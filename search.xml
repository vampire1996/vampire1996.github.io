<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Web Service学习]]></title>
    <url>%2Fblog%2F2019%2F03%2F25%2Fwebservice%2F</url>
    <content type="text"><![CDATA[建立工程和使用参考访问上图URI+services(localhost:8080/WebServiceTest_war_exploded/services)即可实现对服务页面的访问。]]></content>
      <categories>
        <category>web service</category>
      </categories>
      <tags>
        <tag>-web service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机视觉与深度学习]]></title>
    <url>%2Fblog%2F2019%2F03%2F24%2FCVAndDeeplearning%2F</url>
    <content type="text"><![CDATA[软件安装Ubuntu16.04下安装PyTorch 参考解决pytorch安装问题参考 参考2 注意在网上搜索清华镜像,把上面网站都试一试Ubuntu16.04下安装PyTorch 参考]]></content>
      <categories>
        <category>computer vision and deep learning</category>
      </categories>
      <tags>
        <tag>-computer vision -deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux学习]]></title>
    <url>%2Fblog%2F2019%2F03%2F23%2FlinuxLearning%2F</url>
    <content type="text"><![CDATA[修改下载源文件sources.list注意要以root用户打开文件 参考镜像源文件(注意要根据ubuntu系统选择源,我现在的版本是18.04) 清华大学开源软件镜像站 vim命令复制粘贴(在普通模式下)123yy 复制一行dd 删除一行p 在当前行后粘贴之前复制的内容 i-insert 进入插入模式(可编辑)，按esc退出，进入普通模式 win10创建linux子系统参考注意源要和ubuntu系统适配 安装linux双系统UEFI模式下安装，要根据U盘制作的类型选择是legacy还是UEFI参考解决开机黑屏参考解决重复登录问题参考]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>-linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓学习]]></title>
    <url>%2Fblog%2F2019%2F02%2F18%2FandroidLearning%2F</url>
    <content type="text"><![CDATA[使用OkHttp进行Http访问当访问某一地址时失败，需要在AndroidManifest.xml文件中添加1android:usesCleartextTraffic="true" 参考 使用ADB命令行win+r进入cmd界面，cd命令进入Android SDK目录下，接下来再进入platform-tools目录接下来即可使用adb命令。 完全卸载已在设备上安装的App1adb uninstall com.example.coolweather 无法修改应用图标用adb命令完全卸载app后，重命名包名再重新安装app参考 下载七牛云空间中的公开资源找到外链默认域名或自定义绑定的域名，域名+文件名即为访问该文件的url，直接进行http访问即可。也可以在七牛云中进入存储空间，内容管理+操作+点击显示更多操作+复制外链查看该文件对应的url。 linux访问windows中文件‘’’doscd /mnt/d #访问D盘cd /mnt/c #访问C盘‘’’ 打开图形界面1.打开xfce4桌面1xfce4-session 2.打开compiz`compiz···]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>-Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Letter0]]></title>
    <url>%2Fblog%2F2019%2F02%2F08%2Fletter0%2F</url>
    <content type="text"><![CDATA[亲爱的鱼鱼: 一年一度的情人节又到了，不知道你有没有想找个人一起度过呢？哈哈，没有鲜花也没有礼物，和你说说心里话吧。 距离我们相识也有一段时间了，虽然只是网上聊天，但是隔着屏幕我也能感受到你的善良和温油(不知道有没有猜错)。我们每天分享彼此的生活，诉说各自的心事，可能在彼此心里都描绘出了一个对方的形象，但是就像我之前说的，只是管中窥豹，但必须承认和你交流给我的生活带来了更多的色彩，让我觉得也许爱情并不遥远。我记得有人说幸福就是每天醒来都满怀希望的开始新的一天，而你就是那个甜甜的希望。 与你的相遇是我之前人生没有过的体验，几乎没有女生主动找我聊过天，也没有人像你这样时时刻刻都考虑到我的感受。我知道这是你的天性，但是还是有点小私心希望你能只对我这样hhh。我总在想你这样善良的女生如果遇到生活黑暗丑陋的一面怎么办？但是通过对你个人经历的了解我觉得可能你总能找到方法解决问题或者说你已经习惯出淤泥而不染永远保持对真善美的追求，做一个文能插花，武能上山采摘的奇女子. 在我们的谈话中你总是说自己是学渣，菜鸡等等看低自己的话。我觉得你完全没有必要担心或者对自己感到不自信，因为就我个人经验来说，只要一直保持努力向上的心态，让自己进入一个优秀而出色的集体，肯定会不断进步，成为自己想变成的那个人。因为人生是一场长跑，一时的落后并不重要，重要的是要做笑到最后的那个人，当然也希望我们能彼此监督，共同进步，不论是学习还是生活。 最后，希望如果我们足够幸运，明年的今天我能陪在你身边，过一个真正意义上的情人节(小鲜花，小礼物搞起来)，也希望当未来某一天你看到这些话的时候，会感到甜蜜。]]></content>
      <categories>
        <category>Letter</category>
      </categories>
      <tags>
        <tag>-Letter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 117. Populating Next Right Pointers in Each Node II]]></title>
    <url>%2Fblog%2F2019%2F01%2F14%2Fleetcode117%2F</url>
    <content type="text"><![CDATA[117. Populating Next Right Pointers in Each Node II python solution123456789101112131415161718192021222324252627282930313233# Definition for binary tree with next pointer.# class TreeLinkNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# self.next = None"""思路整理 BFS+Queue1)利用队列 存储每一代的节点 2)对于每一代节点 迭代执行： i.node为当前节点 pre为其左侧的节点 ii.令pre指向node即可 最后一个节点指向空Explanation1)use queue to store the node's in one certain generation2)for each,generation,iteratively conduct: i.node is current node and pre is the node in its left side ii.let pre points to node and let the last node points to null"""class Solution: # @param root, a tree link node # @return nothing def connect(self, root): if not root:return queue=[root] while queue: length=len(queue) for i in range(length): node=queue.pop(0) if i!=0:pre.next=node if node.left:queue.append(node.left) if node.right:queue.append(node.right) pre=node java solution123456789101112131415161718192021222324252627282930313233343536/** * Definition for binary tree with next pointer. * public class TreeLinkNode &#123; * int val; * TreeLinkNode left, right, next; * TreeLinkNode(int x) &#123; val = x; &#125; * &#125; *///level traversalpublic class Solution &#123; public void connect(TreeLinkNode root) &#123; TreeLinkNode dummy=new TreeLinkNode(0); while(root!=null) &#123; TreeLinkNode cur=dummy; System.out.println(root.val); while(root!=null) &#123; if(root.left!=null) &#123; cur.next=root.left; cur=cur.next; &#125; if(root.right!=null) &#123; cur.next=root.right; cur=cur.next; &#125; root=root.next; &#125; root=dummy.next; //dummy.next必需置为null因为到最后一个level必须将dummy.next置为null才能推出循环 root=null dummy.next = null; &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA进行android开发]]></title>
    <url>%2Fblog%2F2019%2F01%2F11%2FideaAndroid%2F</url>
    <content type="text"><![CDATA[配置Gradle新建项目无法运行出现Failed to find Build Tools revision 27.0.3的解决方法参考本地下载的builtool版本就是buildToolsVersion “28.0.3” 出现多个gradle报错“Error:Gradle distribution ‘https\://services.gradle.org/distributions/gradle-4.4-all.zip’ contains too many directories. Expected to find exactly 1 directory.”解决方法：将gradle-4.4-all.zip中的__MACOSX 文件夹删除。]]></content>
      <categories>
        <category>android开发</category>
      </categories>
      <tags>
        <tag>-android开发 -IntelliJ IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 300. Longest Increasing Subsequence]]></title>
    <url>%2Fblog%2F2019%2F01%2F08%2Fleetcode300%2F</url>
    <content type="text"><![CDATA[300. Longest Increasing Subsequence python solution12345678910111213141516171819202122232425262728class Solution(object): def lengthOfLIS(self, nums): """ :type nums: List[int] :rtype: int """ """ 思路整理:DP O(n^2) Input: [10,9,2,5,3,7,101,18] cur=[1,1,1,2,2,3,4,4] 1)用cur存储每个位置到该位置时的最大子序列长度 2)对于每个nums[i] 找到其之前nums中每个小于其的位置j,对应cur[j]+1即为 从从j到i的长度 而cur[i]需要找到所有这些长度中最大的值 Explanation 1)we use cur to store lis in each position in nums 2)for each nums[i],we need to find all nums[j]&lt;nums[i] and cur[j]+1 is the length form nums[j] to nums[i],and we need to find the longest length among all cur[j]+1 """ if not nums:return 0 cur=[1 for i in range(len(nums))] length=1 for i in range(1,len(nums)): for j in range(i): if nums[j]&lt;nums[i]: if cur[j]+1&gt;cur[i]: cur[i]=cur[j]+1 if cur[i]&gt;length:length=cur[i] return length java solution1234567891011121314151617181920212223242526272829303132/*DP O(nlogn)tails用于存放所有递增子序列的最小值tails[i] 存放长度为i+1的递增子序列最小值(在nums中)Input:nums = [4,5,6,3]len = 1 : [4], [5], [6], [3] =&gt; tails[0] = 3len = 2 : [4, 5], [5, 6] =&gt; tails[1] = 5len = 3 : [4, 5, 6] =&gt; tails[2] = 6利用二分查找(1)当num&gt;所有tails 则tails.append(num) Size++(2)当 tails[i-1]&lt;num&lt;=tails[i] tails[i]=num*/class Solution &#123; public int lengthOfLIS(int[] nums) &#123; int[] tails=new int[nums.length]; int Size=0; for(int num:nums) &#123; int i=0,j=Size; while(i&lt;j) &#123; int m=i+(j-i)/2; //最终跳出循环时i=j 因此若tails[m]==num则j=m最终i=j=m if(tails[m]&lt;num) i=m+1; else j=m; &#125; tails[i]=num; if(i==Size)Size++; &#125; return Size; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 90. Subsets II]]></title>
    <url>%2Fblog%2F2019%2F01%2F06%2Fleetcode90%2F</url>
    <content type="text"><![CDATA[90. Subsets II python solution123456789101112131415161718192021222324252627class Solution(object): def subsetsWithDup(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ """ 思路整理:DFS recursion 1)对nums进行排序以避免nums中重复元素不聚集在一起如[1,2,4,4,3,4] 2)从nums中依次取出元素加到path中进行DFS 3)对于重复元素如[1,2,2]中的2，res中每个以2为开头的数组的只取nums的第一个2 Explanation 1)sort nums to gather all same number together 2)take numbers from nums iteratively and use them to conduct DFS 3)for same numbers like 2 in [1,2,2],each array only take the first 2 as its first 2 """ def helper(start,end,path,res): res.append(path) for i in range(start,end): if i!=start and nums[i]==nums[i-1]:continue helper(i+1,end,path+[nums[i]],res) return res=[] nums.sort() helper(0,len(nums),[],res) return res java solution123456789101112131415161718192021222324252627282930/*对于无重复元素的n维数组 有2^n个子数组 因为每个元素在每个子数组里都只有出现或者不出现两种可能而对于有重复元素的数组如[1,2,2](1)[](2)[] [1] 复制一份[] 并向其中加入1(3)[] [1] [2] [1,2] 复制一份[] [1] 并向其中加入2(3)[] [1] [2] [1,2] [2,2] [1,2,2]对于重复元素 只向前一次添加过与其相同元素的数组中添加该元素复制一份[2] [1,2] 并向其中加入2*/class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;List&lt;Integer&gt;&gt;(); int start=0; res.add(new ArrayList&lt;Integer&gt;()); Arrays.sort(nums); for(int i=0;i&lt;nums.length;i++) &#123; if(i==0||nums[i]!=nums[i-1]) start=0; int size=res.size(); for(int j=start;j&lt;size;j++) &#123; List&lt;Integer&gt; temp=new ArrayList&lt;Integer&gt;(res.get(j)); temp.add(nums[i]); res.add(temp); &#125; start=size; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日记]]></title>
    <url>%2Fblog%2F2018%2F12%2F31%2Fpoem3%2F</url>
    <content type="text"><![CDATA[海子 姐姐, 今夜我在德令哈, 夜色笼罩姐姐, 我今夜只有戈壁草原尽头我两手空空悲痛时握不住一颗泪滴姐姐, 今夜我在德令哈这是雨水中一座荒凉的城除了那些路过的和居住的德令哈……今夜这是唯一的, 最后的, 抒情这是唯一的, 最后的, 草原我把石头还给石头让胜利的胜利今夜青稞只属于他自己一切都在生长今夜我只有美丽的戈壁 空空姐姐, 今夜我不关心人类, 我只想你]]></content>
      <categories>
        <category>poem</category>
      </categories>
      <tags>
        <tag>-poem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我有一个不到一百斤的理想]]></title>
    <url>%2Fblog%2F2018%2F12%2F31%2Fpoem2%2F</url>
    <content type="text"><![CDATA[逆水谣 借一碗馄饨面，扑灭我的忧伤撒一把小虾米，助我去远洋回忆起昨夜的甜点，本该充满甜蜜的力量却为何在望向今天的糖果时，忍不住迷茫 我有一个，不到一百斤的理想恶魔却挥舞着香甜，摧毁这志向我只能向橱窗里的美丽，轻轻的挥一挥手等着我战胜了邪恶，再接你回家箱 或许我的余生，将在战斗中激荡或许我的梦想，只会增加重量或许我的期待，已穿在了别人的身上或许下一刻的我，已经沦为恶魔的臂膀 悲哀啊，天命如此难挡绽放吧，味蕾上的欲望悔恨吗？那些擦肩而过的漂亮请安慰我！这人生的，路还长……]]></content>
      <categories>
        <category>poem</category>
      </categories>
      <tags>
        <tag>-poem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[老电影]]></title>
    <url>%2Fblog%2F2018%2F12%2F31%2Fpoem1%2F</url>
    <content type="text"><![CDATA[逆水谣 无所事事的咖啡杯蜷缩在沙发上的腿 白天不开窗子的电脑前看着那部电影，回味 舌尖有着葡萄干的甜蜜用来遮掩着苦涩的嘴 手指在把发尾缠绕着纠结着还没播到的伤悲 有时酸涩会化作眼泪有些记忆会酝酿得甜美 那些曾经两个人共同看过的老电影一个人看的时候，只会是微笑着流泪]]></content>
      <categories>
        <category>poem</category>
      </categories>
      <tags>
        <tag>-poem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 279. Perfect Squares]]></title>
    <url>%2Fblog%2F2018%2F12%2F29%2Fleetcode279%2F</url>
    <content type="text"><![CDATA[279. Perfect Squares python solution123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution(object): def numSquares(self, n): """ :type n: int :rtype: int """ """ O(n^3) 思路整理: 1)用nums存储小于根号n取整的所有整数的平方和 2)迭代执行O(n) 以nums[i]为组成n的平方数中的最大值 j=i 迭代执行O(j) 找到以nums[0:j+1]中平方数组成n-nums[i]的最小平方数个数--O(j) Explanation 1)use nums to store all square numbers of integers which are less than int(sqrt(n)) 2)iteratively conduct take nums[i] as the largest number as a part of n iteratively conduct find the smallest number of n-nums[i]'s square numbers using nums[0:j+1] """ def helper(nums,lo,hi,temp): if temp==0:return 0 i=hi cnt=0 while i&gt;=lo: if temp-nums[i]&gt;0: temp-=nums[i] cnt+=1 continue elif temp-nums[i]==0:break else:i-=1 return cnt+1 num=int(math.sqrt(n)) nums=[i*i for i in range(1,num+1)] cnt=2e31 i=num-1 while i&gt;=0: j=i while j&gt;=0: cur=helper(nums,0,j,n-nums[i]) if cur+1&lt;cnt:cnt=cur+1 j-=1 i-=1 return cnt python3 solution1234567891011121314151617181920class Solution: _dp=[0] def numSquares(self, n): """ :type n: int :rtype: int """ """ static dynamic programming 用dp数组存储每一个数到该位置所需的最小平方数个数 那么dp[j]=min(dp[j-i*i])+1 1&lt;=i*i&lt;=j j=j-i*i+i*i 也就是说每个数都可以由cnt[j-i*i]+1得到一个平方数和的方案 找到其中最小的个数即可 这里利用静态变量_dp，只需初始化一次 当之前有testcase调用之后，之前的_dp继续可以用与下一次 testcase使用,因此可以减少时间 """ mincnt=self._dp while len(mincnt)&lt;=n: mincnt+=[min(mincnt[-i*i] for i in range(1,int(len(mincnt)**0.5)+1))+1] return mincnt[n] java solution1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class Solution &#123; public int numSquares(int n) &#123; return LagrangeFourSquareTheorem(n); &#125; /* 广度优先搜索 search search Input: n = 13 1 2(1+1) 4 5(1+4) 9 10(1+9) cnt=1 13(9+3) 结果为2 cnt=2 */ private int bfs(int n) &#123; if(n&lt;=0)return 0; List&lt;Integer&gt; squares=new ArrayList&lt;Integer&gt;(); boolean visited[]=new boolean[n]; for(int i=1;i*i&lt;=n;i++) &#123; if(i*i==n)return 1; squares.add(i*i); &#125; Queue&lt;Integer&gt; search = new LinkedList&lt;Integer&gt;(); for(int i=1;i*i&lt;=n;i++)search.add(i*i); int curCnt=1; while(!search.isEmpty()) &#123; curCnt++; int searchSize=search.size(); for(int i=0;i&lt;searchSize;i++) &#123; int tmp=search.peek(); //当前search中某一数加上一个平方数如果等于n则搜索结束 for(int square:squares) &#123; if(tmp+square==n) &#123; return curCnt; &#125; //visited 用于存储是否访问过某一节点，如果访问过则不再访问 else if(tmp+square&lt;n&amp;&amp;visited[tmp+square-1]==false) &#123; search.add(tmp+square); visited[tmp+square-1]=true; &#125; else if(tmp+square&gt;n) break; &#125; search.remove(); &#125; &#125; return 0; &#125; //Lagrange 四平方定理： 任何一个正整数都可以表示成不超过四个整数的平方之和。 //O(n) private int LagrangeFourSquareTheorem(int n) &#123; int ub=(int)Math.sqrt(n);//upper bound for(int a=0;a&lt;=ub;a++) &#123; for(int b=a;b&lt;=ub;b++) &#123; //因为a,b都是从0开始的,所以返回时的数一定是最小的 int c=(int)Math.sqrt(n-a*a-b*b); if(a*a+b*b+c*c==n) &#123; return (a==0?0:1)+(b==0?0:1)+(c==0?0:1); &#125; &#125; &#125; //超过3个只能是4 return 4; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 213. House Robber II]]></title>
    <url>%2Fblog%2F2018%2F12%2F27%2Fleetcode213%2F</url>
    <content type="text"><![CDATA[213. House Robber II python solution12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution(object): def rob(self, nums): """ :type nums: List[int] :rtype: int """ """ O(n) time complexity O(n) space complexity 思路整理 1)计算某一位置最大金钱的方法是 max(pre[i-2],pre[i-3])+nums[i] pre[i]为本位置可获得的最大金钱,由于不能找与其相邻的位置，因此只能找pre[i-2],pre[i-3] 2)由于题目中说明第一个和最后一个元素也是相邻的 所以利用maxMoney1存储从第一个元素开始到倒数第二个元素每个位置可获得最大金钱 maxMoney2存储从第二个元素开始到最后一个元素每个位置可获得最大金钱 则max(max(maxMoney1[-1],maxMoney1[-2]),max(maxMoney2[-1],maxMoney2[-2])) 倒数第三个元素及之前的元素都会被最后两个元素覆盖 即为总体可获得的最大金钱 理由:从第一个元素开始的某一条抢劫路径不可能到达最后，所以包含最后元素就不包含第一个元素 包含第一个元素就不包含最后一个元素 Explanation Input abcdefgh maxMoney1 bcdefgh to get the maximum in each position maxMoney2 abcdefg when you start at the beginning of the array,you can just raech the (n-1)th position and if you start at the second position,you can reach the last position """ if not nums:return 0 if len(nums)&lt;=3:return max(nums) maxMoney1,maxMoney2=[],[0] for i in range(len(nums)): if i==0:maxMoney1.append(nums[i]) elif i==1: maxMoney1.append(nums[i]) maxMoney2.append(nums[i]) elif i==2: maxMoney1.append(nums[i]+nums[i-2]) maxMoney2.append(nums[i]) elif i==3 and i!=len(nums)-1: if maxMoney1[i-2]&gt;maxMoney1[i-3]: maxMoney1.append(nums[i]+maxMoney1[i-2]) else: maxMoney1.append(nums[i]+maxMoney1[i-3]) maxMoney2.append(nums[i]+nums[i-2]) elif i&lt;len(nums)-1: if maxMoney1[i-2]&gt;maxMoney1[i-3]: maxMoney1.append(nums[i]+maxMoney1[i-2]) else: maxMoney1.append(nums[i]+maxMoney1[i-3]) if maxMoney2[i-2]&gt;maxMoney2[i-3]: maxMoney2.append(nums[i]+maxMoney2[i-2]) else: maxMoney2.append(nums[i]+maxMoney2[i-3]) else: if maxMoney2[i-2]&gt;maxMoney2[i-3]: maxMoney2.append(nums[i]+maxMoney2[i-2]) else: maxMoney2.append(nums[i]+maxMoney2[i-3]) return max(max(maxMoney1[-1],maxMoney1[-2]),max(maxMoney2[-1],maxMoney2[-2])) java solution1234567891011121314151617181920//用rob(k)代表截止到第k个位置最大的抢劫金额//rob(k) = max( rob(k-2) + nums[k], rob(k-1) )class Solution &#123; public int rob(int[] nums) &#123; if(nums.length==1)return nums[0]; return Math.max(helper(nums,1,nums.length-1),helper(nums,0,nums.length-2)); &#125; private int helper(int[] nums,int lo,int hi) &#123; int pre_i1=0,pre_i2=0; for(int i=lo;i&lt;=hi;i++) &#123; int cur=Math.max(nums[i]+pre_i2,pre_i1); int temp=pre_i1; pre_i1=cur; pre_i2=temp; &#125; return pre_i1; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 151. Reverse Words in a String]]></title>
    <url>%2Fblog%2F2018%2F12%2F26%2Fleetcode151%2F</url>
    <content type="text"><![CDATA[151. Reverse Words in a String python solution1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution(object): def reverseWords(self, s): """ :type s: str :rtype: str """ """ 思路整理: 1)由于字符串是不可修改的 因此需要将其转换为数组 2)将整个数组翻转l[:]=l[::-1] 3)将每个单词翻转 4)排除掉前缀和后缀中的空格 5)排除掉两个单词间多余一个的空格 Explanation 1)because string can not be modified,we need to reverse it to a list 2)reverse the whole list 3)reverse each word in the list 4)redeuce the leading or trailing spaces 5)reduce multiple spaces between two words """ def reverse_string(arr, l, r): '''reverse a given string''' while l &lt; r: arr[l], arr[r] = arr[r], arr[l] l += 1 ; r -= 1 if not s:return s l=list(s) l[:]=l[::-1] length=len(s) i=0 #将每个单词翻转 while i&lt;length: if l[i]==' ': i+=1 continue j=i+1 while j&lt;length and l[j]!=' ':j+=1 reverse_string(l, i, j-1) i=j #排除掉前缀和后缀中的空格 start,end=0,length-1 while start&lt;length and l[start]==' ':start+=1 while end&gt;=0 and l[end]==' ':end-=1 if start==length or end&lt;0:return "" #排除掉两个单词间多余一个的空格 res=[l[start]] for i in range(start+1,end+1): if res[-1]==' ' and l[i]==' ':continue res.append(l[i]) return "".join(res) java solution123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Solution &#123; /* 1)输入为"" 跳过for循环 直接输出out[0]="" 2)输入为"a" 跳过for循环 直接输出out[0]="a" 3)输入为"a b c" for循环结束后res="c b " res+out[0]="c b a" */ public String reverseWords(String s) &#123; return solution2(s); &#125; //利用库函数 private String solution1(String s) &#123; String[] out=s.trim().split("\\s+"); String res=""; for(int i=out.length-1;i&gt;0;i--) &#123; res+=out[i]+" "; &#125; return res+out[0]; &#125; private String solution2(String s) &#123; if(s==null||s.length()==0)return ""; char[] res=s.toCharArray(); reverse(res,0,res.length-1); int start=0,end=0; for(int i=0;i&lt;res.length;i++) &#123; if(res[i]!=' ') &#123; res[end++]=res[i]; &#125; else if(i&gt;0&amp;&amp;res[i-1]!=' ') &#123; reverse(res,start,end-1); res[end++]=' '; start=end; &#125; &#125; reverse(res,start,end-1);//s="the sky is blue" 最后一个单词之前未翻转 //s="" 或s全为空格或s="a b c" res(0,end) //s="a b c " res(0,end-1) return new String(res,0,end&gt;0&amp;&amp;res[end-1]==' '?end-1:end); &#125; private char[] reverse(char[] s,int i,int j) &#123; while(i&lt;j) &#123; char temp=s[i]; s[i]=s[j]; s[j]=temp; i++; j--; &#125; return s; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 200. Number of Islands]]></title>
    <url>%2Fblog%2F2018%2F12%2F25%2Fleetcode200%2F</url>
    <content type="text"><![CDATA[200. Number of Islands python solution123456789101112131415161718192021222324252627282930313233343536373839class Solution(object): def numIslands(self, grid): """ :type grid: List[List[str]] :rtype: int """ """ 思路整理DFS 1)用visited标记所有访问过的'1' 2)利用helper找到所有与当前位置相通的'1'，并在visited中将其标记为已访问 3)在主循环中每次遇到一个未访问过的'1' 执行一次DFS 也就是说找老了一个新的 island 所以num++ Explanation 1)we use 'visited' to store all the positions of visited '1's 2)function helper can help us to find all the '1's which is connected to current '1',and mark them to Ture in 'visited' 3)in main iteration,when we meet a '1' which has not been visited, we call function helper and also ,this means that we find a new island so num++ """ if not grid:return 0 def helper(visited,i,j,row,col): if i&lt;0 or i==row or j&lt;0 or j==col: return if visited[i][j]==True or grid[i][j]=='0':return visited[i][j]=True helper(visited,i+1,j,row,col) helper(visited,i-1,j,row,col) helper(visited,i,j+1,row,col) helper(visited,i,j-1,row,col) visited=[[False for i in range(len(grid[0]))]for j in range(len(grid))] row,col=len(grid),len(grid[0]) num=0 for i in range(row): for j in range(col): if visited[i][j]==True or grid[i][j]=='0':continue helper(visited,i,j,row,col) num+=1 return num python3 solution12345678910111213141516171819202122232425class Solution: def numIslands(self, grid): &quot;&quot;&quot; Python 2.7 doc on map --返回一个列表 &quot;Apply function to every item of iterable and return a list of the results.&quot; Python 3.6 doc on map --返回一个迭代器 &quot;Return an iterator that applies function to every item of iterable, yielding the results.&quot; 在python3中,map返回一个迭代器,将结果不断迭代,计算的结果会作与下次结果叠加 如 Input: 11110 11010 11000 00000 map(sink,(i+1,i-1,i,i),(j,j,j+1,j-1))输出 9(将所有1求和) list(map(sink,(i+1,i-1,i,i),(j,j,j+1,j-1))) 输出 1 &quot;&quot;&quot; def sink(i,j): if 0&lt;=i&lt;len(grid) and 0&lt;=j&lt;len(grid[0]) and grid[i][j]==&apos;1&apos;: grid[i][j]=&apos;0&apos; list(map(sink,(i+1,i-1,i,i),(j,j,j+1,j-1))) return 1 return 0 if not grid:return 0 return sum(sink(i,j) for i in range(len(grid)) for j in range(len(grid[0]))) java solution1234567891011121314151617181920212223242526class Solution &#123; private int row,col; public int numIslands(char[][] grid) &#123; if(grid==null||grid.length==0)return 0; row=grid.length; col=grid[0].length; int islands=0; for(int i=0;i&lt;row;i++) &#123; for(int j=0;j&lt;col;j++) islands+=sink(grid,i,j); &#125; return islands; &#125; private int sink(char[][] grid,int i,int j) &#123; if(i&lt;0||i==row||j&lt;0||j==col||grid[i][j]=='0')return 0; grid[i][j]='0'; for(int k=0;k&lt;4;k++) &#123; sink(grid,i+d[k],j+d[k+1]); &#125; return 1; &#125; int[] d=&#123;1,0,-1,0,1&#125;;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 80. Remove Duplicates from Sorted Array II]]></title>
    <url>%2Fblog%2F2018%2F12%2F25%2Fleetcode80%2F</url>
    <content type="text"><![CDATA[80. Remove Duplicates from Sorted Array II python solution123456789101112131415161718192021222324252627282930313233343536373839404142class Solution(object): def removeDuplicates(self, nums): """ :type nums: List[int] :rtype: int """ """ 思路整理 1)length为要返回的长度 cnt为连续元素相等的子数组长度 pre为当前元素前一个元素的值 2)当前元素和pre相等且之前只有一个一个与之相同的元素(pre) 令nums[length]=nums[i] length代表当前已经符合要求的长度 因此这句话代表将当前元素赋值给符合要求长度部分的下一个元素 此时length长度+1 3)当前元素和pre不等 令nums[length]=nums[i] 且相应修改pre length cnt的值 Explanation 1)lenght represents the length we will return cnt represents the length of subarray whose elements are constantly equal pre represents the previous number before nums[i] 2)if nums[i]==pre and cnt==1:#only one number before nums[i] equals to nums[i] set nums[length]=nums[i],length represents the length of the subarray which has arranged according the given requiremnet,after this lenght=length 3)if nums[i]!=pre set nums[length]=nums[i],and change pre,length,cnt """ if not nums:return length,pre,cnt=1,nums[0],1 for i in range(1,len(nums)): if nums[i]==pre and cnt==1: nums[length]=nums[i] cnt+=1 length+=1 elif nums[i]!=pre: nums[length]=nums[i] pre=nums[i] length+=1 cnt=1 return length java solution12345678910111213141516171819202122232425class Solution &#123; public int removeDuplicates(int[] nums) &#123; /* nums[i-2] nums[i-1] nums[i] a a a a b b a b c 只要nums[i]&gt;nums[i-2] nums[i]即为符合题目要求的元素 需要加到符合当前要求序列的末端 然鹅这里nums[i-2]可能已经别修改过了 Given nums = [1,1,1,2,2,3] 到nums[4]的时候 nums = [1,1,2,2,2,3] 所以应该改为nums[length-2] nums[length-1] nums[i],原理同上 */ int length=0; for(int num:nums) &#123; if(length&lt;2||num&gt;nums[length-2]) &#123; nums[length++]=num; &#125; &#125; return length; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 152. Maximum Product Subarray]]></title>
    <url>%2Fblog%2F2018%2F12%2F24%2Fleetcode152%2F</url>
    <content type="text"><![CDATA[152. Maximum Product Subarray python solution12345678910111213141516171819202122232425262728293031323334class Solution(object): def maxProduct(self, nums): """ :type nums: List[int] :rtype: int """ """ 思路整理 只有两种可能 大写为整数 小写 1)负数的个数为奇数nums=[a,B,c,D,e,F,g,H,i] 对于nums必然可以转换为[A,b]或者[a,B]的形式 (任意一对负数可以组合成一个正数) 而forward记录正向乘积 back记录反向乘积 即可记录A,B这些值中的最大值 2)负数的个数为偶数 将所有数乘起来即可 Explanation there are only two possible situations: 1)the number of negetive numbers are even nums=[a,B,c,D,e,F,g,H,i] num can be transfered to [A,b]or[a,B] we use back and forward to claculate the back product and forward product.so we can use them to find the maximum in A,B's 2)he number of negetive numbers are odd nums=[a,B,c,D,e,F,g,H,i] just return the product of all nums """ res=-2e31 forward,back=1,1 l=len(nums) for i in range(l): forward*=nums[i] back*=nums[l-i-1] res=max([res,forward,back]) if back==0:back=1 if forward==0:forward=1 return res java solution12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int maxProduct(int[] nums) &#123; int res=nums[0]; /* 用min max存储当前最大和最小的乘积 如果nums[i]&lt;0 则nums[i]*max&lt;nums[i]*min因此需要将max和min交换 如果nums[i]=0 max=Math.max(nums[i],nums[i]*max)=0; min=Math.min(nums[i],nums[i]*min)=0; 若nums[i+1]&gt;0 max=Math.max(nums[i+1],nums[i+1]*max)=nums[i+1]; min=Math.min(nums[i+1],nums[i+1]*min)=0; 若nums[i+1]&lt;0 max=Math.max(nums[i+1],nums[i+1]*max)=0; min=Math.min(nums[i+1],nums[i+1]*min)=nums[i+1]; min和max中一定有一个保存nums[i+1] 在接下来的运算中不会会略掉nums[i+1],巧妙地避开了nums[i]=0的情况 */ int max=res,min=res; for(int i=1;i&lt;nums.length;i++) &#123; if(nums[i]&lt;0) &#123; int temp=max; max=min; min=temp; &#125; max=Math.max(nums[i],nums[i]*max); min=Math.min(nums[i],nums[i]*min); res=Math.max(res,max); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 116. Populating Next Right Pointers in Each Node]]></title>
    <url>%2Fblog%2F2018%2F12%2F24%2Fleetcode116%2F</url>
    <content type="text"><![CDATA[116. Populating Next Right Pointers in Each Node python solution12345678910111213141516171819202122232425262728293031323334353637# Definition for binary tree with next pointer.# class TreeLinkNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# self.next = None"""思路整理 BFS+Queue1)利用队列 存储每一代的节点 2)对于每一代节点 迭代执行： i.node为当前节点 pre为其左侧的节点 ii.令pre指向node即可 最后一个节点指向空Explanation1)use queue to store the node's in one certain generation2)for each,generation,iteratively conduct: i.node is current node and pre is the node in its left side ii.let pre points to node and let the last node points to null"""class Solution: # @param root, a tree link node # @return nothing def connect(self, root): if not root:return queue=[root] while queue: #range(len(queue)) 生成[0,...len(queue)-1]可迭代的列表 #不会因为len(queue)改变而改变 for i in range(len(queue)): node=queue.pop(0) if node.left: queue.append(node.left) queue.append(node.right) if i&gt;0:pre.next=node pre=node #下面这句话可加可不加 因为初始化的时候 next就是null #pre.next=None java solution1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * Definition for binary tree with next pointer. * public class TreeLinkNode &#123; * int val; * TreeLinkNode left, right, next; * TreeLinkNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public void connect(TreeLinkNode root) &#123; bfs(root); &#125; //dfs 0ms O(n) time complexity O(1) space complexity /* 1 -&gt; NULL 1 -&gt; NULL 1 -&gt; NULL / \ ---&gt; / \ ---&gt; / \ 2 3 -&gt; NULL 2 -&gt; 3 -&gt; NULL 2 -&gt; 3 -&gt; NULL / \ / \ / \ / \ / \ / \ 4 5 6 7 -&gt; NULL 4 5 6 7 -&gt; NULL 4-&gt;5-&gt;6 7 -&gt; NULL 1 -&gt; NULL / \ 2 -&gt; 3 -&gt; NULL / \ / \ 4-&gt;5-&gt;6-&gt;7 -&gt; NULL */ private void dfs(TreeLinkNode root) &#123; if(root==null)return; //把当前节点的左节点指向右节点 if(root.left!=null)root.left.next=root.right; //把当前节点的右节点指向当前节点右节点的左节点 if(root.right!=null&amp;&amp;root.next!=null)root.right.next=root.next.left; dfs(root.left); dfs(root.right); &#125; //bfs 1ms O(n) time complexity O(1) space complexity /* 1 -&gt; NULL 1 -&gt; NULL 1 -&gt; NULL / \ ---&gt; / \ ---&gt; / \ 2 3 -&gt; NULL 2 -&gt; 3 -&gt; NULL 2 -&gt; 3 -&gt; NULL / \ / \ / \ / \ / \ / \ 4 5 6 7 -&gt; NULL 4 5 6 7 -&gt; NULL 4-&gt;5-&gt;6-&gt;7 -&gt; NULL */ private void bfs(TreeLinkNode root) &#123; if(root==null)return; TreeLinkNode cur=root; while(root!=null) &#123; while(cur!=null) &#123; if(cur.left!=null)cur.left.next=cur.right; if(cur.right!=null&amp;&amp;cur.next!=null)cur.right.next=cur.next.left; cur=cur.next; &#125; cur=root.left; root=root.left; &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 130. Surrounded Regions]]></title>
    <url>%2Fblog%2F2018%2F12%2F23%2Fleetcode130%2F</url>
    <content type="text"><![CDATA[130. Surrounded Regions python solution1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution(object): def solve(self, board): """ :type board: List[List[str]] :rtype: void Do not return anything, modify board in-place instead. """ """ DFS 思路整理: 1)找到所有未被包围的'O' 而这种'O'只能是从board的第一行，第一列，最后一行，最后一列 出发的一系列'O' 2)从上述位置出发进行DFS 也就是向上 向下 向左 向右移动 看接下来移动到的位置是否是'O' 若不是，则返回 3)利用isSurrounded 存储未被包围和被包围的'O'的位置 将对应位置board中元素置为'X'即可 Explanation 1)try to find all 'O's,which can only be a part of a series of 'O's started from the 1st row.1st column,last row,last column 2)start from one position,try to do BFS,which means that we are trying to move to the left,right,up and down position then check the current element,if it's 'O',set isSurrounded[i][j]=False and continue BFS else return 3)we use isSurrounded to store all positions of surrended 'O's and not surrended 'O's so just set the element to 'X' in corresponding posiotion in board """ def helper(isSurrounded,i,j): if i==0 or j==0 or i==len(board)-1 or j==len(board[0])-1:return if isSurrounded[i][j]==False or board[i][j]=='X':return isSurrounded[i][j]=False helper(isSurrounded,i+1,j) helper(isSurrounded,i,j+1) helper(isSurrounded,i-1,j) helper(isSurrounded,i,j-1) if len(board)&lt;=2 or len(board[0])&lt;=2:return isSurrounded=[[True for i in range(len(board[0]))]for j in range(len(board))] for j in range(1,len(board)-1): if board[j][0]=='O':helper(isSurrounded,j,1) if board[j][len(board[0])-1]=='O':helper(isSurrounded,j,len(board[0])-2) for i in range(1,len(board[0])-1): if board[0][i]=='O':helper(isSurrounded,1,i) if board[len(board)-1][i]=='O':helper(isSurrounded,len(board)-2,i) for j in range(1,len(board)-1): for i in range(1,len(board[0])-1): if board[j][i]=='O': if isSurrounded[j][i]==True:board[j][i]='X' java solution123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution &#123; int[][] dirs=&#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;; public void solve(char[][] board) &#123; if(board==null||board.length==0||board[0]==null||board[0].length==0) return; int row=board.length,col=board[0].length; for(int i=0;i&lt;row;i++) &#123; if(board[i][0]=='O') &#123; dfs(board,i,0); &#125; if(board[i][col-1]=='O') &#123; dfs(board,i,col-1); &#125; &#125; for(int j=0;j&lt;col;j++) &#123; if(board[0][j]=='O') &#123; dfs(board,0,j); &#125; if(board[row-1][j]=='O') &#123; dfs(board,row-1,j); &#125; &#125; for(int i=0;i&lt;row;i++) &#123; for(int j=0;j&lt;col;j++) &#123; if(board[i][j]=='O') &#123; board[i][j]='X'; &#125; else if(board[i][j]=='*') &#123; board[i][j]='O'; &#125; &#125; &#125; &#125; private void dfs(char[][] board,int i,int j) &#123; int m = board.length, n = board[0].length; board[i][j] = '*'; for(int[] dir:dirs) &#123; int x=i+dir[0]; int y=j+dir[1]; if(x&lt;0||x==m||y&lt;0||y==n|| board[x][y] != 'O')continue; dfs(board,x,y); &#125; &#125; &#125; python3 solution1234567891011121314151617181920212223class Solution: def solve(self, board): """ 找到所有未被包围的'O' 将其置为'S' """ #board=[[]] return if not any(board):return row,col=len(board),len(board[0]) save=[ij for k in range(max(row,col)) for ij in ((k,0),(0,k),(row-1,k),(k,col-1))] while save: i,j=save.pop() if 0&lt;=i&lt;row and 0&lt;=j&lt;col and board[i][j]=='O': board[i][j]='S' save.extend([(i-1,j),(i+1,j),(i,j-1),(i,j+1)]) #p=='S'=1 'XO'[1]='O' 之前将未被包围的'O'置为'S'，再将其变回来 #p=='S'=0 'XO'[0]='X' 被包围的'O'置为'X' """ board1[:]=[['XO'[p=='S'] for p in r] for r in board1] board2=[['XO'[p=='S'] for p in r] for r in board2] board1的操作是更改board1内部的值，board2的操作是重新生成一个对象赋值给board2 board2指向的地址还是原来的 """ board[:]=[['XO'[p=='S'] for p in r] for r in board]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 209. Minimum Size Subarray Sum]]></title>
    <url>%2Fblog%2F2018%2F12%2F22%2Fleetcode209%2F</url>
    <content type="text"><![CDATA[209. Minimum Size Subarray Sum python solution1234567891011121314151617181920212223242526272829303132333435class Solution(object): def minSubArrayLen(self, s, nums): """ :type s: int :type nums: List[int] :rtype: int """ """ O(nlogn) 1)用numSum存储nums从第一个元素到第i个元素的和 2)利用二分查找找到与当前nums[i]相差大于等于s的最小索引end 也就是end-i为满足nums[i+1]+...nums[end]&gt;=s 的最小值 3)如果二分查找结果end==length+1 也就是说sum(nums)&lt;s 无法找到符合条件的子数组 4)二分查找一定会找到大于等于numSum[i]+s的最小索引，证明如下 numSum[i]=4 numSum[i+1]=6 target=5 lo=mi=i hi=6 numSum[mi]=4&lt;5 lo=mi+1=i+1退出 返回i+1 由于在如下二分查找算法中 取值范围是[lo,hi) 所以mi不会取到hi """ if not nums:return 0 def binarySearch(numSum,lo,hi,target): while lo&lt;hi: mi=lo+int(hi-lo)/2 if numSum[mi]&gt;=target:hi=mi else:lo=mi+1 return lo length,l=len(nums),2147483647 hi,lo=length,0 numSum=[0 for i in range(length+1)] for j in range(1,length+1):#O(n) numSum[j]=nums[j-1]+numSum[j-1] for i in range(length): end=binarySearch(numSum,i+1,length+1,numSum[i]+s) if end==length+1:break if end-i&lt;l:l=end-i return l if l!=2147483647 else 0 python3 solution123456789101112131415161718192021222324252627282930313233343536373839class Solution: def minSubArrayLen(self, s, nums): """ :type s: int :type nums: List[int] :rtype: int """ """ O(n) solution 思路整理: 1)若nums所有元素之和小于s 则不会有邻接的子序列满足sum&gt;=s 2)用numSum存储nums从第一个元素到第i个元素的和 3)numSum[end]-numSum[start] 即为从start开始到end 结束的子序列的和 如果numSum[end]-numSum[start]&gt;=s 则从start到end的序列为满足要求的序列 因此start++ 从新的位置开始计算是否符合要求 否则 end++ 继续扩展当前序列 Explanation 1)if the sum of nums is less then s, so there is no contiguous subarray of which the sum ≥ s 2)we use numSum to store the sum from the first element to the ith element 3)numSum[end]-numSum[start] represents the sum of subarray nums[start:end] if numSum[end]-numSum[start]&gt;=s,nums[start:end] satisfies the requirement so,start++,we will calculate from a new position else end++,expand the current subarray """ if not nums or sum(nums)&lt;s:return 0 length,l=len(nums),len(nums) start,end=0,1 numSum=[0 for i in range(length+1)] for j in range(1,length+1):#O(n) numSum[j]=nums[j-1]+numSum[j-1] #只有两种情况 end++ 或者start++ #因此当end 和start都为len(nums)也不过是2*len(nums)次循环 while end&lt;=length and start&lt;end: if numSum[end]-numSum[start]&gt;=s: if l&gt;end-start:l=end-start start+=1 else:end+=1 return l java solution123456789101112131415161718class Solution &#123; public int minSubArrayLen(int s, int[] nums) &#123; if(nums==null||nums.length==0)return 0; int start=0,end=0; int sum=0,min=Integer.MAX_VALUE; while (end&lt;nums.length) &#123; sum+=nums[end++]; //注意这里是while 不是if while(sum&gt;=s) &#123; min=Math.min(min,end-start); sum-=nums[start++]; &#125; &#125; return (min==Integer.MAX_VALUE)?0:min; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 357. Count Numbers with Unique Digits]]></title>
    <url>%2Fblog%2F2018%2F12%2F22%2Fleetcode357%2F</url>
    <content type="text"><![CDATA[357. Count Numbers with Unique Digits python solution123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution: def countNumbersWithUniqueDigits(self, n): """ :type n: int :rtype: int """ """ 思路整理 1.若输入位数大于1 1)res第一部分是 从0-9 10个数字中取出n个数字并进行全排列combine(10,n)*factorial(n) 2)以上全排列只能包括n位中只有1个0的情况 接下来计算n位中多个0的情况 i. 0x.... x不能是0 且x之后的数位必须含一个0 因此0可以有(n-2)个位置 0之后数位必须有一个0 其余从1-9中取n-2个数进行全排列即可 combine(9,n-1)*factorial(n-2)*(n-2) ii. 00.... 因为已经有两个0 所以之后n-2位迭代执行 最高位必须为1-9 任意一个数 剩下的i-1位 从0-9 中除了上面取出的那个数中取i-1个数 并全排列 9*combine(9,i-1)*factorial(i-1) 2.若输入位数等于1 直接返回10 Explanation if n&gt;1 1)the first part is taking n numbers in 0-9 and taking purmutaion of them combine(10,n)*factorial(n) 2)the upper situation only considers the condition of one 0 then we talk about the condition when ther are more than 2 0's i. 0x.... x cannot be 0 and there must be a 0 after x, so 0 can be placed in n-2 positions, then we just taking n-2 numbers in 1-9 and take purmutaion of them ii. 00.... because there are already 2 0's,so when just iteratively conduct: the highest bit must in 1-9 the rest i-1 bits can anyone but the num in highest bit in 0-9 9*combine(9,i-1)*factorial(i-1) """ def factorial(num): res=1 for i in range(1,num+1): res*=i return res def combine(n,m): temp=min(m,n-m) res=1.0 for i in range(1,temp+1): res*=((n-i+1)/i) return int(res) res=0,0 res=combine(10,n)*factorial(n) for i in range(1,n): if i==n-1:res+=combine(9,i-1)*factorial(i-1)*(i-1) else:res+=9*combine(9,i-1)*factorial(i-1) return res+1 if n&gt;1 else res java solution12345678910111213141516171819202122232425262728/*Following the hint. Let f(n) = count of number with unique digits of length n.f(1) = 10. (0, 1, 2, 3, ...., 9)f(2) = 9 * 9. Because for each number i from 1, ..., 9, we can pick j to form a 2-digit number ij and there are 9 numbers that are different from i for j to choose from.f(3) = f(2) * 8 = 9 * 9 * 8. Because for each number with unique digits of length 2, say ij, we can pick k to form a 3 digit number ijk and there are 8 numbers that are different from i and j for k to choose from.Similarly f(4) = f(3) * 7 = 9 * 9 * 8 * 7....return f(1) + f(2) + .. + f(n)*/class Solution &#123; public int countNumbersWithUniqueDigits(int n) &#123; if(n==0)return 1; int res=10,availableBits=9,pre=9; for(int i=n;i&gt;1;i--,availableBits--) &#123; res+=availableBits*pre; pre*=availableBits; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 113. Path Sum II]]></title>
    <url>%2Fblog%2F2018%2F12%2F21%2Fleetcode113%2F</url>
    <content type="text"><![CDATA[113. Path Sum II python solution1234567891011121314151617181920212223242526272829303132# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = None""" 5 / \ 4 8 / / \ 11 13 4 / \ / \7 2 5 1BFS+queuequeue是先进先出 因此遍历顺序是5-4-8-11-13-4-7-2-5-1 BFS"""class Solution(object): def pathSum(self, root, sum): if not root:return [] queue=[(root,[root.val],sum-root.val)] res=[] while queue: cur,path,num=queue.pop(0)#弹出第一个元素 if not cur.right and not cur.left and num==0: res.append(path) if cur.left: queue.append((cur.left,path+[cur.left.val],num-cur.left.val)) if cur.right: queue.append((cur.right,path+[cur.right.val],num-cur.right.val)) return res python3 solution1234567891011121314151617181920212223242526272829303132# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def pathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: List[List[int]] """ """ 思路整理:DFS recursion 1)用path缓存路径，用num保存路径和 如果当前节点为叶子结点 且路径和为sum 则在res中加入path Explanation we use to cache pat,num to store the sum of path if current node is a leaf and num==sum,just add path to res """ def helper(res,path,node,num): if not node:return if node.left==None and node.right==None: if num+node.val==sum:res.append(path+[node.val]) return helper(res,path+[node.val],node.left,num+node.val) helper(res,path+[node.val],node.right,num+node.val) res=[] helper(res,[],root,0) return res java solution1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; *//* 5 / \ 4 8 / / \ 11 13 4 / \ / \7 2 5 1DFS 由于stack是后进先出 访问次序是5-4-11-7-2-8-13-4-5-1*/class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123; List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;(); if(root==null)return res; Stack&lt;TreeNode&gt; node=new Stack&lt;TreeNode&gt;(); Stack&lt;List&lt;Integer&gt;&gt; path=new Stack&lt;List&lt;Integer&gt;&gt;(); Stack&lt;Integer&gt; num=new Stack&lt;Integer&gt;(); List&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;(); list.add(root.val); node.add(root); path.add(list); num.add(sum-root.val); //push 加到stack头部(top) add加到stack尾部(end) while(!node.isEmpty()) &#123; TreeNode cur=node.pop(); list=path.pop(); int curNum=num.pop(); if(cur.left==null&amp;&amp;cur.right==null&amp;&amp;curNum==0) &#123; res.add(new ArrayList&lt;&gt;(list)); &#125; if(cur.right!=null) &#123; list.add(cur.right.val); node.add(cur.right); path.add(new ArrayList&lt;&gt;(list)); num.add(curNum-cur.right.val); list.remove(list.size()-1); &#125; if(cur.left!=null) &#123; list.add(cur.left.val); node.add(cur.left); path.add(new ArrayList&lt;&gt;(list)); num.add(curNum-cur.left.val); list.remove(list.size()-1); &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 139. Word Break]]></title>
    <url>%2Fblog%2F2018%2F12%2F21%2Fleetcode139%2F</url>
    <content type="text"><![CDATA[139. Word Break python solution12345678910111213141516171819"""DP O(n^2)---1+2+3+...+n思路整理:1)res 存储s中每个位置 到该位置能否分裂成wordDict中单词举个例子：字符串为applepen 和 wordDict为apple，pen。当我们遍历到字母n的时候我们从n开始向前找看看有没有apple：即字符串被分为app和lepen（因为apple的长度为5，我们期待lepen可能为apple，若lepen确实为apple，app也能够被break（即dp[2] = true)，那么我们将dp[7] = true,但lepen不为apple而且dp[2]为false，因此我们循环到下一个wordDict即pen，将字符串划分为前面的apple和后面的pen，而后面的pen确实存在，dp[4] = true，所以确实可以划分，因此dp[7]= true。Input: s = "leetcode", wordDict = ["leet", "code"] dp FFFFTFFFT dp[-1]=True """class Solution(object): def wordBreak(self, s, wordDict): res=[False for i in range(len(s)+1)] res[0]=True for i in range(1,len(s)+1): for j in range(i): if res[j] and s[j:i] in wordDict:res[i]=True return res[len(s)] python3 solution1234567891011121314151617class Solution(object): def wordBreak(self, s, wordDict): """ :type s: str :type wordDict: List[str] :rtype: bool """ dp=[True] max_len=max(map(len,wordDict+['']))#找到wordDict中长度最长的单词的长度 #加['']的目的是避免出现map为空的情况 words=set(wordDict)#将列表变成集合 这样访问速度变成O(1) for i in range(1,len(s)+1): #加逗号的原因是使其变成一个元祖(可迭代) #这样速度快于dp.append(x)--第二 和dp+=[x]--第三 dp+=any([dp[j] and s[j:i] in words for j in range(max(0,i-max_len),i)]), #不需要遍历i之前的每一个子串 只有[i-max_len,i]范围内的元素才能有可能和words中单词相同 return dp[-1] java solution1234567891011121314151617181920212223242526272829303132333435363738394041//BFS solution class Solution &#123; public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; int max_len=-1; for(String word :wordDict) &#123; max_len=Math.max(max_len,word.length()); &#125; Set&lt;String&gt; words=new HashSet&lt;&gt;(wordDict); Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); queue.add(0); boolean[] visited=new boolean[s.length()+1]; /* Input: s = "leetcode", wordDict = ["leet", "code"] visited FFFTFFFT max_len=4 leet eetc etco tcod code */ while(!queue.isEmpty()) &#123; int start=queue.remove();//弹出列表的第一个元素 FIFO for(int end=start+1;end-start&lt;=max_len&amp;&amp;end&lt;=s.length();end++) &#123; //visited[end]==ture 说明能到达s[end]位置 不需要判断words中是否包含子串 //当能到达end=s.length()说明成功 if(end&lt;s.length()&amp;&amp;visited[end]) continue; if(words.contains(s.substring(start,end))) &#123; if(end==s.length()) return true; queue.add(end); visited[end]=true; &#125; &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 264. Ugly Number II]]></title>
    <url>%2Fblog%2F2018%2F12%2F21%2Fleetcode264%2F</url>
    <content type="text"><![CDATA[264. Ugly Number II python solution1234567891011121314151617181920212223242526272829303132333435class Solution(object): def nthUglyNumber(self, n): """ :type n: int :rtype: int """ """ 思路整理 1)用seq[0:n]存储第1个到第n个ugly number 2)计算第i个ugly number的方法是min(seq[x]*2,seq[y]*3,seq[z]*5) x,y,z是在序列中未出现的分别乘以2，3，5 的最小指针 也就是说如果seq[i]=seq[x]*2 x指针对应的元素已经乘过2 并在队列中存储了 下一个大于它且同样乘以2的元素就是seq[x+1] We have an array seq of first n ugly number. We only know, at the beginning, the first one, which is 1. Then seq[1] = min( seq[0]x2, seq[0]x3, seq[0]x5). The answer is seq[0]x2. So we move 2's pointer to 1. Then we test: seq[2] = min( seq[1]x2, seq[0]x3, seq[0]x5). And so on. Be careful about the cases such as 6, in which we need to forward both pointers of 2 and 3. """ seq=[1 for i in range(n)] p2,p3,p5=0,0,0 for i in range(1,n): num=min(seq[p2]*2,min(seq[p3]*3,seq[p5]*5)) seq[i]=num #注意以下情况不是 if elseif 的关系 而是并列的关系 #seq[p2]=3 seq[p3]=2 #2*3=6 3*2=6 seq[i]=6 所以这两种情况都已经使用过了 #因此均需要向前移动指针p2++ p3++ if num==seq[p2]*2:p2+=1 if num==seq[p3]*3:p3+=1 if num==seq[p5]*5:p5+=1 return seq[n-1] java solution12345678910111213141516class Solution &#123; public int nthUglyNumber(int n) &#123; int[] seq=new int[n]; int p2=0,p3=0,p5=0; seq[0]=1; for(int i=1;i&lt;n;i++) &#123; int num=Math.min(seq[p2]*2,Math.min(seq[p3]*3,seq[p5]*5)); seq[i]=num; if(num==seq[p2]*2)p2++; if(num==seq[p3]*3)p3++; if(num==seq[p5]*5)p5++; &#125; return seq[n-1]; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 79. Word Search]]></title>
    <url>%2Fblog%2F2018%2F12%2F20%2Fleetcode79%2F</url>
    <content type="text"><![CDATA[79. Word Search python solution123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Solution(object): def exist(self, board, word): """ :type board: List[List[str]] :type word: str :rtype: bool """ """ 思路整理: 1)遍历整个board 如果满足board[i][j]==word[0]则调用helper 从i,j出发 探索所有可能的路径 2)利用字典存储满足board[i][j]==word[k]的 i,j位置 每次检测是否在字典中已经出现该位置 由于一条路径中不能有同一个位置，因此利用dict.has_key(key_value)检测是否存在相同位置 3)在每个位置 需满足3个条件才能继续递归 i.有向某一方向前进的余地 ii.向该方向前进的元素与word中下一元素相同 iii.在字典中不存在即将要前进的位置 4)当获得路径与word相同k==len(word)-1 则成功 返回True Explanation 1)traverse the whole board,if board[i][j]==word[0],call the helper 2)because he same letter cell may not be used more than once, so we use a dictionary to avoid it 3)in each position,constrains below must be satisfied to continue the recursion i.we can move to one direction without oversteping the boundary ii.the element we are moving to is the same with next element in word iii.there is no same position in dictionary 4)when we get the same path with word,we can return True """ """ dict.update(dict2)把字典dict2的键/值对更新到dict里 dict.has_key(key)如果键在字典dict里返回true，否则返回false Dict.pop(key)#pop()，()里为需要删除的key值 """ if len(word)&gt;len(board)*len(board[0]):return False def helper(i,j,k,Dict): if k==len(word)-1:return True m=(i-1)*len(board[0])+j if i&gt;0 and not Dict.has_key(m)and board[i-1][j]==word[k+1]:#up n=&#123;m:True&#125; Dict.update(n) if helper(i-1,j,k+1,Dict):return True Dict.pop(m) m=(i+1)*len(board[0])+j if i&lt;len(board)-1 and not Dict.has_key(m)and board[i+1][j]==word[k+1]:#down n=&#123;m:True&#125; Dict.update(n) if helper(i+1,j,k+1,Dict):return True Dict.pop(m) m=i*len(board[0])+j-1 if j&gt;0 and not Dict.has_key(m)and board[i][j-1]==word[k+1]:#left n=&#123;m:True&#125; Dict.update(n) if helper(i,j-1,k+1,Dict):return True Dict.pop(m) m=i*len(board[0])+j+1 if j&lt;len(board[0])-1 and not Dict.has_key(m)and board[i][j+1]==word[k+1]:#right n=&#123;m:True&#125; Dict.update(n) if helper(i,j+1,k+1,Dict):return True Dict.pop(m) return False Dict=&#123;&#125; for i in range(len(board)): for j in range(len(board[0])): if board[i][j]==word[0]: n=&#123;i*len(board[0])+j:True&#125; Dict.update(n) if helper(i,j,0,Dict):return True Dict.pop(i*len(board[0])+j) return False java solution1234567891011121314151617181920212223242526272829class Solution &#123; public boolean exist(char[][] board, String word) &#123; //String为不可变类型 需要将其转换为char数组 //length--数组长度 length()--字符串长度 char[ ] w = word.toCharArray(); for(int i=0;i&lt;board.length;i++) &#123; for(int j=0;j&lt;board[0].length;j++) if(isExist(i,j,0,board,w)) return true; &#125; return false; &#125; private boolean isExist(int i,int j,int k,char[][] board,char[] word) &#123; if (k==word.length)return true; if(i&lt;0||j&lt;0||i==board.length||j==board[0].length)return false; if(board[i][j]!=word[k])return false; //利用异或操作 将当前字符反转 避免出现使用同一个位置字符的情况 //char 8bit board[i][j]^=256; boolean result=isExist(i-1,j,k+1,board,word)|| isExist(i+1,j,k+1,board,word)|| isExist(i,j-1,k+1,board,word)|| isExist(i,j+1,k+1,board,word); //再次异或 恢复原来的值 board[i][j]^=256; return result; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 120. Triangle]]></title>
    <url>%2Fblog%2F2018%2F12%2F19%2Fleetcode120%2F</url>
    <content type="text"><![CDATA[120. Triangle python solution1234567891011121314151617181920212223242526272829class Solution(object): def minimumTotal(self, triangle): """ :type triangle: List[List[int]] :rtype: int """ """ 思路整理 用cur和pre记录当前行和之前一行到达每个位置的最小路径和 pre a b c triangle[i] d e f g cur a+d min(a,b)+e min(b,c)+e c+g 按以上计算方法即可 Explanation we use cur and pre to store the minimun sum to one position in the current row and the previous row """ #O(row^2) time complexity O(row) space complexity minSum=2147483647#MAX_INT cur=[triangle[0][0]] for i in range(1,len(triangle)): pre=[m for m in cur] for j in range(len(triangle[i])): if j!=len(triangle[i])-1 and j!=0: cur[j]=min(pre[j],pre[j-1])+triangle[i][j] elif j==0:cur[j]=pre[0]+triangle[i][0] else:cur.append(pre[j-1]+triangle[i][j]) for num in cur: if minSum&gt;num:minSum=num return minSum java solution12345678910111213141516171819202122/*采用自底而上(bottom up)的动态规划算法如果已知triangle中 某一位置及其左右两个"孩子" a 则经过a到底的路径一定是a+min(b,c) b c根据这种思路 我们从triangle的最后一行开始 每个位置记录从该位置出发到底的最小路径和 则有 triangle[i][j]=min(triangle[i+1][j],triangle[i+1][j+1])+triangle[i][j] 则triangle[0][0] 最终存储的就是最小路径和*/class Solution &#123; public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; for(int i=triangle.size()-2;i&gt;=0;i--) &#123; for(int j=0;j&lt;triangle.get(i).size();j++) &#123; int self=triangle.get(i).get(j); int min=Math.min(triangle.get(i+1).get(j),triangle.get(i+1).get(j+1)); triangle.get(i).set(j,self+min); &#125; &#125; return triangle.get(0).get(0); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 78. Subsets]]></title>
    <url>%2Fblog%2F2018%2F12%2F19%2Fleetcode78%2F</url>
    <content type="text"><![CDATA[78. Subsets python solution123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution(object): def subsets(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ """ Input: nums = [1,2,3,4] 思路整理 1)每次迭代在res中添加长度比当前最长list长度大1的枚举序列 2)cur 存储经过一次迭代后res中增加的list数目 prev 记录上一次迭代res的长度 3)每次迭代在res中的范围是res[len(res)_previous,len(res)_current] 4)添加的方法是遍历nums中元素 如果第k个元素索引k大于res[j]最后一个元素在nums中的索引 则添加该元素 e.g. []----&gt;[1]--------&gt;[1,2] res[0][-1]=1 2,3,4均可添加 [1,3] [1,4] [2]--------&gt;[2,3] res[1][-1]=2 3,4均可添加 [2,4] [3]--------&gt;[3,4] res[2][-1]=3 4可添加 [4] res[2][-1]=4 无元素可添加 cur=4 Explanation each time of iteration,we add one element to all element which has the longest length in res and also they should satisfy following rules: res[j][-1]&lt;k k is the index in nums j belongs to [len(res)_previous,len(res)_current] """ res=[[]] l=len(nums) prev=0 for i in range(l): temp=prev prev=len(res) for j in range(temp,len(res)): for k in range(0,l): if temp==0 or k&gt;nums.index(res[j][-1]): """ res复制已经存在的元素如res 不能用res.append(res[j]) 地址传递--修改res[j]的值 会同时改变res[-1] 而是应该用下面这种方法 创建一个新的list """ res.append([m for m in res[j]]) res[-1].append(nums[k]) return res python3 solution123456789101112131415161718192021222324252627import functools"""reduce把一个函数作用在一个序列[x1, x2, x3...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)"""class Solution: def subsets(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ """ n取自nums 迭代结果存放于subsets subsets初始化为[[]] """ """ 思路 对于一定长度为n的序列[a,b,c...]有m种子集 则长度为n+1的序列 相当于原序列添加了一个元素 因此 在原来的子集基础上有两种情况:1)加上这个元素 2)不加这个元素 因此有2m种子集 综上 长度为n的序列共有2^n种子集 以下算法的时间复杂度为O(2^n) 与递归的回溯算法相同 e.g.Input: nums = [1,2,3] Initially: [[]] Adding the first number to all the existed subsets: [[], [1]]; Adding the second number to all the existed subsets: [[], [1], [2], [1, 2]]; Adding the third number to all the existed subsets: [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]. """ return functools.reduce(lambda subsets,n:subsets+[s+[n] for s in subsets],nums,[[]]) java solution12345678910111213141516171819202122232425//backtracking --DFS的一种 用于组合排列的问题/*回溯算法Input: nums = [1,2,3]Output:[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]前一个元素的最后一个元素弹出 再加入新的元素*///O(2^n)class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;(); List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;(); backTrack(nums,0,list,res); return res; &#125; private void backTrack(int[] nums,int start,List&lt;Integer&gt; list,List&lt;List&lt;Integer&gt;&gt; res) &#123; res.add(new ArrayList&lt;Integer&gt;(list)); for(int i=start;i&lt;nums.length;i++) &#123; list.add(nums[i]); backTrack(nums,i+1,list,res); list.remove(list.size()-1); &#125; &#125;&#125; c++ solution1234567891011121314151617181920212223242526272829303132333435class Solution &#123; /* Using [1, 2, 3] as an example, 1 appears once in every two consecutive subsets, 2 appears twice in every four consecutive subsets, and 3 appears four times in every eight subsets (initially all subsets are empty)： 1两个subset一循环 2四个subset一循环 3八个subset一循环 [], [], [], [], [], [], [], [] [], [1], [], [1], [], [1], [], [1] [], [1], [2], [1, 2], [], [1], [2], [1, 2] [], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3] */ //O(n*2^n)public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; //c++中的size()和length()没有区别 int n=pow(2,nums.size()); vector&lt;vector&lt;int&gt;&gt; sets(n,vector&lt;int&gt;()); for(int i=0;i&lt;nums.size();i++) &#123; for(int j=0;j&lt;n;j++) &#123; //以2^(i+1)为周期 前2^i不添加元素(最低位为0) if(1&amp;(j&gt;&gt;i)) &#123; sets[j].push_back(nums[i]);//向量的最后添加元素 //后2^i添加元素(最低位为1) &#125; &#125; &#125; return sets; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 155. Min Stack]]></title>
    <url>%2Fblog%2F2018%2F12%2F18%2Fleetcode155%2F</url>
    <content type="text"><![CDATA[155. Min Stack python solution123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051"""思路整理:1)用二维数组记录数据 每一组数据分别记录进栈时的数据 和进栈后所有数据的最小值2)getmin 只需取出最后一次进栈后所有数据的最小值self.res[-1][1]即可explanation1)we use a 2D matrix to store datas for each "push" operationwhich include the current data and the minimum data of all data in the stack2)so we can easily get the smallest data by taking self.res[-1][1] as our return data"""class MinStack(object): def __init__(self): """ initialize your data structure here. """ self.res=[] def push(self, x): """ :type x: int :rtype: void """ self.curMin=self.getMin() if x&lt;self.curMin or self.curMin==None:self.curMin=x self.res.append([x,self.curMin]) def pop(self): """ :rtype: void """ self.res.pop() def top(self): """ :rtype: int """ return self.res[-1][0] def getMin(self): """ :rtype: int """ if not self.res:return None return self.res[-1][1]# Your MinStack object will be instantiated and called as such:# obj = MinStack()# obj.push(x)# obj.pop()# param_3 = obj.top()# param_4 = obj.getMin() java solution12345678910111213141516171819202122232425262728293031323334353637383940public class MinStack &#123; int min=Integer.MAX_VALUE; //必须是Integer 不能是 int Stack&lt;Integer&gt; stack; public MinStack()&#123; stack=new Stack&lt;&gt;(); &#125; //当x&lt;=min时 min应变为x 此时将之前的min入栈 //当pop时若弹出的元素为最小值 则将当前的min置为之前入栈的x未入栈时的最小值 public void push(int x) &#123; //这里必须是&lt;= 而不能是&lt; //因为弹出时满足stack.pop()==min 的条件为x&lt;=min if(x&lt;=min)&#123; stack.push(min); min=x; &#125; stack.push(x); &#125; public void pop() &#123; if(stack.pop()==min)min=stack.pop(); &#125; public int top() &#123; return stack.peek(); &#125; public int getMin() &#123; return min; &#125;&#125;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 110. Balanced Binary Tree]]></title>
    <url>%2Fblog%2F2018%2F12%2F18%2Fleetcode110%2F</url>
    <content type="text"><![CDATA[110. Balanced Binary Tree python solution12345678910111213141516171819202122232425262728293031# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isBalanced(self, root): """ :type root: TreeNode :rtype: bool """ """ 思路整理: DFS 计算每个节点的深度 如果左右子树深度之差大于1 则该树不是BBT 返回-1 只要出现一次-1 则最终返回-1 否则返回树的深度 Explanation calculate each node's depth if the absolate difference is bigger than 1,we just return -1,when there are one -1 returned, we can draw the conclusion that this tree is not a BBT """ def helper(node,depth): if not node:return depth leftdepth=helper(node.left,depth+1) rightdepth=helper(node.right,depth+1) if leftdepth==-1 or rightdepth==-1:return -1 if abs(leftdepth-rightdepth)&gt;1:return -1 return max(leftdepth,rightdepth) return True if helper(root,0)!=-1 else False java solution1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; *///用ans作为出现不平衡情况的标志位 只要ans=false则不是BBTclass Solution &#123; public boolean isBalanced(TreeNode root) &#123; helper(root); return ans; &#125; //private--访问权限仅限于类的内部 private boolean ans=true; private int helper(TreeNode root) &#123; if(root==null)return 0; int left=helper(root.left); int right=helper(root.right); if(Math.abs(left-right)&gt;1) ans=false; return Math.max(left,right)+1; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 74. Search a 2D Matrix]]></title>
    <url>%2Fblog%2F2018%2F12%2F18%2Fleetcode74%2F</url>
    <content type="text"><![CDATA[74. Search a 2D Matrix python solution12345678910111213141516171819202122232425262728293031class Solution(object): def searchMatrix(self, matrix, target): """ :type matrix: List[List[int]] :type target: int :rtype: bool """ """ 思路整理 1) 当target对于matrix中某一行来说 大于等于其最小值 小于等于最大值 则在这一行进行二分搜索 2)若能找到对应元素返回真 否则返回假 explanation 1)when row[0]&lt;=target and row[-1]&gt;=target conduct binary search 2) if we can find the target in this row,return true else return false """ if not matrix or not matrix[0]:return False def binarySearch(res): lo,hi=0,len(res) while lo&lt;hi: mi=int((lo+hi)/2) if res[mi]==target:return True elif res[mi]&gt;target:hi=mi else:lo=mi+1 return False for row in matrix: if row[0]&lt;=target and row[-1]&gt;=target: return binarySearch(row) return False python3 solution123456789101112131415161718192021class Solution: def searchMatrix(self, matrix, target): &quot;&quot;&quot; :type matrix: List[List[int]] :type target: int :rtype: bool &quot;&quot;&quot; &quot;&quot;&quot; 将二维数组看成一个 m*n的一维数组进行二分搜索 O(log(m*n))=O(log(m))+O(log(n)) &quot;&quot;&quot; #// 取整除 - 返回商的整数部分（向下取整） if not matrix or not matrix[0]:return False row,col=len(matrix),len(matrix[0]) lo,hi=0,row*col while lo&lt;hi: mi=(lo+hi)//2 if matrix[mi//col][mi%col]==target:return True elif matrix[mi//col][mi%col]&gt;target:hi=mi else:lo=mi+1 return False java solution123456789101112131415161718192021222324252627282930class Solution &#123; /* 分别对行和列进行二叉搜索O(log(m))+O(log(n)) */ public boolean searchMatrix(int[][] matrix, int target) &#123; if(matrix==null||matrix.length==0)return false; if(matrix[0]==null||matrix[0].length==0)return false; int lo=0,hi=matrix.length,mi=(lo+hi)/2; while(lo&lt;hi) &#123; mi=(lo+hi)/2; if(matrix[mi][0]==target)return true; else if(matrix[mi][0]&lt;target)lo=mi+1; else hi=mi; &#125; lo=0; hi=matrix[0].length; //当matrix[mi][0]&lt;target 则在mi这一行进行搜索 //当matrix[mi][0]&gt;target 则在mi-1这一行进行搜索 int temp=matrix[mi][0]&gt;target&amp;&amp;mi&gt;0?mi-1:mi; while(lo&lt;hi) &#123; mi=(lo+hi)/2; if(matrix[temp][mi]==target)return true; else if(matrix[temp][mi]&lt;target)lo=mi+1; else hi=mi; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 539. Minimum Time Difference]]></title>
    <url>%2Fblog%2F2018%2F12%2F17%2Fleetcode539%2F</url>
    <content type="text"><![CDATA[539. Minimum Time Difference python solution123456789101112131415161718192021222324252627282930313233class Solution(object): def findMinDifference(self, timePoints): """ :type timePoints: List[str] :rtype: int """ """ 思路整理: 1)对所有时间点排序 找到排序后所有相邻时间点间最小的时间差 注意还有第一个和最后一个也是相邻的 2)计算两个时间点的最小时间差 i.s1-s2&gt;12h diff=(23-hour2+hour1)*60+60-min2+min1 ii.s1-s2&lt;=12h diff=(hour2-hour1)*60+min2-min1 explanation 1)sort all time points,find the minimun difference between all adjacent time points to be noticed,the first and the last are also adjacent 2)calculate the diffenence between two adjacent time points """ def calDiff(s1,s2): hour1=(ord(s1[0])-ord('0'))*10+ord(s1[1])-ord('0') hour2=(ord(s2[0])-ord('0'))*10+ord(s2[1])-ord('0') min1=(ord(s1[3])-ord('0'))*10+ord(s1[4])-ord('0') min2=(ord(s2[3])-ord('0'))*10+ord(s2[4])-ord('0') if hour2-hour1&gt;12 or (hour2-hour1==12 and min1&lt;min2) : return (23-hour2+hour1)*60+60-min2+min1 else: return (hour2-hour1)*60+min2-min1 timePoints.sort()#升序排列 diff=calDiff(timePoints[0],timePoints[-1]) for i in range(len(timePoints)-1): diff=min(diff,calDiff(timePoints[i],timePoints[i+1])) return diff python3 solution123456789101112131415161718192021222324252627282930313233class Solution: def findMinDifference(self, timePoints): &quot;&quot;&quot; :type timePoints: List[str] :rtype: int &quot;&quot;&quot; def convert(s): return int(s[0:2])*60+int(s[3:]) &quot;&quot;&quot; map()是 Python 内置的高阶函数，它接收一个函数 f 和一个 list， 并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。 &quot;&quot;&quot; minutes=list(map(convert,timePoints)) minutes.sort() &quot;&quot;&quot; zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表 下面zip(minutes,minutes[1:]+minute[0])的含义是 返回[(mintues[0],mintues[1]),(mintues[1],mintues[2]),...(mintues[n-1],mintues[0])] 对应元素依次相减 &quot;&quot;&quot; &quot;&quot;&quot; 对于相邻时间点 都有两个时间差 min1-min2 和24*60-min1+min2 对于升序排列的两个相邻时间点其24*60-min1+min2 一定大于首元素和末元素 24*60-first+last 因此只需计算min1-min2%(24*60)=min1-min2&gt;0 对于首元素和末元素 24*60-first+last first-last&lt;0 如0-1439=-1439 而-1439%(24*60)=1 即为我们想要的结果 &quot;&quot;&quot; &quot;&quot;&quot; -9%7=-9 - 7*[-2]=5 9%-7=-9 - -7*[-2]=-5 &quot;&quot;&quot; return min((y-x)%(24*60) for x,y in zip(minutes,minutes[1:]+minutes[:1])) java solution123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public int findMinDifference(List&lt;String&gt; timePoints) &#123; //因为时间点一共有24*60个 将其转换为24*60个布尔型变量 //若在timePoints中出现 则在对应位置置为true //接下来计算timePoints中相邻时间点的差值的最小值 //同时 将最后的min与时间点的最小值与最大值的差60*24-(last-first)比较 找到二者间的最小值 //不能是last-fast 因为任意相邻的两个时间点都比它小 boolean[] mask=new boolean[24*60]; for(String time:timePoints) &#123; //praseInt() 返回值为int对象 //valueOf()返回值为Integer，可以使用Integer对象里面的所有方法， //包括转为Object对象，而int类型不能转为Object对象 String[] t=time.split(":"); int hour = Integer.parseInt(t[0]); int Min=Integer.parseInt(t[1]); if(mask[hour*60+Min]) return 0; mask[hour*60+Min]=true; &#125; int min=Integer.MAX_VALUE,first=Integer.MAX_VALUE,last=Integer.MIN_VALUE,pre=Integer.MAX_VALUE; for(int i=0;i&lt;60*24;i++) &#123; if(mask[i]) &#123; if(first!=Integer.MAX_VALUE) &#123; min=Math.min(min,i-pre); &#125; first=Math.min(i,first); last=Math.max(i,last); pre=i; &#125; &#125; min=Math.min(min,60*24-(last-first)); return min; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 134. Gas Station]]></title>
    <url>%2Fblog%2F2018%2F12%2F17%2Fleetcode134%2F</url>
    <content type="text"><![CDATA[134. Gas Station python solution123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution(object): def canCompleteCircuit(self, gas, cost): """ :type gas: List[int] :type cost: List[int] :rtype: int """ """ 思路整理: 1)如果sum(gas+cost)&gt;=0 一定有方案可以从某一位置出发回到该位置 证明: i.假设下面部分和为最小 gas[0]-cost[0]+gas[1]-cost[1]+...+gas[i]-cost[i] ii.则开始位置为start=i+1 且满足gas[i+1]-cost[i+1]&gt;=0 (若gas[i+1]-cost[i+1]&lt;0,则0-i不是最小) 以下各不等式均应该满足 --也就是能从i+1到最后 gas[i+1]-cost[i+1]&gt;=0 gas[i+1]-cost[i+1]+gas[i+2]-cost[i+2]&gt;=0 ....... gas[i+1]-cost[i+1]+gas[i+2]-cost[i+2]+...+gas[n-1]-cost[n-1]&gt;=0 (从i+1到之后的任意一个位置均应该大于等于0,若小于0 则则0-i不是最小) 同时有(因为从0-i之和为最小 任何j&lt;i均满足下列不等式) gas[0]-cost[0]+gas[1]-cost[1]+...+gas[j]-cost[j] + gas[i+1]-cost[i+1]+...+gas[n-1]-cost[n-1] &gt;= gas[0]-cost[0]+gas[1]-cost[1]+...+gas[i]-cost[i] + gas[i+1]-cost[i+1]+...+gas[n-1]-cost[n-1]=sum(gas+cost) &gt;=0 由上可知 gas[i+1]-cost[i+1]&gt;=0, gas[i+1]-cost[i+1]+gas[i+2]-cost[i+2]&gt;=0, gas[i+1]-cost[i+1]+gas[i+2]-cost[i+2]+...+gas[n-1]-cost[n-1]&gt;=0, ... gas[i+1]-cost[i+1]+...+gas[n-1]-cost[n-1] + gas[0]-cost[0]+gas[1]-cost[1]+...+gas[j]-cost[j]&gt;=0, ... 从i+1出发可以到达0-i的任意一个位置 得证 """ tank,total,start=0,0,0 for i in range(len(gas)): tank=tank+gas[i]-cost[i] if tank&lt;0: total+=tank tank=0 start=i+1 return -1 if tank+total&lt;0 else start java solution12345678910111213141516171819202122232425class Solution &#123; /* 思路整理:贪心算法 从start开始走尽可能远的位置(sum&gt;=0) 当无法再前进(sum&lt;0)start向后退一位 也就是从新的位置开始出发 当start与end相遇 则可从start出发回到该位置(前提sum&gt;=0) */ public int canCompleteCircuit(int[] gas, int[] cost) &#123; int start=gas.length-1,end=0; int sum=gas[start]-cost[start]; while(start&gt;end) &#123; if(sum&gt;=0) &#123; sum+=gas[end]-cost[end]; end++; &#125; else &#123; start--; sum+=gas[start]-cost[start]; &#125; &#125; return sum&gt;=0?start:-1; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 199. Binary Tree Right Side View]]></title>
    <url>%2Fblog%2F2018%2F12%2F17%2Fleetcode199%2F</url>
    <content type="text"><![CDATA[199. Binary Tree Right Side View python solution12345678910111213141516171819202122232425262728293031323334353637383940# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def rightSideView(self, root): """ :type root: TreeNode :rtype: List[int] """ """ 思路整理 1)对二叉树进行先序遍历(root--left--right) 2)将每一层的最后一个元素加到res队尾 explanation 1)take the preorder trversal for the binary tree 2)add the last element to res in stack Input: 1 stack=[1] res=[1] / \ 2 3 stack=[2,3] res=[1,3] \ \ 5 4 stack=[5,4] res=[1,3,4] """ if not root:return [] stack=[root] res=[root.val] while stack: k=len(stack) for i in range(k): #pop() 函数用于移除列表中的一个元素（默认最后一个元素） node=stack.pop(0)#移除列表中的第一个元素 if node.left:stack.append(node.left) if node.right:stack.append(node.right) if stack: res.append(stack[-1].val) return res java solution12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; *//*1.Each depth of the tree only select one node.2. View depth is current size of result list.*/class Solution &#123; public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; //Vector主要用在事先不知道数组的大小，或者只是需要一个可以改变大小的数组的情况。 //创建一个默认的向量，默认大小为10： ArrayList res = new ArrayList&lt;Integer&gt;(); helper(res,root,0); return res; &#125; //DFS-traverse the tree right-to-left, add values to the res whenever we first reach a new record depth. //当depth第一次增加1 即到达下一层时 添加最右边的元素到res public void helper(ArrayList res,TreeNode node,int depth) &#123; if(node!=null) &#123; // size()是集合的方法,可以返回集合中对象的数量 length()是数组的方法,返回数组的长度 if(res.size()==depth) &#123; res.add(new Integer(node.val)); &#125; helper(res,node.right,depth+1); helper(res,node.left,depth+1); &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 522. Longest Uncommon Subsequence II]]></title>
    <url>%2Fblog%2F2018%2F12%2F17%2Fleetcode522%2F</url>
    <content type="text"><![CDATA[522. Longest Uncommon Subsequence II python solution123456789101112131415161718192021222324252627282930313233class Solution: def findLUSlength(self, strs): """ :type strs: List[str] :rtype: int """ def isSubsequence(s1,s2): """ iter() 函数用来生成迭代器 s会返回s2的下一个值 if t was '1234' and we check whether '3' is in T = iter(t), after we will have next(T) = '4', not '1' """ s=iter(s2) """ all(iterable) returns true if and only if every element of the iterable is truthy. 也就是说只有s1中每个元素都依次和s2的元素匹配 则s1为s2的子串 但是要注意["aaa","aaa","aa"]这种情况 "aa"是"aaa"的子串 "aaa"不是是"aa"的子串 当s1="aa" s2="aaa" all(c in s2 for c in s1) 为真--因此要用这种写法 all(c in s1 for c in s2) 为假--s2取到最后一个a时s1已经没有可迭代的元素了 """ return all(c in s for c in s1) #以字符的长度排序 reverse=True代表长度从大到小--降序 strs.sort(key=len,reverse=True) for s1 in strs: """ 如果s1(当前最长的串)不是其他所有串的子串(只是他自己的子串--sum==1) 则返回其长度即为最长uncommon subsequence """ if sum(isSubsequence(s1,s2) for s2 in strs)==1: return len(s1) return -1 java solution123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public int findLUSlength(String[] strs) &#123; // reverse sorting array with length Arrays.sort(strs,new Comparator&lt;String&gt;() &#123; public int compare(String s1,String s2) &#123; //s2.length()-s1.length()--倒序 s1.length()-s2.length()--正序 //int compare(T o1, T o2) 是比较o1和o2的大小 //如果返回值为负数意味着o1比o2小，否则返回为零意味着o1等于o2，返回为正数意味着o1大于o2 //假如o1的值大于o2，你返回1，此时调用Collections.sort()函数就是升序；假如o1的值大于o2，你返回-1，此时调用Collections.sort()函数就是降序。 return s2.length()-s1.length(); &#125; &#125;); for(int i=0;i&lt;strs.length;i++) &#123; int cnt=strs.length-1; for(int j=0;j&lt;strs.length;j++) &#123; if(i!=j&amp;&amp;isSubsequence(strs,i,j)==false) cnt--; &#125; // strs[i] is not a sub sequence of any other entry if(cnt==0)return strs[i].length(); &#125; return -1; &#125; public boolean isSubsequence(String[] strs,int i,int j) &#123; if(strs[i].length()&gt;strs[j].length())return false; int k=0; for(char ch:strs[j].toCharArray()) if(k&lt;strs[i].length()&amp;&amp;ch==strs[i].charAt(k)) &#123; k++; &#125; return k==strs[i].length(); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 234. Palindrome Linked List]]></title>
    <url>%2Fblog%2F2018%2F12%2F15%2Fleetcode234%2F</url>
    <content type="text"><![CDATA[234. Palindrome Linked List python solution123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def isPalindrome(self, head): """ :type head: ListNode :rtype: bool """ """ Input: 1-&gt;2-&gt;2-&gt;1 (1) Input: 1-&gt;2-&gt;3-&gt;2-&gt;1 (2) 思路整理: 1)首先找到链表的中间节点slow 偶数个节点(1) slow=2-&gt;2-&gt;1 奇数个节点(2) slow=3-&gt;2-&gt;1 2)翻转链表的第二部分 e.g. slow=4-&gt;3-&gt;2-&gt;1 fast=slow.next=3-&gt;2-&gt;1 temp=slow.next temp=3-&gt;2-&gt;1 temp=2-&gt;3-&gt;1 slow.next=fast.next slow=4-&gt;2-&gt;1 slow=4-&gt;1 fast.next=fast.next.next fast=3-&gt;1 fast=3 slow.next.next=temp slow=4-&gt;2-&gt;3-&gt;1 slow=4-&gt;1-&gt;2-&gt;3 3)比较第一部分和第二部分，完全相同则为回文，否则不是 Explanation 1)find the middle find the middle of the linked list when the number of nodes are odd slow=2-&gt;2-&gt;1 when the number of nodes are even slow=3-&gt;2-&gt;1 2)reverse the second part 3)compare the 1st and the 2nd part """ if not head:return True slow,fast=head,head #find the middle of the linked list while fast.next and fast.next.next: slow=slow.next fast=fast.next.next fast=slow.next #reverse the second part while fast and fast.next: temp=slow.next slow.next=fast.next fast.next=fast.next.next slow.next.next=temp #compare the 1st and the 2nd part fast=slow.next slow=head while fast: if slow.val!=fast.val:return False slow=slow.next fast=fast.next return True python3 solution12345678910111213141516171819202122232425262728293031# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def isPalindrome(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: bool &quot;&quot;&quot; &quot;&quot;&quot; Input: 1-&gt;2-&gt;2-&gt;1 Input: 1-&gt;2-&gt;3-&gt;2-&gt;1 思路整理: 1)rev存储链表的前半部分翻转后的结果 rev=2-&gt;1 slow存储 链表的后半部分 slow=2-&gt;1 2)这种算法并没有改变原链表的结构 而是构建以rev为链表头的链表 3)当节点数为偶数fast=None slow=2-&gt;1 当节点数为偶数fast=1 slow=3-&gt;2-&gt;1 因此slow=slow.next=2-&gt;1 &quot;&quot;&quot; rev,fast,slow=None,head,head while fast and fast.next: fast=fast.next.next rev,rev.next,slow=slow,rev,slow.next if fast:slow=slow.next while rev and rev.val==slow.val: rev=rev.next slow=slow.next return not rev java solution123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isPalindrome(ListNode head) &#123; if(head==null)return true; ListNode slow=head,fast=head; while(fast.next!=null&amp;&amp;fast.next.next!=null) &#123; slow=slow.next; fast=fast.next.next; &#125; fast=slow.next; while(fast!=null&amp;&amp;fast.next!=null) &#123; ListNode next=slow.next; slow.next=fast.next; fast.next=fast.next.next; slow.next.next=next; &#125; fast=slow.next; slow=head; while(fast!=null) &#123; if(fast.val!=slow.val) return false; slow=slow.next; fast=fast.next; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 64. Minimum Path Sum]]></title>
    <url>%2Fblog%2F2018%2F12%2F14%2Fleetcode64%2F</url>
    <content type="text"><![CDATA[64. Minimum Path Sum python solution12345678910111213141516171819202122232425262728293031323334353637383940class Solution(object): def minPathSum(self, grid): """ :type grid: List[List[int]] :rtype: int """ """ 思路整理 res用于存储grid中每一行每个位置到达该位置的最小sum值 Input: res [ [1,3,1], [1,4,5] [1,5,1], [2,7,6] [4,2,1] [6,8,7] ] 1)对于第一行或第一列 res的值可由grid[0][i]+res[i-1](右侧值+当前grid值) 或 grid[j][0]+res[0](上方值+当前grid值)求得 2)对于其它情况 res值 为res[i]+grid[j][i](上方值+当前grid值) 和res[i-1]+grid[j][i](右侧值+当前grid值) 二者之间的最小值 Explanation we use res to store the minimum sum of each position in grid 1)for grid[0][i] or grid[j][0],we can simply use grid[0][i]+res[i-1] and grid[j][0]+res[0] to calculate them 2) for other situation,res[i]=min(res[i]+grid[j][i],res[i-1]+grid[j][i]) the sum of one particular position,there are only tow potential previous position (either from its top or its left side),so we just take the small one """ if not grid:return 0 row=len(grid) col=len(grid[0]) res=[0 for i in range(col)] res[0]=grid[0][0] for i in range(1,col):res[i]=grid[0][i]+res[i-1] for j in range(1,row): res[0]=grid[j][0]+res[0] for i in range(1,col): res[i]=res[i]+grid[j][i] if res[i]&lt;res[i-1] else res[i-1]+grid[j][i] return res[col-1] java solution1234567891011121314151617class Solution &#123; public int minPathSum(int[][] grid) &#123; int row=grid.length; int col=grid[0].length; for(int i=0;i&lt;row;i++) &#123; for(int j=0;j&lt;col;j++) &#123; if(i==0&amp;&amp;j==0)continue; else if(i==0&amp;&amp;j&gt;0) grid[0][j]+=grid[0][j-1]; else if(i&gt;0&amp;&amp;j==0) grid[i][0]+=grid[i-1][0]; else grid[i][j]=Math.min(grid[i-1][j]+grid[i][j],grid[i][j]+grid[i][j-1]); &#125; &#125; return grid[row-1][col-1]; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 106. Construct Binary Tree from Inorder and Postorder Traversal]]></title>
    <url>%2Fblog%2F2018%2F12%2F14%2Fleetcode106%2F</url>
    <content type="text"><![CDATA[106. Construct Binary Tree from Inorder and Postorder Traversal python solution123456789101112131415161718192021222324# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def buildTree(self, inorder, postorder): """ :type inorder: List[int] :type postorder: List[int] :rtype: TreeNode """ """ 利用pop()操作 依次从postorder中取出元素因此不需要计算左右子树的范围 注意要先计算右子树再计算左子树 """ if not inorder or not postorder:return None node=TreeNode(postorder.pop()) i=inorder.index(node.val) node.right=self.buildTree(inorder[i+1:], postorder) node.left=self.buildTree(inorder[:i], postorder) return node python3 solution12345678910111213141516171819202122232425262728293031323334353637383940414243444546# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def buildTree(self, inorder, postorder): &quot;&quot;&quot; :type inorder: List[int] :type postorder: List[int] :rtype: TreeNode &quot;&quot;&quot; &quot;&quot;&quot; 思路整理: 1)[lo,hi]代表postorder当前要处理的元素范围 postorder[hi] 为当前函数的根节点 [start,end]代表inorder当前要处理的元素范围 在inorder中找到postorder[hi]对应的秩index 则end-index 为右子树的长度 [hi-(end-index),hi-1]即为postorder中右子树的范围 同理[lo,hi-(end-index)-1]即为postorder中左子树的范围 而[index+1,end]为inorder中右子树的范围 [start,index-1]为inorder中左子树的范围 e.g. lo=0 hi=4 start=0 end=4 inorder = [9,3,15,20,7] index(postorder[hi])=1 end-index=3 postorder = [9,15,7,20,3] node.val=postorder[hi]=3 则postorder中右子树的范围 [hi-(end-index),hi-1]=[1,3]=[3,15,20] postorder中左子树的范围 [lo,hi-(end-index)-1]=[0,0]=[9] 则inorder中右子树的范围 [index+1,end]=[2,4]=[3,15,20] inorder中左子树的范围 [start,index-1]=[0,0]=[9] Explanation 1)[lo,hi]represents the range of elements in postorder postorder[hi] is current root [start,end]represents the range of elements in inorder thus end-index is the length of right child [hi-(end-index),hi-1] is the range of right child in postorder [lo,hi-(end-index)-1] is the range of left child in postorder &quot;&quot;&quot; if not inorder:return None def helper(lo,hi,start,end): if lo&gt;hi or start&gt;end:return None node=TreeNode(postorder[hi]) index=inorder.index(postorder[hi]) node.right=helper(hi-(end-index),hi-1,index+1,end) node.left=helper(lo,hi-(end-index)-1,start,index-1) return node return helper(0,len(inorder)-1,0,len(inorder)-1) java solution1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode buildTree(int[] inorder, int[] postorder) &#123; if(inorder==null||postorder==null)return null; HashMap&lt;Integer,Integer&gt; map=new HashMap&lt;Integer,Integer&gt;(); for(int i=0;i&lt;inorder.length;i++) &#123; map.put(inorder[i],i); &#125; return helper(0,inorder.length-1,0,inorder.length-1,map,inorder,postorder); &#125; private static TreeNode helper(int lo,int hi,int start,int end,HashMap&lt;Integer,Integer&gt; map,int[] inorder, int[] postorder) &#123; if(lo&gt;hi||start&gt;end) return null; TreeNode node=new TreeNode(postorder[hi]); int index=map.get(postorder[hi]); node.right=helper(hi-(end-index),hi-1,index+1,end,map,inorder,postorder); node.left=helper(lo,hi-(end-index)-1,start,index-1,map,inorder,postorder); return node; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 91. Decode Ways]]></title>
    <url>%2Fblog%2F2018%2F12%2F14%2Fleetcode91%2F</url>
    <content type="text"><![CDATA[91. Decode Ways python solution12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution: def numDecodings(self, s): """ :type s: str :rtype: int """ """ 思路整理: 1)用cnt[len(s)]存储截止到s[i](包括s[i])所有可能的编码数 2)对于任意s[i] i.若 '1'&lt;=s[i]&lt;='9' 则s[i]都可以直接单独加到之前的编码队列--cnt[i-1] 同时,若s[i-1]=='1' 或者 s[i-1]=='2' and '1'&lt;=s[i]&lt;='6' 则s[i],s[i-1]二者可以结为1个编码 但前提是s[i-1]未与s[i-2]结合 此时我们用twoDigits记录之前的编码队列的s[i-1]与s[i-2]结合成的两位数 cnt[i-1]-twoDigits即为s[i-1]未与s[i-2]结合的数目--temp 则cnt[i]=cnt[i-1]+temp 同时temp可作为下一次迭代时的twoDigits ii.若 's[i]=='0' s[i]只能和s[i-1]结为1个编码 因此,cnt[i]=temp Explanation 1)we use cnt[len(s)] to store all possible decode ways up to s[i](include s[i]) 2)for every s[i] i.if '1'&lt;=s[i]&lt;='9' s[i] can add the formal decoding list seprately--cnt[i-1] meanwhile,if s[i-1]=='1' or(s[i-1]=='2' and '1'&lt;=s[i]&lt;='6') we can combine s[i] with s[i-1] to one number but we should ensure that s[i-1] and s[i-2] are not combined we use twoDigits to represent the number of combinations between s[i-1] and s[i-2],so cnt[i-1]-twoDigits is the number of which s[i-1] and s[i-2] are not combined so cnt[i]=cnt[i-1]+temp to be noticedw,temp can the next twoDigits ii.if 's[i]=='0' s[i] can one combines with s[i-1] thus cnt[i]=temp """ if not s or s[0]=='0':return 0 l=len(s) last=s[0] twoDigits=0 cnt=[0 for i in range(l)] cnt[0]=1 for i in range(1,l): #连续两个0 或者0之前为一大于2的数 if s[i]=='0' and (last=='0' or ord(last)&gt;ord('2')): return 0 if last=='1':temp=cnt[i-1]-twoDigits elif last=='2' and ord(s[i])&lt;ord('7'):temp=cnt[i-1]-twoDigits else:temp=0 cnt[i]=cnt[i-1]+temp if s[i]!='0' else temp twoDigits=temp last=s[i] return cnt[l-1] java solution123456789101112131415161718192021222324252627282930class Solution &#123; public int numDecodings(String s) &#123; if(s==null)return 0; int l=s.length(); int dp[]=new int[l]; //dp[l]每个元素均初始化为0 dp[0]=s.charAt(0)=='0'?0:1; //对于000123这种情况 由于dp[0:2]均为0 因此dp[3:5]也均为0--dp[i]+=dp[i-1/2]; for(int i=1;i&lt;l;i++) &#123; /* public String substring(int beginIndex, int endIndex) 左闭右开 第一个int为开始的索引，对应String数字中的开始位置，--能取到 第二个是截止的索引位置，对应String中的结束位置--取不到 */ /* Integer.valueOf(s)把字符串s解析成Integer对象类型， 返回的integer 可以调用对象中的方法。 */ int first=Integer.valueOf(s.substring(i,i+1)); //取出当前元素并转换为整型--一位数 int second=Integer.valueOf(s.substring(i-1,i+1)); //取出当前元素及其之前元素并转换为整型--两位数 if(first&gt;=1&amp;&amp;first&lt;=9) dp[i]+=dp[i-1]; //符合要求区间，可直接加到之前编码队列 if(second&gt;=10&amp;&amp;second&lt;=26) dp[i]+=i&gt;1?dp[i-2]:1; &#125; return dp[l-1]; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用hexo搭建个人博客]]></title>
    <url>%2Fblog%2F2018%2F12%2F14%2F%E5%88%A9%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[参考 博客插图由于所有的博客都是使用 markdown 进行编辑的，而 markdown 的插图一般需要外链，下面提供三种插图方法：在 source 文件夹中建立 images 文件夹，把需要插入的图片放到该文件夹中，然后通过相对路径 /images/image_name 进行访问。这种方法是最简单的，但由于 github page 一般空间限制为 1G，所以当图片比较多时这种方法不太合适。把图片上传到第三方图床，网上很多人推荐七牛网，但似乎目前免费空间只有1G了，如果图片较多就需要花钱了。另外，这些第三方图床说不定什么时候倒闭了或者被墙了就麻烦了。直接使用 github 当图床，其实就是创建一个新的 repository，可以命名为 blog_images，然后直接通过网页把需要插入的图片上传到该 repository 中。下面说一下如何获取访问地址，首先进入新建的 repository，点开需要插入的那张图片，复制浏览器中地址栏中的地址，把地址中的 blob 改成 raw 就好了，这一步很重要。虽然每个 repository 也有 1G 容量的限制，但是 reposiroty 的数量是没有限制的，你懂的。个人比较推荐这种方法。正常情况下，markdown 插入图片的语法是1![title](address) 但这种方法不能改变插入图片的大小和位置。因此我们可以通过下面的 html 语句来设置插入图片的格式： 1&lt;img src="address" width=50% height=50% align=center/&gt; 这条语句可以实现图片大小的设置 Hexo中添加本地图片1 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true2 在你的hexo目录下执行这样一句话npm install hexo-asset-image –save，这是下载安装一个可以上传本地图片的插件，来自dalao：dalao的git3 等待一小段时间后，再运行hexo n “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹4 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：1![你想输入的替代文字](xxxx/图片名.jpg) 注意： xxxx是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。5 最后检查一下，hexo g生成页面后，进入public\2017\02\26\index.html文件中查看相关字段，可以发现，html标签内的语句是1&lt;img src="2017/02/26/xxxx/图片名.jpg"&gt; 而不是&lt;img src=”xxxx/图片名.jpg&gt;。这很重要，关乎你的网页是否可以真正加载你想插入的图片。 注意事项1.hexo部署和生成有时仅仅使用下面两句实现hexo部署和生成刷新博客并没有变化12hexo ghexo d 可以采用如下方法，现在本地观察有没有变化，再部署到coding/github123hexo ghexo shexo d 也可以先清楚缓存，再部署123hexo clean hexo ghexo d 博客加密 方法]]></content>
      <categories>
        <category>建立博客</category>
      </categories>
      <tags>
        <tag>-blog</tag>
      </tags>
  </entry>
</search>
