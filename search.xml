<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode Problem 539. Minimum Time Difference]]></title>
    <url>%2Fblog%2F2018%2F12%2F17%2Fleetcode539%2F</url>
    <content type="text"><![CDATA[539. Minimum Time Difference python solution123456789101112131415161718192021222324252627282930313233class Solution(object): def findMinDifference(self, timePoints): """ :type timePoints: List[str] :rtype: int """ """ 思路整理: 1)对所有时间点排序 找到排序后所有相邻时间点间最小的时间差 注意还有第一个和最后一个也是相邻的 2)计算两个时间点的最小时间差 i.s1-s2&gt;12h diff=(23-hour2+hour1)*60+60-min2+min1 ii.s1-s2&lt;=12h diff=(hour2-hour1)*60+min2-min1 explanation 1)sort all time points,find the minimun difference between all adjacent time points to be noticed,the first and the last are also adjacent 2)calculate the diffenence between two adjacent time points """ def calDiff(s1,s2): hour1=(ord(s1[0])-ord('0'))*10+ord(s1[1])-ord('0') hour2=(ord(s2[0])-ord('0'))*10+ord(s2[1])-ord('0') min1=(ord(s1[3])-ord('0'))*10+ord(s1[4])-ord('0') min2=(ord(s2[3])-ord('0'))*10+ord(s2[4])-ord('0') if hour2-hour1&gt;12 or (hour2-hour1==12 and min1&lt;min2) : return (23-hour2+hour1)*60+60-min2+min1 else: return (hour2-hour1)*60+min2-min1 timePoints.sort()#升序排列 diff=calDiff(timePoints[0],timePoints[-1]) for i in range(len(timePoints)-1): diff=min(diff,calDiff(timePoints[i],timePoints[i+1])) return diff python3 solution123456789101112131415161718192021222324252627282930313233class Solution: def findMinDifference(self, timePoints): &quot;&quot;&quot; :type timePoints: List[str] :rtype: int &quot;&quot;&quot; def convert(s): return int(s[0:2])*60+int(s[3:]) &quot;&quot;&quot; map()是 Python 内置的高阶函数，它接收一个函数 f 和一个 list， 并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。 &quot;&quot;&quot; minutes=list(map(convert,timePoints)) minutes.sort() &quot;&quot;&quot; zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表 下面zip(minutes,minutes[1:]+minute[0])的含义是 返回[(mintues[0],mintues[1]),(mintues[1],mintues[2]),...(mintues[n-1],mintues[0])] 对应元素依次相减 &quot;&quot;&quot; &quot;&quot;&quot; 对于相邻时间点 都有两个时间差 min1-min2 和24*60-min1+min2 对于升序排列的两个相邻时间点其24*60-min1+min2 一定大于首元素和末元素 24*60-first+last 因此只需计算min1-min2%(24*60)=min1-min2&gt;0 对于首元素和末元素 24*60-first+last first-last&lt;0 如0-1439=-1439 而-1439%(24*60)=1 即为我们想要的结果 &quot;&quot;&quot; &quot;&quot;&quot; -9%7=-9 - 7*[-2]=5 9%-7=-9 - -7*[-2]=-5 &quot;&quot;&quot; return min((y-x)%(24*60) for x,y in zip(minutes,minutes[1:]+minutes[:1])) java solution123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public int findMinDifference(List&lt;String&gt; timePoints) &#123; //因为时间点一共有24*60个 将其转换为24*60个布尔型变量 //若在timePoints中出现 则在对应位置置为true //接下来计算timePoints中相邻时间点的差值的最小值 //同时 将最后的min与时间点的最小值与最大值的差60*24-(last-first)比较 找到二者间的最小值 //不能是last-fast 因为任意相邻的两个时间点都比它小 boolean[] mask=new boolean[24*60]; for(String time:timePoints) &#123; //praseInt() 返回值为int对象 //valueOf()返回值为Integer，可以使用Integer对象里面的所有方法， //包括转为Object对象，而int类型不能转为Object对象 String[] t=time.split(":"); int hour = Integer.parseInt(t[0]); int Min=Integer.parseInt(t[1]); if(mask[hour*60+Min]) return 0; mask[hour*60+Min]=true; &#125; int min=Integer.MAX_VALUE,first=Integer.MAX_VALUE,last=Integer.MIN_VALUE,pre=Integer.MAX_VALUE; for(int i=0;i&lt;60*24;i++) &#123; if(mask[i]) &#123; if(first!=Integer.MAX_VALUE) &#123; min=Math.min(min,i-pre); &#125; first=Math.min(i,first); last=Math.max(i,last); pre=i; &#125; &#125; min=Math.min(min,60*24-(last-first)); return min; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 134. Gas Station]]></title>
    <url>%2Fblog%2F2018%2F12%2F17%2Fleetcode134%2F</url>
    <content type="text"><![CDATA[134. Gas Station python solution123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution(object): def canCompleteCircuit(self, gas, cost): """ :type gas: List[int] :type cost: List[int] :rtype: int """ """ 思路整理: 1)如果sum(gas+cost)&gt;=0 一定有方案可以从某一位置出发回到该位置 证明: i.假设下面部分和为最小 gas[0]-cost[0]+gas[1]-cost[1]+...+gas[i]-cost[i] ii.则开始位置为start=i+1 且满足gas[i+1]-cost[i+1]&gt;=0 (若gas[i+1]-cost[i+1]&lt;0,则0-i不是最小) 以下各不等式均应该满足 --也就是能从i+1到最后 gas[i+1]-cost[i+1]&gt;=0 gas[i+1]-cost[i+1]+gas[i+2]-cost[i+2]&gt;=0 ....... gas[i+1]-cost[i+1]+gas[i+2]-cost[i+2]+...+gas[n-1]-cost[n-1]&gt;=0 (从i+1到之后的任意一个位置均应该大于等于0,若小于0 则则0-i不是最小) 同时有(因为从0-i之和为最小 任何j&lt;i均满足下列不等式) gas[0]-cost[0]+gas[1]-cost[1]+...+gas[j]-cost[j] + gas[i+1]-cost[i+1]+...+gas[n-1]-cost[n-1] &gt;= gas[0]-cost[0]+gas[1]-cost[1]+...+gas[i]-cost[i] + gas[i+1]-cost[i+1]+...+gas[n-1]-cost[n-1]=sum(gas+cost) &gt;=0 由上可知 gas[i+1]-cost[i+1]&gt;=0, gas[i+1]-cost[i+1]+gas[i+2]-cost[i+2]&gt;=0, gas[i+1]-cost[i+1]+gas[i+2]-cost[i+2]+...+gas[n-1]-cost[n-1]&gt;=0, ... gas[i+1]-cost[i+1]+...+gas[n-1]-cost[n-1] + gas[0]-cost[0]+gas[1]-cost[1]+...+gas[j]-cost[j]&gt;=0, ... 从i+1出发可以到达0-i的任意一个位置 得证 """ tank,total,start=0,0,0 for i in range(len(gas)): tank=tank+gas[i]-cost[i] if tank&lt;0: total+=tank tank=0 start=i+1 return -1 if tank+total&lt;0 else start java solution12345678910111213141516171819202122232425class Solution &#123; /* 思路整理:贪心算法 从start开始走尽可能远的位置(sum&gt;=0) 当无法再前进(sum&lt;0)start向后退一位 也就是从新的位置开始出发 当start与end相遇 则可从start出发回到该位置(前提sum&gt;=0) */ public int canCompleteCircuit(int[] gas, int[] cost) &#123; int start=gas.length-1,end=0; int sum=gas[start]-cost[start]; while(start&gt;end) &#123; if(sum&gt;=0) &#123; sum+=gas[end]-cost[end]; end++; &#125; else &#123; start--; sum+=gas[start]-cost[start]; &#125; &#125; return sum&gt;=0?start:-1; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 199. Binary Tree Right Side View]]></title>
    <url>%2Fblog%2F2018%2F12%2F17%2Fleetcode199%2F</url>
    <content type="text"><![CDATA[199. Binary Tree Right Side View python solution12345678910111213141516171819202122232425262728293031323334353637383940# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def rightSideView(self, root): """ :type root: TreeNode :rtype: List[int] """ """ 思路整理 1)对二叉树进行先序遍历(root--left--right) 2)将每一层的最后一个元素加到res队尾 explanation 1)take the preorder trversal for the binary tree 2)add the last element to res in stack Input: 1 stack=[1] res=[1] / \ 2 3 stack=[2,3] res=[1,3] \ \ 5 4 stack=[5,4] res=[1,3,4] """ if not root:return [] stack=[root] res=[root.val] while stack: k=len(stack) for i in range(k): #pop() 函数用于移除列表中的一个元素（默认最后一个元素） node=stack.pop(0)#移除列表中的第一个元素 if node.left:stack.append(node.left) if node.right:stack.append(node.right) if stack: res.append(stack[-1].val) return res java solution12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; *//*1.Each depth of the tree only select one node.2. View depth is current size of result list.*/class Solution &#123; public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; //Vector主要用在事先不知道数组的大小，或者只是需要一个可以改变大小的数组的情况。 //创建一个默认的向量，默认大小为10： ArrayList res = new ArrayList&lt;Integer&gt;(); helper(res,root,0); return res; &#125; //DFS-traverse the tree right-to-left, add values to the res whenever we first reach a new record depth. //当depth第一次增加1 即到达下一层时 添加最右边的元素到res public void helper(ArrayList res,TreeNode node,int depth) &#123; if(node!=null) &#123; // size()是集合的方法,可以返回集合中对象的数量 length()是数组的方法,返回数组的长度 if(res.size()==depth) &#123; res.add(new Integer(node.val)); &#125; helper(res,node.right,depth+1); helper(res,node.left,depth+1); &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 522. Longest Uncommon Subsequence II]]></title>
    <url>%2Fblog%2F2018%2F12%2F17%2Fleetcode522%2F</url>
    <content type="text"><![CDATA[522. Longest Uncommon Subsequence II python solution123456789101112131415161718192021222324252627282930313233class Solution: def findLUSlength(self, strs): """ :type strs: List[str] :rtype: int """ def isSubsequence(s1,s2): """ iter() 函数用来生成迭代器 s会返回s2的下一个值 if t was '1234' and we check whether '3' is in T = iter(t), after we will have next(T) = '4', not '1' """ s=iter(s2) """ all(iterable) returns true if and only if every element of the iterable is truthy. 也就是说只有s1中每个元素都依次和s2的元素匹配 则s1为s2的子串 但是要注意["aaa","aaa","aa"]这种情况 "aa"是"aaa"的子串 "aaa"不是是"aa"的子串 当s1="aa" s2="aaa" all(c in s2 for c in s1) 为真--因此要用这种写法 all(c in s1 for c in s2) 为假--s2取到最后一个a时s1已经没有可迭代的元素了 """ return all(c in s for c in s1) #以字符的长度排序 reverse=True代表长度从大到小--降序 strs.sort(key=len,reverse=True) for s1 in strs: """ 如果s1(当前最长的串)不是其他所有串的子串(只是他自己的子串--sum==1) 则返回其长度即为最长uncommon subsequence """ if sum(isSubsequence(s1,s2) for s2 in strs)==1: return len(s1) return -1 java solution123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public int findLUSlength(String[] strs) &#123; // reverse sorting array with length Arrays.sort(strs,new Comparator&lt;String&gt;() &#123; public int compare(String s1,String s2) &#123; //s2.length()-s1.length()--倒序 s1.length()-s2.length()--正序 //int compare(T o1, T o2) 是比较o1和o2的大小 //如果返回值为负数意味着o1比o2小，否则返回为零意味着o1等于o2，返回为正数意味着o1大于o2 //假如o1的值大于o2，你返回1，此时调用Collections.sort()函数就是升序；假如o1的值大于o2，你返回-1，此时调用Collections.sort()函数就是降序。 return s2.length()-s1.length(); &#125; &#125;); for(int i=0;i&lt;strs.length;i++) &#123; int cnt=strs.length-1; for(int j=0;j&lt;strs.length;j++) &#123; if(i!=j&amp;&amp;isSubsequence(strs,i,j)==false) cnt--; &#125; // strs[i] is not a sub sequence of any other entry if(cnt==0)return strs[i].length(); &#125; return -1; &#125; public boolean isSubsequence(String[] strs,int i,int j) &#123; if(strs[i].length()&gt;strs[j].length())return false; int k=0; for(char ch:strs[j].toCharArray()) if(k&lt;strs[i].length()&amp;&amp;ch==strs[i].charAt(k)) &#123; k++; &#125; return k==strs[i].length(); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 234. Palindrome Linked List]]></title>
    <url>%2Fblog%2F2018%2F12%2F15%2Fleetcode234%2F</url>
    <content type="text"><![CDATA[234. Palindrome Linked List python solution123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def isPalindrome(self, head): """ :type head: ListNode :rtype: bool """ """ Input: 1-&gt;2-&gt;2-&gt;1 (1) Input: 1-&gt;2-&gt;3-&gt;2-&gt;1 (2) 思路整理: 1)首先找到链表的中间节点slow 偶数个节点(1) slow=2-&gt;2-&gt;1 奇数个节点(2) slow=3-&gt;2-&gt;1 2)翻转链表的第二部分 e.g. slow=4-&gt;3-&gt;2-&gt;1 fast=slow.next=3-&gt;2-&gt;1 temp=slow.next temp=3-&gt;2-&gt;1 temp=2-&gt;3-&gt;1 slow.next=fast.next slow=4-&gt;2-&gt;1 slow=4-&gt;1 fast.next=fast.next.next fast=3-&gt;1 fast=3 slow.next.next=temp slow=4-&gt;2-&gt;3-&gt;1 slow=4-&gt;1-&gt;2-&gt;3 3)比较第一部分和第二部分，完全相同则为回文，否则不是 Explanation 1)find the middle find the middle of the linked list when the number of nodes are odd slow=2-&gt;2-&gt;1 when the number of nodes are even slow=3-&gt;2-&gt;1 2)reverse the second part 3)compare the 1st and the 2nd part """ if not head:return True slow,fast=head,head #find the middle of the linked list while fast.next and fast.next.next: slow=slow.next fast=fast.next.next fast=slow.next #reverse the second part while fast and fast.next: temp=slow.next slow.next=fast.next fast.next=fast.next.next slow.next.next=temp #compare the 1st and the 2nd part fast=slow.next slow=head while fast: if slow.val!=fast.val:return False slow=slow.next fast=fast.next return True python3 solution12345678910111213141516171819202122232425262728293031# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def isPalindrome(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: bool &quot;&quot;&quot; &quot;&quot;&quot; Input: 1-&gt;2-&gt;2-&gt;1 Input: 1-&gt;2-&gt;3-&gt;2-&gt;1 思路整理: 1)rev存储链表的前半部分翻转后的结果 rev=2-&gt;1 slow存储 链表的后半部分 slow=2-&gt;1 2)这种算法并没有改变原链表的结构 而是构建以rev为链表头的链表 3)当节点数为偶数fast=None slow=2-&gt;1 当节点数为偶数fast=1 slow=3-&gt;2-&gt;1 因此slow=slow.next=2-&gt;1 &quot;&quot;&quot; rev,fast,slow=None,head,head while fast and fast.next: fast=fast.next.next rev,rev.next,slow=slow,rev,slow.next if fast:slow=slow.next while rev and rev.val==slow.val: rev=rev.next slow=slow.next return not rev java solution123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isPalindrome(ListNode head) &#123; if(head==null)return true; ListNode slow=head,fast=head; while(fast.next!=null&amp;&amp;fast.next.next!=null) &#123; slow=slow.next; fast=fast.next.next; &#125; fast=slow.next; while(fast!=null&amp;&amp;fast.next!=null) &#123; ListNode next=slow.next; slow.next=fast.next; fast.next=fast.next.next; slow.next.next=next; &#125; fast=slow.next; slow=head; while(fast!=null) &#123; if(fast.val!=slow.val) return false; slow=slow.next; fast=fast.next; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 64. Minimum Path Sum]]></title>
    <url>%2Fblog%2F2018%2F12%2F14%2Fleetcode64%2F</url>
    <content type="text"><![CDATA[64. Minimum Path Sum python solution12345678910111213141516171819202122232425262728293031323334353637383940class Solution(object): def minPathSum(self, grid): """ :type grid: List[List[int]] :rtype: int """ """ 思路整理 res用于存储grid中每一行每个位置到达该位置的最小sum值 Input: res [ [1,3,1], [1,4,5] [1,5,1], [2,7,6] [4,2,1] [6,8,7] ] 1)对于第一行或第一列 res的值可由grid[0][i]+res[i-1](右侧值+当前grid值) 或 grid[j][0]+res[0](上方值+当前grid值)求得 2)对于其它情况 res值 为res[i]+grid[j][i](上方值+当前grid值) 和res[i-1]+grid[j][i](右侧值+当前grid值) 二者之间的最小值 Explanation we use res to store the minimum sum of each position in grid 1)for grid[0][i] or grid[j][0],we can simply use grid[0][i]+res[i-1] and grid[j][0]+res[0] to calculate them 2) for other situation,res[i]=min(res[i]+grid[j][i],res[i-1]+grid[j][i]) the sum of one particular position,there are only tow potential previous position (either from its top or its left side),so we just take the small one """ if not grid:return 0 row=len(grid) col=len(grid[0]) res=[0 for i in range(col)] res[0]=grid[0][0] for i in range(1,col):res[i]=grid[0][i]+res[i-1] for j in range(1,row): res[0]=grid[j][0]+res[0] for i in range(1,col): res[i]=res[i]+grid[j][i] if res[i]&lt;res[i-1] else res[i-1]+grid[j][i] return res[col-1] java solution1234567891011121314151617class Solution &#123; public int minPathSum(int[][] grid) &#123; int row=grid.length; int col=grid[0].length; for(int i=0;i&lt;row;i++) &#123; for(int j=0;j&lt;col;j++) &#123; if(i==0&amp;&amp;j==0)continue; else if(i==0&amp;&amp;j&gt;0) grid[0][j]+=grid[0][j-1]; else if(i&gt;0&amp;&amp;j==0) grid[i][0]+=grid[i-1][0]; else grid[i][j]=Math.min(grid[i-1][j]+grid[i][j],grid[i][j]+grid[i][j-1]); &#125; &#125; return grid[row-1][col-1]; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 106. Construct Binary Tree from Inorder and Postorder Traversal]]></title>
    <url>%2Fblog%2F2018%2F12%2F14%2Fleetcode106%2F</url>
    <content type="text"><![CDATA[106. Construct Binary Tree from Inorder and Postorder Traversal python solution123456789101112131415161718192021222324# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def buildTree(self, inorder, postorder): """ :type inorder: List[int] :type postorder: List[int] :rtype: TreeNode """ """ 利用pop()操作 依次从postorder中取出元素因此不需要计算左右子树的范围 注意要先计算右子树再计算左子树 """ if not inorder or not postorder:return None node=TreeNode(postorder.pop()) i=inorder.index(node.val) node.right=self.buildTree(inorder[i+1:], postorder) node.left=self.buildTree(inorder[:i], postorder) return node python3 solution12345678910111213141516171819202122232425262728293031323334353637383940414243444546# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def buildTree(self, inorder, postorder): &quot;&quot;&quot; :type inorder: List[int] :type postorder: List[int] :rtype: TreeNode &quot;&quot;&quot; &quot;&quot;&quot; 思路整理: 1)[lo,hi]代表postorder当前要处理的元素范围 postorder[hi] 为当前函数的根节点 [start,end]代表inorder当前要处理的元素范围 在inorder中找到postorder[hi]对应的秩index 则end-index 为右子树的长度 [hi-(end-index),hi-1]即为postorder中右子树的范围 同理[lo,hi-(end-index)-1]即为postorder中左子树的范围 而[index+1,end]为inorder中右子树的范围 [start,index-1]为inorder中左子树的范围 e.g. lo=0 hi=4 start=0 end=4 inorder = [9,3,15,20,7] index(postorder[hi])=1 end-index=3 postorder = [9,15,7,20,3] node.val=postorder[hi]=3 则postorder中右子树的范围 [hi-(end-index),hi-1]=[1,3]=[3,15,20] postorder中左子树的范围 [lo,hi-(end-index)-1]=[0,0]=[9] 则inorder中右子树的范围 [index+1,end]=[2,4]=[3,15,20] inorder中左子树的范围 [start,index-1]=[0,0]=[9] Explanation 1)[lo,hi]represents the range of elements in postorder postorder[hi] is current root [start,end]represents the range of elements in inorder thus end-index is the length of right child [hi-(end-index),hi-1] is the range of right child in postorder [lo,hi-(end-index)-1] is the range of left child in postorder &quot;&quot;&quot; if not inorder:return None def helper(lo,hi,start,end): if lo&gt;hi or start&gt;end:return None node=TreeNode(postorder[hi]) index=inorder.index(postorder[hi]) node.right=helper(hi-(end-index),hi-1,index+1,end) node.left=helper(lo,hi-(end-index)-1,start,index-1) return node return helper(0,len(inorder)-1,0,len(inorder)-1) java solution1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode buildTree(int[] inorder, int[] postorder) &#123; if(inorder==null||postorder==null)return null; HashMap&lt;Integer,Integer&gt; map=new HashMap&lt;Integer,Integer&gt;(); for(int i=0;i&lt;inorder.length;i++) &#123; map.put(inorder[i],i); &#125; return helper(0,inorder.length-1,0,inorder.length-1,map,inorder,postorder); &#125; private static TreeNode helper(int lo,int hi,int start,int end,HashMap&lt;Integer,Integer&gt; map,int[] inorder, int[] postorder) &#123; if(lo&gt;hi||start&gt;end) return null; TreeNode node=new TreeNode(postorder[hi]); int index=map.get(postorder[hi]); node.right=helper(hi-(end-index),hi-1,index+1,end,map,inorder,postorder); node.left=helper(lo,hi-(end-index)-1,start,index-1,map,inorder,postorder); return node; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 91. Decode Ways]]></title>
    <url>%2Fblog%2F2018%2F12%2F14%2Fleetcode91%2F</url>
    <content type="text"><![CDATA[91. Decode Ways python solution12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution: def numDecodings(self, s): """ :type s: str :rtype: int """ """ 思路整理: 1)用cnt[len(s)]存储截止到s[i](包括s[i])所有可能的编码数 2)对于任意s[i] i.若 '1'&lt;=s[i]&lt;='9' 则s[i]都可以直接单独加到之前的编码队列--cnt[i-1] 同时,若s[i-1]=='1' 或者 s[i-1]=='2' and '1'&lt;=s[i]&lt;='6' 则s[i],s[i-1]二者可以结为1个编码 但前提是s[i-1]未与s[i-2]结合 此时我们用twoDigits记录之前的编码队列的s[i-1]与s[i-2]结合成的两位数 cnt[i-1]-twoDigits即为s[i-1]未与s[i-2]结合的数目--temp 则cnt[i]=cnt[i-1]+temp 同时temp可作为下一次迭代时的twoDigits ii.若 's[i]=='0' s[i]只能和s[i-1]结为1个编码 因此,cnt[i]=temp Explanation 1)we use cnt[len(s)] to store all possible decode ways up to s[i](include s[i]) 2)for every s[i] i.if '1'&lt;=s[i]&lt;='9' s[i] can add the formal decoding list seprately--cnt[i-1] meanwhile,if s[i-1]=='1' or(s[i-1]=='2' and '1'&lt;=s[i]&lt;='6') we can combine s[i] with s[i-1] to one number but we should ensure that s[i-1] and s[i-2] are not combined we use twoDigits to represent the number of combinations between s[i-1] and s[i-2],so cnt[i-1]-twoDigits is the number of which s[i-1] and s[i-2] are not combined so cnt[i]=cnt[i-1]+temp to be noticedw,temp can the next twoDigits ii.if 's[i]=='0' s[i] can one combines with s[i-1] thus cnt[i]=temp """ if not s or s[0]=='0':return 0 l=len(s) last=s[0] twoDigits=0 cnt=[0 for i in range(l)] cnt[0]=1 for i in range(1,l): #连续两个0 或者0之前为一大于2的数 if s[i]=='0' and (last=='0' or ord(last)&gt;ord('2')): return 0 if last=='1':temp=cnt[i-1]-twoDigits elif last=='2' and ord(s[i])&lt;ord('7'):temp=cnt[i-1]-twoDigits else:temp=0 cnt[i]=cnt[i-1]+temp if s[i]!='0' else temp twoDigits=temp last=s[i] return cnt[l-1] java solution123456789101112131415161718192021222324252627282930class Solution &#123; public int numDecodings(String s) &#123; if(s==null)return 0; int l=s.length(); int dp[]=new int[l]; //dp[l]每个元素均初始化为0 dp[0]=s.charAt(0)=='0'?0:1; //对于000123这种情况 由于dp[0:2]均为0 因此dp[3:5]也均为0--dp[i]+=dp[i-1/2]; for(int i=1;i&lt;l;i++) &#123; /* public String substring(int beginIndex, int endIndex) 左闭右开 第一个int为开始的索引，对应String数字中的开始位置，--能取到 第二个是截止的索引位置，对应String中的结束位置--取不到 */ /* Integer.valueOf(s)把字符串s解析成Integer对象类型， 返回的integer 可以调用对象中的方法。 */ int first=Integer.valueOf(s.substring(i,i+1)); //取出当前元素并转换为整型--一位数 int second=Integer.valueOf(s.substring(i-1,i+1)); //取出当前元素及其之前元素并转换为整型--两位数 if(first&gt;=1&amp;&amp;first&lt;=9) dp[i]+=dp[i-1]; //符合要求区间，可直接加到之前编码队列 if(second&gt;=10&amp;&amp;second&lt;=26) dp[i]+=i&gt;1?dp[i-2]:1; &#125; return dp[l-1]; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用hexo搭建个人博客]]></title>
    <url>%2Fblog%2F2018%2F12%2F14%2F%E5%88%A9%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[参考 博客插图由于所有的博客都是使用 markdown 进行编辑的，而 markdown 的插图一般需要外链，下面提供三种插图方法：在 source 文件夹中建立 images 文件夹，把需要插入的图片放到该文件夹中，然后通过相对路径 /images/image_name 进行访问。这种方法是最简单的，但由于 github page 一般空间限制为 1G，所以当图片比较多时这种方法不太合适。把图片上传到第三方图床，网上很多人推荐七牛网，但似乎目前免费空间只有1G了，如果图片较多就需要花钱了。另外，这些第三方图床说不定什么时候倒闭了或者被墙了就麻烦了。直接使用 github 当图床，其实就是创建一个新的 repository，可以命名为 blog_images，然后直接通过网页把需要插入的图片上传到该 repository 中。下面说一下如何获取访问地址，首先进入新建的 repository，点开需要插入的那张图片，复制浏览器中地址栏中的地址，把地址中的 blob 改成 raw 就好了，这一步很重要。虽然每个 repository 也有 1G 容量的限制，但是 reposiroty 的数量是没有限制的，你懂的。个人比较推荐这种方法。正常情况下，markdown 插入图片的语法是1![title](address) 但这种方法不能改变插入图片的大小和位置。因此我们可以通过下面的 html 语句来设置插入图片的格式： 1&lt;img src="address" width=50% height=50% align=center/&gt; 这条语句可以实现图片大小的设置 注意事项1.hexo部署和生成有时仅仅使用下面两句实现hexo部署和生成刷新博客并没有变化12hexo ghexo d 可以采用如下方法，现在本地观察有没有变化，再部署到coding/github123hexo ghexo shexo d 也可以先清楚缓存，再部署123hexo clean hexo ghexo d]]></content>
      <categories>
        <category>建立博客</category>
      </categories>
      <tags>
        <tag>-blog</tag>
      </tags>
  </entry>
</search>
