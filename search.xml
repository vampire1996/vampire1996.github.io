<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2019,除了饭量,还收获了什么?]]></title>
    <url>%2Fvampire1996.github.io%2F2020%2F01%2F14%2Fsummary2019%2F</url>
    <content type="text"><![CDATA[2019年经历了从本科生到研究生的转换，也经历了体重的飙升和恢复，反弹，再恢复的曲折过程。感情方面心动过，憧憬过，冲动过，沮丧过，芳心暗许过，彻夜未眠过。探索爱情真是一场漫长的旅程啊。 一月份进行了本科毕业设计的开题答辩。从和交大这边老师联系的不顺利各种心烦意乱到放弃到交大做毕设，2019年的开始仿佛不是那么顺利。好在在张老师和自动化研究所的李老师帮助下，课题顺利开始，开题答辩也水水过去。接下来就是本科生涯最完整的一个寒假，躺尸几天之后迎来了高中同学的第一次班聚。见到好多许久不见的同学感触良多，几个好朋友聚在一起玩了几天，深夜畅聊大学生活和感情经历，不得不感叹时间真的能改变好多。 二月份依然是假期，一家三口和姥姥一起去了西安旅行。其实西安和太原有很多相似之处，比如悠久的历史，干燥的天气和讨厌的雾霾。然而作为国家中心城市，确实感受到了西安在文化建设方面的出众，饮食方面口味也更重一些。回家后的假期老妈开始了喂养模式，三天一烧烤两天一火锅，门口新开超市之后的生活被促销零食和水果占据了hh。值得一提的是假期期间还学了学安卓开发，每天照着书敲代码感觉自己还算有点自律(不是)。 三月份回到了学校。二月份的放纵带来了代价，体重飙升加皮肤变差，下定决心减重护肤，正如翟同学对班聚照片的评价，”男生都有点中年发福”。不行，绝对不行!当然，这一切也是为了一个人。她。。。算了，不想提。Anyway，每天三公里的生活开始了。尽管迎着寒风，涕泪横流，但是想着变瘦变美之后的幸福，瞬间就有动力了呢!三月份也开始了毕业设计的主体工作，从呆了三年多的宋健2号楼600搬到了主楼328，那些关于600的回忆应该抽时间写一篇博客(待完成)。同时也开始了短暂的戒外卖的一段时期，那段时间真的有点自律的不像话嘻嘻。为了给生活加点色彩，特地在学校表白墙上征集联系口语的兄dei。于是我和一个学弟一个学妹组成了三人尬聊口语小组。 四月份收到了交大要求提前体检的通知。怀着激动的心情去体检，体重令人欣喜的减掉了8斤，我寻思还行叭。这段时间接触了阿里天池上关于OCR的一个比赛。为了搞到GPU想尽各种办法,终于成功薅羊毛成功得到了300刀的服务器使用额度，最后也终于跑出了结果，虽然理论上也是一知半解，但是总算有点收获吧。 五月份开始了CS229的重温之旅。博客中有完整的笔记，同时收到了本科的毕业证书和一个小礼物。Em，那会儿还挺开心的。 时光飞逝，岁月如梭，本科的最后一个月如约而至。送了三次学长之后终于作为学长被送走了，感谢实验室师兄师姐的帮助，飞哥哥，钦学长，凯哥，李泽学姐，豪哥 and so on。本科的美好回忆大多关于你们，各自奔前程之后的人生祝一切都好。 六月份的形成排的满满当当。首先是班级毕业照的拍摄，不得不说本科这样dress up的日子真是少之又少，拍心形的时候还特意抢到了C位，总之拍摄过程晒死人但是拍出来效果还是很满意滴。 接下来是毕业设计答辩的阶段。前段时间划水导致写论文压力很大，同时thanks to 翟天临博士今年查重的力度也格外的大。每天挣扎于改格式和降重，不过总算是顺利过关，完成了最后的使命。 Then，学院和全校的毕业晚会，emmm还不错，不放图了hh。终于，万众瞩目的毕业典礼的日子到了，早上六点钟匆匆起床，接受拨穗的洗礼。最后一次唱校歌”让我们的青春，永远闪光!” 最后，是说再见的时候了。很难用语言描述自己当时的心情。说实话，四年的本科生活我对自己的人际关系是很不满意的。具体一点来说就是宿舍关系不融洽，舍友的粗鲁，沉迷游戏，打游戏时脏话满天飞，午睡都要打呼噜的无奈，这一切都导致我很难对他们说声再见。他们走那天我没在宿舍，据说给我留下一盒笔芯意味着”比心”，也流了很多泪，一群人在校门口痛哭流涕。这一切有点令人唏嘘，我是多么渴望在毕业的时候能有人一起分享我的感受啊。也许是不舍，也许是感伤，也许是孤独，也许是无奈.吃完了最后的晚餐，和我的本科母校说了再见。我已经忘了自己有没有流泪，只记得天气很热，学校很空，出了校门，不回头地走远。 回家后的日子有点枯燥，靠回忆杀找找青春的味道。当我看到幼儿园毕业照片的时候不得不感叹自己当初还是有swag的，现在拍照连表情都没有(sad)而且那会儿的学士服也比本科毕业的好看(sad++)。还有初中毕业照片和高中舍友漫画版，青葱时光，总是那么美好。同时堂弟高考报志愿的任务也落到了我的头上。倒霉的粉渣瘤又一次长到了我的腿上，在忍受麻药失效的手术之后，在家躺尸了一段时间。 7月22号，最终还是和她说了再见。 高考志愿结果出来，表弟被调剂到了广播电视学。 这些事情在我的生活中掀起了轩然大波。精神上的折磨让我在7月的早晨，失去了睡眠。 8月份。老爸的50岁生日到了，感谢他多年来为家庭的付出。虽然有点抠门，但是老爸在面对生活的挑战的时候从来没有退缩过。姥爷得病的时候，作为最不被喜欢的女婿，老爸担起了责任，任劳任怨，成为姥爷口中的”宝”。对于家庭，老爸做出了一个出色表率。 没过几天，和那群男人的聚会终于来了。和好基友们在一起的时光总是欢乐而短暂的。最大的感触就是他们的男友力真的比我强，自己还要多多努力啊! 假期的生活总是短暂的，值得一提的是lmh同学的出现，确实改变了我，她的开朗大方深深感染了我，让我鼓起勇气，开始了浴室歌王的生活。歌慌的时候听听自己唱的歌，感觉也害行哈哈。 9月份，交大迎来了他的新王者，没错，就是我!!! However,真相是还没有联系好导师的我慌得一笔。多谢c老师收留我，总算是尘埃落定。导师的确定方式也很神奇，挂名在系里另外一个导师名下。名义上是两个指导老师，然而真正指导我的是年轻老师。。。boy，肿么这么复杂。。 和导师相处几次发现他人真的很不错，没什么架子，科研方面也亲力亲为，是不是给我发文章，和我一起讨论等等。在交大自动化系躲过坑老师也算是幸运哈哈。 9月份的生活真的很忙碌。选课如期而至，和本科不同的是交大可以选外系的课。那我就不客气啦!两门计算机系的课算是给自己体验一把全国顶尖计科教学的机会。两门全英文课程也算是对自己的一个小小挑战。各类聚会也在所难免。老乡会，班聚，实验室聚会各种social。不得不感叹交大真是卧虎藏龙。仅仅我们实验室就有交大第一，哈工大第一，考研430+的第一。挑战与机遇并存啊！ 十月份迎来了伟大祖国70岁的生日。国家命运很我们个人命运是牢牢绑定在一起的，我和我的祖国，一刻也不能分割! 十一小长假和hf同学约了第一次走出闵行，探索上海。一起逛了田子坊，复旦大学和五角场。瞎逛也是体力活啊! 11月的开始体验了一次蹦床。作为保温杯少年，这种刺激的活动确实有点。。。刺激。回来以后连换水的力气都没有了hh。 11月也意味着学业压力的增加。每天仅仅是做作业已经花费大量的时间，剩下不多的时光还要风险给科研。每天的生活中最大的娱乐方式恐怕就是吃饭了。写到这儿有点饿，不想写想去吃东西了hh。值得一提的是第一次参加了班日视频的拍摄。视频传到B站以后看到飘过的弹幕瞬间意识到这种表达风格的对应人选。为森么都要吐槽我hh。 12月正式迎来了考试月，technically，大部分考试还是在1月，但是1月应该写到20年总结里，so暂时先不写考试，写写研一上的体验吧。最大的感受首先是生活节奏快，面对多任务我的大脑却没有多线程处理，只能串行一件件处理，亚历山大，以图书馆为家。其次是交大老师的优秀，印象最为深刻的是计算机系的两位老师，最为领域大牛姿势水平确实高人一等，当人自动化系也有很多不错的老师。 当然，交大在认为关怀方面也做的不错，中秋的月饼，元旦的餐券都很棒! 12月比较悲惨的是出了一场小车祸导致右手可用性大大降低。每天忍着疼痛作报告，记笔记也蛮佩服自己的。 由于学业的压力，前一段时间的食堂探索带来的体重增加被消灭了。 转眼又到了跨年的时候。回望2019感慨良多。感谢帮助过自己的每一个人，感谢相遇，也感谢迷茫又努力的自己！ 2019，世界依然很大，愿意一起去看看吗!]]></content>
      <categories>
        <category>Annual summary</category>
      </categories>
      <tags>
        <tag>-Annual summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[visual studio code使用记录]]></title>
    <url>%2Fvampire1996.github.io%2F2019%2F08%2F28%2Fvscode%2F</url>
    <content type="text"><![CDATA[在vs code中使用C++在vs code中使用Mingw-w64来进行编译 官方文档 下载Mingw-w64报错Cannot download repostory.txt，则使用离线下载 参考 接下来建立工作空间，根据官方文档配置tasks.json和launch.json文件，就可以编译cpp源文件了 使用 VS Code 搭建适用于 ACM 练习的 C/C++ 开发环境]]></content>
      <categories>
        <category>vs code</category>
      </categories>
      <tags>
        <tag>-visual studio code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS229学习笔记13:线性二次型;调节微分动态规划;线性二次高斯分布]]></title>
    <url>%2Fvampire1996.github.io%2F2019%2F05%2F29%2Fcs22913%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
      <tags>
        <tag>-machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS229学习笔记12:强化学习与控制]]></title>
    <url>%2Fvampire1996.github.io%2F2019%2F05%2F25%2Fcs22912%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
      <tags>
        <tag>-machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS229学习笔记11:独立成分分析]]></title>
    <url>%2Fvampire1996.github.io%2F2019%2F05%2F24%2Fcs22911%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
      <tags>
        <tag>-machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS229学习笔记10:主成分分析]]></title>
    <url>%2Fvampire1996.github.io%2F2019%2F05%2F23%2Fcs22910%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
      <tags>
        <tag>-machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS229学习笔记9:因子分析]]></title>
    <url>%2Fvampire1996.github.io%2F2019%2F05%2F22%2Fcs2299%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
      <tags>
        <tag>-machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS229学习笔记8:K均值聚类算法和期望最大化算法]]></title>
    <url>%2Fvampire1996.github.io%2F2019%2F05%2F22%2Fcs2298%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
      <tags>
        <tag>-machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS229学习笔记7:正则化与模型选择]]></title>
    <url>%2Fvampire1996.github.io%2F2019%2F05%2F21%2Fcs2297%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
      <tags>
        <tag>-machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS229学习笔记6:学习理论]]></title>
    <url>%2Fvampire1996.github.io%2F2019%2F05%2F17%2Fcs2296%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
      <tags>
        <tag>-machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS229学习笔记5:支持向量机]]></title>
    <url>%2Fvampire1996.github.io%2F2019%2F05%2F17%2Fcs2295%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
      <tags>
        <tag>-machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS229学习笔记4:生成学习方法]]></title>
    <url>%2Fvampire1996.github.io%2F2019%2F05%2F15%2Fcs2294%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
      <tags>
        <tag>-machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS229学习笔记3:广义线性模型]]></title>
    <url>%2Fvampire1996.github.io%2F2019%2F05%2F14%2Fcs2293%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
      <tags>
        <tag>-machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS229学习笔记2:分类与逻辑回归]]></title>
    <url>%2Fvampire1996.github.io%2F2019%2F05%2F14%2Fcs2292%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
      <tags>
        <tag>-machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS229学习笔记1:线性回归]]></title>
    <url>%2Fvampire1996.github.io%2F2019%2F05%2F12%2Fcs2291%2F</url>
    <content type="text"><![CDATA[Definition of machine learningTom Mitchell(1998):A computer program is used to learn from experience E with respect to some task T and some performance on P,as measured by P,improves with experience E.监督学习(1)回归问题(regression)被预测的变量是连续的(2)分类问题(classification)被预测的变量是离散的非监督学习:给一组数据，每个数据并没有标签，而是自己寻找其中的结构。 线性回归m:训练数据的大小x:输入变量(输入特征)y:输出变量(目标变量)$(x^{(i)},y^{(i)})$:训练集中的第i组训练数据$x^{(i)}_1$:第i个输入变量的第一个特征(如房屋面积)]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
      <tags>
        <tag>-machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EAST:一种用于高效准确的场景文本检测器]]></title>
    <url>%2Fvampire1996.github.io%2F2019%2F05%2F06%2Fpaperlearning2%2F</url>
    <content type="text"><![CDATA[原文链接 摘要之前的场景文本检测方法已经在不同基准下，实现了可观的性能。然而当遇到更有挑战的场景时，它们通常会有缺陷，甚至是配备深度神经网络的时候，因为总体性能取决于多个阶段和流水线中各个元素的相互作用。在本论文中，我们提出了一种简单但有效的流水线，在检测自然文本时，它能实现快速和准确的效果。流水线直接预测了任意朝向和整个图像中四边形的单词和文本线，消除了不必要的中间步骤(比如候选聚合和分词)，仅使用一个简单的神经网络。我们流水线的简单使得可以集中于设计损失函数和神经网络结构。在标准数据集上的实验包括ICDAR2015,COCO-Text和MSRA-TD500，就准确性和效率而言，提出的算法显著的实现了接近于艺术状态的性能。在ICDAR 2015数据集上，提出的是算法实现了0.7820的F分数720p分辨率下和13。2fps前提下。 1.介绍(introduction)文本检测，作为后续过程的先决条件，在整个文本信息提取和理解的过程中扮演着重要的作用。之前的场景文本检测方法已经在不同基准下，实现了可观的性能。文本检测的核心是设计特征使得文本能从背景中区分出来。传统方法是人工设计特征来捕捉场景文本的属性，同时基于深度学习的方法中，有效的特征直接从训练数据中学习到。然而，现存的方法，不论是基于卷积神经网络还是深度神经网络，通常包括几个阶段和成分，可能是次优和消耗时间的。因此准确性和高效性还远不能让人满意。在本文中，流水线直接使用了全卷积网络模型(FCN),它能直接生成文本或者文字检测水平的预测，排除多余和缓慢的中间步骤。产生的文本预测可以是矩形也可以是四边形，被送到非极大值抑制来产生最终的结果。根据在标准基准上的质量和数量检测，相比于现存的方法，提出的算法实现了显著地更强的性能，同时运行的更快。特别地，提出的算法在ICDAR2015上实现了0.7820的F分数(在多尺度上为.8072)在MARATD500上为0.7608，在COCO-Text上为0,3945。优于先前体现最高水平的算法的性能，同时平均下来使用了更少的时间(13.2fps在720P的分辨率下，使用Titan-X GPU用于我们性能最好的模型，16.8fps用于我们最快的模型)此工作的贡献是三倍的:(1)我们提出了一种包括两个阶段的场景文本检测方法:一个全连接神经网络和极大值抑制(NMS)合并解读那，全连接层直接产生了文本区域，去除了多余的和消耗时间的中间步骤。(2)流水线适用于产生单词水平或者线水平的预测，预测的几何形状可以是旋转的方框或者是四边形，这取决于特定的应用。(3)提出的算法显著地最高水平方法的准确性和速度。 2.相关工作场景文本检测和识别已经是计算机视觉领域长时间内很活跃的研究领域。大量鼓舞人心的想法和有效的方法已被探讨。常规的方法依靠人工设计特征。而最近场景文本检测已经进入了基于深度神经网络逐渐成为主流的新时代。黄等人首先使用MSER找到候选然后运用深度卷积网络作为强大的分类器来修剪错误的正例。Jaderberg的方法用滑动窗口的方式扫描图像并且使用一种卷积神经网络模型产生了一种密度热量图，后来，Jaderberg应用CNN和ACF来捕获单词候选，并且使用回归提炼它们。田等人开发了一种垂直的锚并且建立了一个CNN-RNN联合模型来检测水平文本线。区别于这些方法，张等人提出了一种利用全连接网络(FCN)用于热量图代和使用元素投影来进行朝向预测。这些方法在标准基准上获得了极佳的性能。然而，由图二所示，它们大多由多个阶段和元素组成，例如通过后滤波，候选聚合，线形成和分词来进行错误正例去除。多数阶段和成分可能需要详尽的调整，导致次优的性能，并且增加整个流水线的处理时间。在本文中，我们提出了一种直接可以定位最终文本检测结果的深度基于全连接网络的流水线。由图2(e)所描绘的，模型放弃了不必要的中间成分和步骤，并且允许端到端训练和优化。组合的系统配备了单一轻量的神经网络，在性能和速度上明显的超过了所有先前的方法。 3.方法(Methodology)这种提出算法的核心成分是神经网络模型，他被训练于直接预测文本实例的存在和它们在整张图像中的几何形状。模型是一个全连接卷积网络适用于输出每个像素的单词或文本线的温而不能预测。这里去除了中间步骤提出候选，文本区域生成和分词。后处理步骤仅仅包括二值化和非极大值抑制来预测几何形状。检测器叫做EAST，因为它是一个有效且准确的场景文本检测流水线。 3.1流水线我们流水线的一个高水平的概况在图2(e)中显示。算法跟随着密度盒的总体设计，其中图像被输入到全连接网络，输出多个通道的像素级的文本分数图和几何形状。预测通道之一是在[0,1]区间范围内的像素值。其余通道表示了通过观察每个像素而围城单词的形状。分数表示了几何形状预测相同位置的信心程度。我们用两个用于文本区域的几何形状，旋转盒(RBOX)和四边形(QUAD),并且对每个几何形状设计不同的损失函数。二值化接下来被应用于每个预测区域，在预先定义的阈值之上的几何形状被认为是有效的，并且被保存用于之后的非极大值抑制。非极大值抑制后输出的结果被认为是流水线的最终输出结果。 3.2网络设计当设计神经网络时几个因素必须被考虑到。既然单词区域的大小变化的非常剧烈，确定大单词的存在会要求神经网络后部的特征，同时预测准确的将小单词围起来的区域需要神经网络前部低水平的信息。。因此网络一定要使用不同阶段的特征来满足这些要求。HyperNet满足了这些在特征图上的条件，但是合并在大量特征图上的通道会显著地增加计算消耗对于后面的阶段来说。为了改正这一点，我们采用U-shape的方法来逐渐合并特征图，同时保持向上采样的分支尽量小。我们最终得到了一个技能利用不同水平的并且能保持较小的计算消耗的网络。我们某些的简述在图3中被描绘。模型可以被分解成三部分，特征提取茎(stem)，特征融合分支(branch)和输出层。 stem可以是在ImageNet数据集上预训练的卷积网络，夹杂着卷积核赤化层。标记为$f_i$的特征图的四个水平从stem中被提取出来，他们的尺寸分别是输入图像的1/21.1/16,1/8和1/4。在图3中，PVAN被描绘出来。在摸们的实验中，我们也采用了有名的VGG16模型，特征图在池化2和池化5后被提取出来。在特征融合分支，我们渐渐融合它们。 \begin{equation}g_{i}=\left{\begin{array}{ll}{\operatorname{unpool}\left(h_{i}\right)} &amp; {\text { if } \quad i \leq 3} \ {\operatorname{conv}{3 \times 3}\left(h{i}\right)} &amp; {\text { if } \quad i=4}\end{array}\right.\end{equation} \begin{equation}h_{i}=\left{\begin{array}{ll}{f_{i}} &amp; {\text { if } i=1} \ {\operatorname{conv}{3 \times 3}\left(\operatorname{conv}{1 \times 1}\left(\left[g_{i-1} ; f_{i}\right]\right)\right)} &amp; {\text { otherwise }}\end{array}\right.\end{equation}其中$g_{i}$是融合基，$h_i$是被融合的特征图，而操作器$[·;·]$代表着沿着通道轴的级联。在每个融合阶段，从上一阶段的特征图首先输入一个反池化层使其大小翻倍，接下来与当前特征图相连。接下来，一个$conv_{1 \times 1}$瓶颈降低了通道的数量且降低了计算量，跟随着的操作是$conv_{3 \times 3}$使得最终产生融合阶段的输出。跟随着随后的融合阶段，一个$conv_{3 \times 3}$层生成了最终融合分支的特征图且将其输入输出层。每次卷积输出通道的数目在图3中描绘，我们保持在分支(branch)中的卷积的通道的数目尽量小，仅在stem后增加了少量的计算开销，使得网络计算高效。最终输出层包括几个$conv_{1 \times 1}$操作来产生32个通道到得分图$F_s$的一个通道和多通道的几何图$F_g$。几何输出可以是RBOX或者是QUAD，在表1中总结。对于RBOX，几何形状被轴向包围盒(AABB)$\mathbf{R}$的四个通道和一个通道旋转角$\theta$代表。$\mathbf{R}$的四个通道代表着从四边形的像素位置分别到顶端，右边，底部，左边边界的距离。对于QUAD$\mathbf{Q}$，我们用8个数字来代表从四边形像素坐标的四个顶点$\left{p_{i} | i \in{1,2,3,4}\right}$的坐标偏移。由于每个距离偏移包括两个数字$\left(\Delta x_{i}, \Delta y_{i}\right)$，形状输出包括8个通道。 3.3标签生成3.3.1四边形得分图生成在不失去一般性的前提下，我们仅仅考虑形状是四边形的情况。四边形在得分图上的正区域被大概设计为原始的所见版本，在图4(a)中描绘。对于一个四边形$\mathbf{Q}=\left{p_{i} | i \in{1,2,3,4}\right}$，其中$p_{i}=\left{x_{i}, y_{i}\right}$是四边形以顺时针方向的顶点。为了缩小$\mathbf{Q}$，我们首先计算对于每个顶点$p_i$的参考距离$r_i$为:\begin{aligned} r_{i}=\min ( \mathrm{D}\left(p_{i}, p_{(i \bmod 4)+1}\right) ， \mathrm{D}\left(p_{i}, p_{((i+2) \bmod 4)+1}\right) ) \end{aligned}其中$\mathrm{D}\left(p_{i}, p_{j}\right)$是$p_i$和$p_j$之间的$L_2$距离我们首先缩小四边形的两个长边，接下来两个短边。对于每一对两个相对的边，我们定义更长的那对通过比较他们长度的平均值。对于每个边$\left\langle p_{i}, p_{(i \bmod 4)+1}\right\rangle$,我们通过向内分别移动$0.3r_i$和$0.3r_{(i \bmod 4)+1}$使其缩小。 3.3.2几何图生成几何图可以是RBOX或QUAD。RBOX的生成过程见图4(c-e)对于那些文字区域以QUAD风格注释的数据集(如ICDRA2015)，我们首先生成一个旋转的四边形以覆盖最小的区域。接下来对于每个有正分数的像素点，我们计算其到文本框四个边界的距离，然后将其置为RBOX基本值得四个通道。对于QUAD的基本值，在8通道几何图中有正分数的每个像素的值是它的坐标到四边形四个顶点的偏移距离。 3.4损失函数损失可以被定义为 $$L=L_{\mathrm{s}}+\lambda_{\mathrm{g}} L_{\mathrm{g}}$$ 其中$L_s$和$L_g$代表着分数图和几何形状的损失，$\lambda_{\mathrm{g}}$代表两种损失间的权重。在我们的实验中，我们将$\lambda_{\mathrm{g}}$置为1 3.4.1分数图的损失在大多数体现最高水平的检测流水线中，通过平衡采样和难分样本挖掘(hard negative mining)来处理目标物体的不均衡分布。这样做潜在地提高了网络的性能。然而，使用这样的技巧不可避免地引入不可微的阶段和更多参数来调试和更复杂的流水线，这违背了我们的设计准则。为了促使一个更为简洁的训练程序，我们使用类平衡交叉熵，公式为: \begin{equation}L_{\mathrm{s}} =\text { balanced-xent }\left(\hat{\mathbf{Y}}, \mathbf{Y}^{}\right) =-\beta \mathbf{Y}^{} \log \hat{\mathbf{Y}} -(1-\beta)(1-\mathbf{Y}^{*}) \log (1-\hat{\mathbf{Y}})\end{equation} 其中$\hat{\mathbf{Y}}=F_{\mathrm{s}}$是得分图的预测,$\mathbf{Y}^{*}$是真实值。参数$\beta$是正例和负例的平衡因子，由下式给定 \begin{equation}\beta=1-\frac{\sum_{y^{} \in \mathbf{Y}^{}} y^{}}{\left|\mathbf{Y}^{}\right|}\end{equation} 平衡交叉熵首先Yao等人用于文本检测，作为得分图预测的目标函数。 3.4.2几何形状的损失文本检测的一个挑战是单词区域的大小变化的非常剧烈。直接使用$L1$或者$L2$损失用于回归会引起损失偏差朝向更大更长的文本区域。我们需要产生准确的文本形状不论是大的还是小的文本区域，而回归损失应该是比例不变的。因此，我们使用IoU损失在RBOX的AABB部分，和一个规模正则化平滑L1损失用于QUAD回归。$RBOX$对于AABB部分，我们使用IoU损失因为它对不同规模的物体都是不变的。 \begin{equation}L_{\mathrm{AABB}}=-\log \operatorname{IoU}\left(\hat{\mathbf{R}}, \mathbf{R}^{}\right)=-\log \frac{\left|\hat{\mathbf{R}} \cap \mathbf{R}^{}\right|}{\left|\hat{\mathbf{R}} \cup \mathbf{R}^{*}\right|}\end{equation} 其中$\hat{\mathbf{R}}$代表预测的AABB形状而$\mathbf{R}^{}$是它对应的真实值。很容易可知相交正方形$\left|\hat{\mathbf{R}} \cap \mathbf{R}^{}\right|$的宽度和高度为: \begin{equation}\begin{aligned} w_{\mathrm{i}} &amp;=\min \left(\hat{d}{2}, d{2}^{}\right)+\min \left(\hat{d}{4}, d{4}^{}\right) \ h_{\mathrm{i}} &amp;=\min \left(\hat{d}{1}, d{1}^{}\right)+\min \left(\hat{d}{3}, d{3}^{}\right) \end{aligned}\end{equation}其中$d_1,d_2,d_3$和$d_4$代表着一个像素点到其对应四边形顶端，右侧，底部和左侧边界的距离。联合区域由下式给定:\begin{equation}\left|\hat{\mathbf{R}} \cup \mathbf{R}^{}\right|=|\hat{\mathbf{R}}|+\left|\mathbf{R}^{}\right|-\left|\hat{\mathbf{R}} \cap \mathbf{R}^{}\right|\end{equation}因此交集和并集可以被轻松地计算。接下来，旋转角度被计算为:\begin{equation}L_{\theta}\left(\hat{\theta}, \theta^{}\right)=1-\cos \left(\hat{\theta}-\theta^{}\right)\end{equation}其中$\hat{\theta}$是旋转角度的预测值，$\theta^{}$是旋转角度的真实值。最终，总体形状损失是AABB的加权损失和角度损失，由下式给出:\begin{equation}L_{\mathrm{g}}=L_{\mathrm{AABB}}+\lambda_{\theta} L_{\theta}\end{equation}其中$\lamda_{theta}$在实验中被设为10注意我们计算$L_{AABB}$并没有考虑旋转角度。这可以看做是四边形IoU的近似当角度被完美地预测时。尽管这不是训练时的情况，它仍然可以采用正确的梯度来学习以预测$\hat{\mathbf{R}}$$QUAD$我们扩展平滑L1损失通过增加设计用于单词四边形的正则项，它通常在某一方向上更加长。令$Q$的所有坐标值为一有序集\begin{equation}\mathrm{C}{\mathrm{Q}}=\left{x{1}, y_{1}, x_{2}, y_{2}, \ldots, x_{4}, y_{4}\right}\end{equation}接下来损失可以被写为:\begin{equation}L_{\mathrm{g}}=L_{\mathrm{QUAD}}\left(\hat{\mathbf{Q}}, \mathbf{Q}^{}\right)=\min {\tilde{\mathbf{Q}} \in P{\mathbf{Q}^{}}} \sum_{\tilde{c}{i} \in \mathbb{C}{\tilde{\mathbf{Q}}}} \frac{\operatorname{smoothed}{L 1}\left(c{i}-\tilde{c}{i}\right)}{8 \times N{\mathbf{Q}}}\end{equation}其中正则项$\mathrm{N}{\mathrm{Q}^{*}}$为四边形的短边，由下式给出：\begin{equation}N{Q^{}}=\min {i=1} D\left(p{i}, p_{(i \bmod 4)+1}\right)\end{equation}而$P_Q$是有着不同顶点顺序$Q_{}$的所有相等四边形的集合。这种有序的排列是必须的因为公开训练集的四边形的注释是不一致的。 3.5训练网络使用ADAM优化器进行端到端的训练。为了加速学习，我们一致地从图像中采样512x512的切片以形成尺寸为24的小批量。ADAM的学习率从1e-3开始，每隔27300个迷你批量衰减1/10，停止于1e-5.网络会训练到性能不再提升。 3.6位置感知极大值抑制(Locality-Aware NMS)为了形成最终的结果，二值化后形成的几何形状应该被NMS融合。一种原始的NMS算法以O(n^2)复杂度运行，其中n是几何形状候选数，这是不可接受的当我们面对从密度预测得到的上万个几何形状。 词汇fall short 缺乏;不足interplay 相互作用yield 产生，退让quadrilateral 四边形intermediate 中间的aggregation 聚合simplicity 简单outperform 表现更好resolution 决议，决心prerequisite 先决条件utilize 使用exclude 排除redundant 多余rectangle 矩形quadrangle 四边形suppression 抑制quantitative 定量的，量化的unprecedented 史无前例的prerequisite 条件extraction 提取manually 手动地utilize 利用outperform 表现优于state-of-the-art 使用最先进技术的，体现最高水平的review 评论comprehensive 综合的，全面的conventional 常规的prune 修剪regression 回归refine 提炼anchor 锚vertical 垂直projection 投影formation 编队，形成multitude 多数exhaustive 详尽的tuning 调整devise 发明，设计depicte 描绘resultant 组合的remedy 救济，改正adopt 收养，采用schematic 略图的;简表的;严谨的interleave 插入，夹进concatenation 一系列相关联的事物concatenate with 与…连接bottleneck 瓶颈，阻碍fraction 少量overhead 开销vertice 顶点generality 一般性;概述inward 向内地，向中心地annotate 给…做注解minimal 最小的inevitably 不可避免地contradicts 反驳，与..相反facilitate 促进inconsistent 不一致的uniformly 一致的，均匀的 概念(1)分类模型的评价指标Fscore $$ F-score=1+\beta^2\frac{PercisionRecall}{\beta^2(Percision+Recall)} $$ 其中$\beta$的取值有三种情况如果取1,表示Precision与Recall一样重要如果取小于1,表示Precision比Recall重要如果取大于1,表示Recall比Precision重要(2)难分样本挖掘(hard negative mining)对于目标检测中我们会事先标记处ground truth，然后再算法中会生成一系列proposal，这些proposal有跟标记的ground truth重合的也有没重合的，那么重合度（IOU）超过一定阈值（通常0.5）的则认定为是正样本，以下的则是负样本。然后扔进网络中训练。However，这也许会出现一个问题那就是正样本的数量远远小于负样本，这样训练出来的分类器的效果总是有限的，会出现许多false positive，把其中得分较高的这些false positive当做所谓的Hard negative，既然mining出了这些Hard negative，就把这些扔进网络再训练一次，从而加强分类器判别假阳性的能力。]]></content>
      <categories>
        <category>paper learning</category>
      </categories>
      <tags>
        <tag>-paper learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在谷歌云服务器上搭建深度学习平台]]></title>
    <url>%2Fvampire1996.github.io%2F2019%2F05%2F03%2Fgcp%2F</url>
    <content type="text"><![CDATA[创建实例参考注意这里申请配额时，需要申请的是GPUs(All Regions),单独申请某一型号的GPU不好使。我在网上查到申请后会发邮件让你充35刀，但是我申请后直接给我发接邮件说申请配额成功(微笑) 使用putty远程连接参考 sha1:9c6a22bb10a2:bf05beffb070312fa52a90c5a0acb6eb27f965d8 在谷歌云服务器上搭建深度学习平台下面这篇写的非常详细使用Xshell连接云虚拟机 使用自己的数据集在控制台选择存储-&gt;浏览器，选择创建存储分区，创建后上传数据集文件上传文件完成后，点击文件名浏览器就会自动下载。这里以chrome浏览器为例，点击右上角选择下载内容，将下载数据集的链接右键+复制链接地址接下来再云虚拟终端中输入命令1wget 数据集链接 即可将数据集保存到VM实例中 在juypter notebook中解压zip文件1234import zipfilef = zipfile.ZipFile("/home/xiaosakun/code/EAST_ICPR/resnet_model/east_icpr.zip",'r')for file in f.namelist(): f.extract(file,"/home/xiaosakun/code/EAST_ICPR/resnet_model/") 在gcp虚拟机上跑阿里天池程序本文教你如何在gcp虚拟机上跑阿里天池新人赛网络图像的文本检测的程序。首先大前提是已经成功安装anaconda，tensorflow,同时在命令行中输入jupyter notebook以启动notebook(1)下载程序在jupyter notebook中新建cell并输入1!git clone https://github.com/HaozhengLi/EAST_ICPR.git (2)数据下载和处理下载github地址中的已训练好的模型(任选下图中一个)，同时在阿里云赛事官网下载数据集。接下来再matlab中运行project中的rename.m，记得修改测试集地址为自己本地的地址。处理完之后将\ICPR2018_test文件夹下的图片打包成zip文件，同时将模型文件也打包成zip文件。(3)上传数据和模型在控制台选择存储-&gt;浏览器，选择创建存储分区，创建后上传测试集和模型打包后的zip文件上传文件完成后，点击文件名浏览器就会自动下载。这里以chrome浏览器为例，点击右上角选择下载内容，将下载文件的链接右键+复制链接地址接下来再云虚拟终端中输入命令1wget 文件链接 即可将数据集保存到VM实例中，可以在notebook中查看其位置并将其移到需要的位置。(3)在juypter notebook中解压zip文件1234567import zipfilef = zipfile.ZipFile("/home/xiaosakun/code/EAST_ICPR/resnet_model/east_icpr.zip",'r')for file in f.namelist(): f.extract(file,"/home/xiaosakun/code/EAST_ICPR/resnet_model/")f = zipfile.ZipFile("/home/xiaosakun/code/EAST_ICPR/data/ICPR_data/ICPR2018_test.zip",'r')for file in f.namelist(): f.extract(file,"/home/xiaosakun/code/EAST_ICPR/data/ICPR_data/") (4)运行程序下载依赖，由于tensorflow版本兼容问题这里可能出错，所以可以打开requirements.txt，用pip命令一条一条下载，每个库的版本可以根据pip insatll后出现的提示确定。123import osos.chdir('/home/xiaosakun/code/EAST_ICPR')!pip install -r requirements.txt 如果只是想生成txt文件而不需要将图像中的文本都框出来同时保存成新的图像文件，则只需将eval.py中以下程序屏蔽。123if not FLAGS.no_write_images: img_path = os.path.join(FLAGS.output_dir, os.path.basename(im_fn)) cv2.imwrite(img_path, im[:, :, ::-1]) 运行验证程序并生成相应的txt文件123import osos.chdir('/home/xiaosakun/code/EAST_ICPR')!python eval.py --test_data_path=data/ICPR_data/ICPR2018_test/ --gpu_list=0 --checkpoint_path=resnet_model/east_icpr2018_resnet_v1_50_rbox_1035k/ --output_dir=resnet_result/ 针对报错的处理方法i.出现报错can not compile lanms修改lanms/Makefile中的$(shell python-config –cflags)为以下形式1-I/home/xiaosakun/anaconda3/include/python3.6m -I/home/xiaosakun/anaconda3/include/python3.6m -Wno-unused-result -Wsign-compare -march=nocona -ftree-vectorize -fPIC -fstack-protector-strong -O3 -pipe -fdebug-prefix-map==/usr/local/src/conda/- -fdebug-prefix-map==/usr/local/src/conda-prefix -fuse-linker-plugin -ffat-lto-objects -flto-partition=none -flto -flto -fuse-linker-plugin -ffat-lto-objects -flto-partition=none -g -DNDEBUG -fwrapv -O3 -Wall 这里前两个地址是虚拟机中ananconda目录下python的地址，根据以上形式修改即可。ii.出现报错undefined symbol: _Py_ZeroStruct将eval.py进行以下修改123##在第97行，出错原因和gcc版本有关boxes = nms_locality.nms_locality(boxes.astype(np.float64), nms_thres)#使用python实现，速度相对较慢，但是不会报错#boxes = lanms.merge_quadrangle_n9(boxes.astype('float32'), nms_thres)#使用c++实现，速度更快 (5)将结果压缩为zip文件12345678910import zipfileazip = zipfile.ZipFile('bb.zip','w')#新建zip文件for current_path, subfolders, filesname in os.walk(r'/home/xiaosakun/code/EAST_ICPR/resnet_result'): #print(current_path, subfolders, filesname) # filesname是一个列表，我们需要里面的每个文件名和当前路径组合 for file in filesname: # 将当前路径与当前路径下的文件名组合，就是当前文件的绝对路径 azip.write(os.path.join(current_path, file))# 关闭资源 azip.close() (5)将结果保存到google storage bucket中由于直接在VM中下载文件速度很慢，需要将文件保存到google storage bucket，以提高下载速度官方文档准备工作这里需要注意的是在VM已经提前预装好python和gsutil，因此不再需要安装，但是安装Cloud SDK时，使用文档中的命令会报错1./google-cloud-sdk/bin/gcloud init 直接使用以下命令按照提示输入关联的project即可1gcloud init 接下来只需输入以下命令即可将zip文件复制到google storage中的dataseteast bucket中,这里dataseteast是提前创建的存储分区。1gsutil cp /home/xiaosakun/code/EAST_ICPR/bb.zip gs://dataseteast/]]></content>
      <categories>
        <category>deep learning</category>
      </categories>
      <tags>
        <tag>-deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一种用于基于图像的序列识别的端到端可训练神经网络及其在场景文字识别上的应用]]></title>
    <url>%2Fvampire1996.github.io%2F2019%2F04%2F28%2FpaperLearning1%2F</url>
    <content type="text"><![CDATA[原文链接 摘要基于图像的序列识别已经是计算机视觉领域长期存在的研究课题。在本篇论文中，我们调查了场景文字识别的问题，它包括在基于图像的序列识别中的最为重要和具有挑战性的任务。一种新颖的神经网络结构被提出，包括特征提取，序列建模和转化为统一结构。相比于之前的泳衣场景文字识别的系统，提出的结构具有四个不同的属性:(1)相比于大多数现存的元素分开训练和调整的算法，它是端到端可训练的(2)它自然地处理任意长度的序列，并且没有文字分割和水平方向上规模的标准化(3)它并不受限于任何预先设定的词库并且实现了在无词库和基于词库的场景文字识别任务上都有显著的性能。(4)它产生了一种有效但是更小的模型，对于真实世界的应用脚本更为有效实验在基准上进行，包括IIIT-5K，Street Veiw Text和ICDAR数据集，显示了提出算法相对于之前方法的优越性。除此之外。提出的算法在基于图像的乐谱识别任务上也表现良好，这也更明显地确认了算法的广泛性。 介绍(introduction)基于DCNN(deep conventional neural network)的方法有(1)先将文字一个一个地检测出来，接下来再用DCNN(已经用单个文字图像进行了训练)对这些单个的文字进行识别,但是把文字单个切割出来对模型的准确性要求很高。(2)将文本检测看成图像分类问题，也就是给每个单词一个标签，但这样模型会变得异常的大，也不太可能应用到中文识别或者乐谱识别上(数据集太大)总结:基于DCNN的系统不能直接用于基于图像的序列识别。基于RNN的方法:需要将输入目标图片转换为图像特征的序列，但是这个预处理过程和之后pipeline中的元素相互独立，所以无法以端到端的方式训练和优化。本文提出一种新颖的网络模型RCNN(Conventional Recurrent Neural Network)，它是DCNN和RNN的结合。CRNN的优点包括:(1)可以直接从序列标签(比如单词)中学习，不需要详细的注解(比如文字)(2)可以直接从图像数据中学习信息表达，和DCNN有着相同的性质。(3)可以产生序列标签，和RNN一样(4)对序列目标的长度没有限制，仅仅要求训练和测试阶段高度(比如图像的高度)的标准化(5)它显示了相对于之前方法更高的性能(6)包括更少的参数向对于标准的DCNN，消耗更少的内存 网络结构CRNN包括三部分(1)卷积层(对输入图像的特征进行提取)用于提取输入图像的Convolutional feature maps，即将大小为(32,100,3)的图像转换为(1,25,512)大小的卷积特征矩阵，feature maps的每一列都是一个一个特征向量采用标准RNN的卷积层和maxpooling层，去掉全连接层在输入图像之前，所有图像都需要转换为相同的高度感受野(receptive field):每一个特征图中的特征序列都对应着原图中的一个矩形区域，可以看成是那个区域的一个解释器(2)给序列打标签使用循环层有三个好处i.RNN有很强的捕捉序列文本信息的能力ii.RNN可以反向传播它的误差差分到输入(比如卷积层)，这样我们就在一个网络中可以共同训练循环层和卷积层iii.RNN可以飞任意长度的序列进行遍历操作传统的RNN具有梯度弥散的问题，限制了它能存储的文本范围，并且向训练过程增加负担。长短期记忆网络(LSTM)解决了这种问题,由一个存储单元和三个乘法门组成，即输入门、输出门和遗忘门。概念上讲，记忆单元存储过去的文本，输入输出门使这个单元存储文本很长一段时间，同时遗忘门可将这个单元的存储遗忘。LSTM的特殊设计使得它能够捕获长距离的依赖关系，这种依赖关系经常出现在基于图像的序列中。LSTM的特殊设计使得它能够捕获长距离的依赖关系，这种依赖关系经常出现在基于图像的序列中。LSTM是有方向的，然而，对于基于文本的序列，它的两个方向的文本都是有意义和互补的(图像从右到左和从左到右遍历)。因此，我们使用两个LSTM，一个前向，一个后向，变成一个双向LSTM。除此之外，多个双向LSTM可以堆叠，变成一个深度双向LSTM。相对于浅层结构，这种深度结构允许一种更高水平的抽象化，并且在语音识别上实现了显著的性能提升。在循环层，误差差分在相反的方向传播，也就是随着时间反向传播(BPTT).在循环层的底部，被传播的差分被连接成映射，反转将特征映射转换为特征序列的操作，并且反馈给卷积层。实践中，我们创造了一种定制网络层，叫做映射到序列，作为卷积层和循环层之间的桥梁。(3)转录转录是将RNN做出的每一帧的预测转换为标签序列。数学上来讲，转录是在每一帧预测的前提下，找到具有最高可能性的标签序列。在实践中，有两种转录模式，分别是基于词库和无词库的转录。词库是值被类似于其预测被拼写检查词典所约束的标签序列集。在无词库模式下，预测在无词库前提下实现。在基于词库的模式下，根据最高可能性的标签序列进行预测。i.标签序列的概率我们采用了CTC中定义的条件概率，序列l在每一帧预测$y=y_1,…,y_T$条件下的概率，并且忽略了每个标签在l中的位置。因此，当我们采用这个概率的负对数似然作为训练的目标，我们仅仅需要图像和它们对应的序列标签，避免了给单个字符位置打标签的工作。条件概率的公式被简明地描述如下:输入序列为$y=y_1,…y_T$这里T代表序列的长度。这里，每个$y_t \in R^{|L’|}$是在集合$L’=L \cup$下的概率分布，这里$L$包括任务中的所有标签(比如说所有的英文字符)，同时还有空白标签。一个序列到序列的映射函数$B$被定义在序列$\pi \in L^{‘T}$,这里T是长度。$B$通过首先去掉重复标签，再去掉空白标签，将$\pi$映射到序列1。比如$B$映射”–hh-e-l-ll-oo–”(-代表空白标签)到”hello”.接下来条件概率被定义为所有被$B$映射到序列1的$\pi$的概率和。 $$\begin{gather}p(l|y)=\sum_{\pi:B(\pi)=1} p(\pi|y)\end{gather}$$这里$\pi$的概率被定义为 $p(\pi|y)=\prod_{t=1}^{T}y_{\pi_t}^t$,$y_{\pi_t}^t$是在时步t拥有标签$\pi_t$的概率。由于指数求和项的数值很大，直接计算公式1是计算不可行的。然而，公式1可以由前向传播算法高效地计算。ii.无词库转换在这种模式下，序列$l^{\ast}$根据公式1的预测具有最高的概率。序列$l^{\ast}$近似的由公式$l^{\ast}\approx B(argmax_{\pi}p(\pi|y))$,也就是说找到每一时步t最大可能性的标签$\pi_t$,并且将结果序列映射到$l^{\ast}$iii.基于词库的转换在基于词库的模型中，每一个测试样本和一个词库$D$相关联。基本上来说，标签序列通过选择被公式1所定义的最高概率的在词库中的序列($l^{\ast}=argmax_{l\in D}p(l|y)$).然而，对于大的词库，对于所有词库中的序列，在词库上进行详尽的搜索来计算公式1并且找到最大概率的那个序列会很费时。为解决这个问题，我们观察通过无词库转换得到的标签序列，然后总是寻找在公制编辑距离下最近的真实结果。这预示着我们可以限制我们的搜索到最近邻候选$N_{\delta}(l’)$.这里$\delta$是最大编辑距离，而$l’$是在无词库模型中的$y$转换而来的序列。 $$\begin{gather}l^{\ast}=\mathop {argmax }\limits_{l\in N_{\delta}(l’)} p(l|y)\end{gather}$$ 候选$N_{\delta}(l’)$可以通过BK-tree数据结构高效地找到，BK-tree数据结构是一种特别适合离散度量空间的度量树。搜索的时间复杂度是$O(log|D|)$,$|D|$是词库大小。因此这种方案非常便利的扩展到了非常大的词库。在我们的方案中，一个BK-tree对于词库是离线构建的。接下来我们利用树进行快速在线搜索，通过找到小于等于编辑距离$\delta$的序列，然后将其加到查询序列。 (4)网络训练标注训练集为 $\chi=\left{I_i,l_i\right}_i$ 这里$I_i$是训练图像，$l_i$是真实标签序列。目标是最小化负的真实标签的条件概率的最小似然。 $$\begin{gather}O=-\sum_{I_i,l_i \in \chi} logp(l_i|y_i)\end{gather}$$ $y_i$是将$I_i$输入到循环层和卷积层后产生的序列。通过一张图像和它的真实标签，目标函数直接计算了损失值。因此网络可以基于图像序列对进行端到端训练，去掉了人工在所有训练图像的单独元素上打标签的程序。网络用随机梯度下降SGD训练。梯度通过反向传播算法计算。特别的，在转录层，误差查分是随着前向传播算法反向传播的。在循环层，随着时间反向传播(BPTT)被应用于计算误差差分。对于优化部分，我们使用ADADELTA来自动计算每个维度的学习率。相比于传统的动量方法，ADADELTA不需要手动设定学习率。更重要的，我们发现使用ADADELTA比动量方法收敛的更快。 词汇long-standing 长期存在的novel 新颖的extraction 抽出，萃取transcription 转录unified 统一的distinctive 独特的，不同的tune 调整(v.)confined 受限的lexicon 词库scenario 脚本benchmark 基准superiority 优势prior 先前的evidently 明显地verify 校验，确认generality 概括，广泛性subsequent 随后的annotations 注释invariant 不变的convey 传达，传递holistic 全面的，整体的cell 单元multiplicative 乘法的complementary 互补的abstraction 抽象化concatenate 使连接起来inverting (使)倒转consequently 因此denote 标志，预示infeasible 不可行的tractable 易处理的exhaustive 详尽的metric 米制的;公制的scheme 方案readily 便利地conventional 传统的manual 手动的，手工的benchmark 基准 概念(1)端到端学习:端到端学习是一种解决问题的思路，与之对应的是多步骤解决问题，也就是讲一个问题拆分成多个步骤解决，而端到端是有输入端的数据直接得到输出端的结果。也就是说端到端将分布解决的中间步骤连接整合在一起，成为一个黑盒子，我们只能看到输入的数据和输出的结果，就是从数据的端，到结果的端。(2)梯度弥散(vanishing gradient problem):梯度弥散的问题很大程度上是来源于激活函数的“饱和”。因为在后向传播的过程中仍然需要计算激活函数的导数，所以一旦卷积核的输出落入函数的饱和区，它的梯度将变得非常小。梯度弥散。使用反向传播算法传播梯度的时候，随着传播深度的增加，梯度的幅度会急剧减小，会导致浅层神经元的权重更新非常缓慢，不能有效学习。这样一来，深层模型也就变成了前几层相对固定，只能改变最后几层的浅层模型。这样可以看到，如果我们使用标准化初始w，那么各个层次的相乘都是0-1之间的小数，而激活函数f的导数也是0-1之间的数，其连乘后，结果会变的很小，导致梯度消失。若我们初始化的w是很大的数，w大到乘以激活函数的导数都大于1，那么连乘后，可能会导致求导的结果很大，形成梯度爆炸。注意这里f3对f2求偏导时，f2是输入，计算完该表达式即可将f2数值带入计算出结果]]></content>
      <categories>
        <category>paper learning</category>
      </categories>
      <tags>
        <tag>-paper learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow学习]]></title>
    <url>%2Fvampire1996.github.io%2F2019%2F04%2F21%2FtfLearning%2F</url>
    <content type="text"><![CDATA[常用语法(1)tf.slice12t = tf.constant([[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]], [[5, 5, 5], [6, 6, 6]]])tf.slice(t, [1, 0, 0], [1, -1, -1]) t是一个shape为[3,3,3]的三维数组,[1, 0, 0]为begin矩阵,(1)第一个1代表从t第0维度的第一个元素开始(索引从0开始),也就是[[3, 3, 3], [4, 4, 4]](2)第二个0代表从t第1维度的第零个元素开始,也就是[3, 3, 3](2)第三个0代表从t第2维度的第零个元素开始,也就是3[-1, -1, -1]为size矩阵,(1)第一个1代表从t第0维度取一个元素,也就是[[3, 3, 3], [4, 4, 4]](2)第二个-1代表从t第1维度的取出全部元素,也就是[3, 3, 3], [4, 4, 4](2)第三个-1代表从t第2维度的取出全部元素,也就是3, 3, 3,4, 4, 4最终结果为[[3, 3, 3], [4, 4, 4]]tf.slice()到底怎么切的，看不懂你掐死我(2)tf.concat(用来拼接张量)1tf.concat([tensor1, tensor2, tensor3,...], axis) 举例1234t1 = [[1, 2, 3], [4, 5, 6]] t2 = [[7, 8, 9], [10, 11, 12]] tf.concat([t1, t2], 0) # [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]] tf.concat([t1, t2], 1) # [[1, 2, 3, 7, 8, 9], [4, 5, 6, 10, 11, 12]] axis=0代表在第0个维度拼接axis=1代表在第1个维度拼接对于[[],[]]和[[],[]]，低维拼接等于拿掉最外面括号，高维拼接是拿掉里面的括号(保证其他维度不变)。注意：tf.concat()拼接的张量只会改变一个维度，其他维度是保存不变的负数在数组索引里面表示倒数(countdown)。比如，对于列表ls = [1,2,3]而言，ls[-1] = 3，表示读取倒数第一个索引对应值。axis=-1表示倒数第一个维度，对于三维矩阵拼接来说，axis=-1等价于axis=2。同理，axis=-2代表倒数第二个维度，对于三维矩阵拼接来说，axis=-2等价于axis=1。]]></content>
      <categories>
        <category>TensorFlow</category>
      </categories>
      <tags>
        <tag>-TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习]]></title>
    <url>%2Fvampire1996.github.io%2F2019%2F04%2F21%2FpythonLearning%2F</url>
    <content type="text"><![CDATA[常用语法12a=[1,2,3]print(a[1:2]) 输出:2 int和string相互转换1.字符串转换成int123a = '10'int(a) //十进制string转化为int， 10int(a, 16) //十六进制string转化为int，16 2.int转换成字符串注意str在python中是关键字123a = 10str(a) //int转化为十进制stringhex(a) //int转化为十六进制string numpy(1)数组维度(array.ndim)，形状(array.shape)，大小(array.size)12345678910111213import numpy as nparray = np.array([ [1, 2, 3], [4, 5, 6]])print(array)print('number of dim:',array.ndim)print('shape:', array.shape)print('size:', array.size) opencv及图像操作1.对图像大小进行放缩(1)用Image的resize()123456789import numpy as npfrom PIL import Imagefrom skimage import ioimage1 = Image.open('/content/cnn_lstm_ctc_ocr_for_ICPR/data/test_image/1_1.jpg') width = image1.size[0]height = 31image3 = image1.resize((width, height), Image.ANTIALIAS)image3 = np.array(image3)io.imshow(image3) 可将image1放缩由(15, 41, 3)放缩为(31, 41, 3)放缩后图像变为:(2)使用opencv进行放缩,且放缩后进行插值12345678import cv2import numpy as npfrom skimage import iocrop_size = (image1.size[0], 31)image1 = Image.open('/content/cnn_lstm_ctc_ocr_for_ICPR/data/test_image/1_1.jpg') image1 = np.array(image1)image_new = cv2.resize(image1, crop_size, interpolation = cv2.INTER_CUBIC)io.imshow(image_new) 其中1234CV_INTER_NN - 最近邻插值CV_INTER_LINEAR - 双线性插值 (缺省使用) CV_INTER_AREA - 使用象素关系重采样。当图像缩小时候，该方法可以避免波纹出现。当图像放大时，类似于 CV_INTER_NN 方法CV_INTER_CUBIC - 立方插值 可将image1放缩由(15, 41, 3)放缩为(31, 41, 3)放缩后图像变为: 2.对图像进行保持图像不被裁剪的旋转1234567891011121314151617181920212223import cv2from math import *import numpy as npfrom skimage import io img = cv2.imread(os.path.join(crop_dataset_dir_vert,'line_'+str(765)+".jpg")) height,width=img.shape[:2] degree=90#旋转后的尺寸heightNew=int(width*fabs(sin(radians(degree)))+height*fabs(cos(radians(degree))))widthNew=int(height*fabs(sin(radians(degree)))+width*fabs(cos(radians(degree)))) matRotation=cv2.getRotationMatrix2D((width/2,height/2),degree,1) matRotation[0,2] +=(widthNew-width)/2 #重点在这步，目前不懂为什么加这步matRotation[1,2] +=(heightNew-height)/2 #重点在这步 imgRotation=cv2.warpAffine(img,matRotation,(widthNew,heightNew),borderValue=(255,255,255))io.imshow(imgRotation)#将numpy.array转换为PIL.Imageimg = Image.fromarray(imgRotation.astype('uint8')).convert('RGB')img.save("/content/img.jpg") 文件操作将字符串str1写入txt文件123456output_txt = '/content/cnn_lstm_ctc_ocr_for_ICPR/result'listText = open(output_txt+'/'+'list.txt','w')listText.seek(0)#要从头开始否则只能将文件尾清空listText.truncate()#清空文件listText.write(str1)listText.close()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>-python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git学习]]></title>
    <url>%2Fvampire1996.github.io%2F2019%2F04%2F19%2FgitLearning%2F</url>
    <content type="text"><![CDATA[廖雪峰的git教程 创建版本库首先，选择一个合适的地方，创建一个空目录12mkdir learngitcd learngit 把这个目录变成Git可以管理的仓库1git init 远程仓库已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同在本地的learngit仓库下运行命令1git remote add origin git@github.com:michaelliao/learngit.git 注意要把上面的michaelliao替换成你自己的GitHub账户名若github上这个仓库不为空,本地和远程的文件应该合并后才能上传本地的新文件1、先拉下来，会自动合并的（不用操心）1git pull origin master 2、再上传1git push -u origin master 若远程库是空的，则推送master分支时，加上了-u参数,否则直接用命令1git push origin master 在github上创建新的仓库克隆到本地修改然后提交到github参考1.在本地某英文目录下输入，将仓库克隆到本地1git clone 要克隆的仓库地址,推荐使用SSH，因为速度更快而且不需要每次输入命令 2.进入本地刚刚克隆的仓库目录下，打开git bash,添加远程地址1git remote add origin git@github.com:yourName/yourRepository.git 3.对仓库内容进行修改4.执行命令(1)$ git inint 初始化(2)$ git status 获取文件夹的现在的状态(3)$ git add . (上传所有的文件 注意有个.记得写上)(4)$ git commit -m “提交信息(这里可能要输入账号信息)(5)$ git push origin master 上传到服务器]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>-git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科学上网]]></title>
    <url>%2Fvampire1996.github.io%2F2019%2F04%2F05%2FScientificlyInternetAccess%2F</url>
    <content type="text"><![CDATA[搭建梯子手把手教你如何自己搭梯子Vultr vps搭建属于自己的ss代理vultr官网用来管理服务器，需要注意Server Stop并不会停止计费而是只能停止机器，只有Server Destroy(完全销毁这个服务器)才会停止计费下载putty后，需要输入IP地址，然后点击open，即可进入命令行首先输入账户名root，接下来从vultr服务器上复制password(在终端中右键即可复制)接下来输入1wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh 下一句1chmod +x shadowsocks.sh 下一句1./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 中间会提示你输入你的SS SERVER的账号，和端口。不输入就是默认。跑完命令后会出来你的SS客户端的信息。特别注意，由于iphone端的目前只支持到cfb，所以我们选择aes-256-cfb，即7，这一步按回车继续然后需要几分钟的安装过程，请耐心等待！请立即copy下来加以保存。记录保存好你的上述信息：Server IP、Server Port、Password、Encryption Method。这时你的专属ss已经搭好了，开始使用吧。接下来使用shadowsocks客户端输入之前保存的Server IP、Server Port、Password信息即可 使用Shadowsockswindows:填好服务器IP,端口号和密码以后点确定,然后在电脑右下角找到纸飞机图标(也就是Shadowsocks)右键选择”启用系统代理”，然后访问个youtube之类的测试一下即可Android:下载好apk以后打开app，在当前配置文件旁边找到那个笔形状的按键，点进去以后填好服务器IP,端口号和密码连接即可. 在手机上使用Google play我的手机是小米8，仅说明在我的手机上的下载和使用方法在手机自带的应用商店搜索google,拉到最下面用豌豆荚搜索,下载谷歌安装器,然后就可以在里面下载谷歌全家桶了。(前提是已经用之前的方法使用了Shadowsocks) putty报错1[error] libsodium install failed 解决方法:cent os 换成较低版本或者换成ubuntu系统]]></content>
      <categories>
        <category>Scientific Internet access</category>
      </categories>
      <tags>
        <tag>-Scientific Internet access</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown学习]]></title>
    <url>%2Fvampire1996.github.io%2F2019%2F04%2F04%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[插入图片插入本地图片语法1&#123;% asset_img example.jpg This is an example image %&#125; 注意要将本地图片存放在同名文件夹中 markdown空格缩进markdown空格缩进以及HTML空格实体一个空格大小1&amp;ensp; 两个空格大小1&amp;emsp; 文字加粗给文字加上一组双引号1**加粗文字** 效果:加粗文字 使用pandoc渲染Pandoc中的Markdown语法插入图片1![月亮](月亮.jpg &quot;十五的月亮&quot;) 注意要将本地图片存放在同名文件夹中 github中的md操作换行行末加两个空格再按回车]]></content>
      <categories>
        <category>language learning</category>
      </categories>
      <tags>
        <tag>-language learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTex学习]]></title>
    <url>%2Fvampire1996.github.io%2F2019%2F04%2F04%2Flatex%2F</url>
    <content type="text"><![CDATA[在线编译器CodeCogs Equation Editor 使用VSCode编写LaTeX参考报错出现can’t spawn cmd.exe解决方法:在系统变量 path 增加一个项：C:\Windows\System32;支持中文路径方法:将 recipets 中的 %DOC%替换成%DOCFILE% 添加公式的方法行内公式1$行内公式$ 行间公式1$$行间公式$$ 需要注意的是在markdown环境下添加行间公式时要记得在每个行间公式上下空出一行，否则会出现显示问题 Latex 数学公式语法分式命令1\frac&#123;分子&#125;&#123;分母&#125; 效果$\frac{分子}{分母}$求和1\sum_&#123;i=1&#125;^&#123;n&#125;&#123;n*(n+1)&#125; 效果$\sum_{i=1}^{n}{n*(n+1)}$下角标1a_2 效果$a_2$幂级数1a^2 效果$a^2$多行下标12f \otimes w=\sum_&#123;\substack&#123;(a,b) \in w\\ (x+a,y+b)\in f&#125;&#125;f(x+a,y+b) w(a,b) 效果 $$f \otimes w=\sum_{\substack{(a,b) \in w\ (x+a,y+b)\in f}}f(x+a,y+b) w(a,b)$$给公式加入标号1\begin&#123;gather&#125; 公式 \end&#123;gather&#125; 效果$$\begin{gather} 公式 \end{gather}$$ 矩阵(写博客的时候markdown语法中换行符\好像不起作用,只能手动换行)12345\begin&#123;matrix&#125; 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9\end&#123;matrix&#125; 效果\begin{matrix} 1 &amp; 2 &amp; 3 \ 4 &amp; 5 &amp; 6 \ 7 &amp; 8 &amp; 9\end{matrix}123456matrix 不带括号 pmatrix 圆括号bmatrix 方括号Bmatrix 大括号vmatrix 行列式Vmatrix 行列式外面再加一行道 下角标有多个时1\mu&#123;k,l&#125; 效果$\mu{k,l}$ 在公式上下加括号123\begin&#123;equation&#125; \underbrace&#123;a + \overbrace&#123;b+\cdots&#125;^&#123;t&#125;+z&#125;_&#123;\text&#123;total&#125;&#125; \end&#123;equation&#125; 效果$$\begin{equation} \underbrace{a + \overbrace{b+\cdots}^{t}+z}_{\text{total}}\end{equation}$$ 在符号上方加字符1\stackrel&#123;i-1&#125;&#123;\oplus&#125; 效果 $\stackrel{i-1}{\oplus}$ 在字符下方加公式12345$$\begin&#123;gather&#125;l*=\mathop &#123;argmax &#125;\limits_&#123;l\in N_&#123;\delta&#125;(l&apos;)&#125; p(l|y)\end&#123;gather&#125;$$ 效果 $$\begin{gather}l^{\ast}=\mathop {argmax }\limits_{l\in N_{\delta}(l’)} p(l|y)\end{gather}$$ 使用大括号1$\chi=\left\&#123;I_i,l_i\right\&#125;_i$ 效果 $\chi=\left{I_i,l_i\right}_i$ 常用希腊字母表 常用特殊字符表 其他]]></content>
      <categories>
        <category>language learning</category>
      </categories>
      <tags>
        <tag>-language learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字图像处理]]></title>
    <url>%2Fvampire1996.github.io%2F2019%2F04%2F02%2FimageProcessing%2F</url>
    <content type="text"><![CDATA[上海交通大学数字图像处理课程1.2 图像的由来数字图像 f(x,y)表示(x,y)处的灰度/密度(intensity)像素(pixel size):最大可能的解像度分辨率(resuloution):决定图像的清晰度灰度/灰阶(grey level):0-255(在计算机内用一个字节存储)data:(1)2-3 demension(2)large(10MB-1GB) (3)voxel 体素(三维图像中常用)二维图像 f(i,j) 三维图像 f(i,j,k) 二维图像 f(i,j,k,t) t代表时间 i,j,k,t都是正整数,用于在计算机内存储数字图像三要素(1)pixel 要采样的点(2)grey level 灰度(3)coordinate 坐标数字图像处理(1)digit (2)digit image:某一物体的数值展示 (3)digit image processing:procesing and analysis (4)任务:数学建模,解决问题,软件编程图形–计算机描述 图像–真实世界 计算机图形学–模型,光照,几何结构，用计算机产生图形 计算机视觉–人的视觉与自然界交互采样:测量每个像素点的灰度值量子化(quantitization):通过整数表示测量值 连续-&gt;离散对比度:照片昏暗采样率:像素距离放大率:采集的图像与自然界的关系(比例尺) 医学图像中可以根据图像中的一个尺度来测量人体某个器官的大小存储格式(1)2D:raw-image,.bmp,.tif,.jpg,.gif(实际上不同的格式是对图想学习的压缩)(2)3D:raw+extra,info,.vox,.mnc,.dicom(医学图像国际标准) 1.3 图像的种类分类方法:(1)三维图像，灰度，彩色，伪彩(2)根据传感器:光学，红外，X光，雷达，MRI(核磁共振),超声(3)2D,3D,4D(心脏随时间的跳动)(4)传感器平台：显微镜，卫星,MRI机器灰度:0和255常用彩图:三个灰度图像的叠加 RGB 三个channel红外:自然界中温度的变化(可用伪彩方式表达)紫外(UV)：天文学显微图片:穿刺-在人体表面采样(活体采样–活采)核磁共振:更能描述人体软组织结构超声：对人体无害更廉价录像:对移动目标的跟踪，识别 1.4 图像的处理流程图像处理的流程：1.low level预处理(图像的滤波)从图像到图像2.intermediate level图像的分割，从图像到符号集(symbolic represetation)把图想从目标区域标定/分割出来3.high level图像的理解(模式识别)从符号集到功能描述医学图像处理的标准流程1.low level预处理(滤波)增强(sharpen)smooth(平滑)interpolate(插值)reduce noise(去噪)crop(从图片中切出一小块)2.intermediate level(中间的level)分割(segmentation)ROI(region of interest)区域边缘求取，分类，分组3.High level 识别(recognition)区域特点分析(定位，朝向，尺寸)目标匹配4.high level建模(model)数学模型，deformable model(可变形模型)，volume rendering(体积渲染)5输出 2.1图像的灰度直方图及其二值化一.灰度直方图(histogram)定义:灰度直方图是基于每个不同的灰度值对应图像中像素数目的分布特点:(1)整个图像浓缩到灰度直方图里，丢失了所有空间信息(确定每个灰度值的像素数;对于那些像素的位置没有任何提示;在图像上切出两方块位置对调对灰度直方图没有任何影响)(2)沿x轴积分可得图像面积应用:(1)帮助我们确定数字化参数(2)确定最优二值化的值(threshold level) –双峰性(bimodal histogram) 两峰值之间的最小值即为threshold level;两峰值之间是有叠加的(可以看做是两个高斯信号) 二.二值化(binary operation)1.二值化是一种简单的，非文本性的分割技术(利用二值化值把整个图像的像素(体素)分成两类–前景和背景)，产生一个二值化图像(binarisation)形式:(1)固定阈值(fixed)的二值化(2)动态的二值化(adaptive)–用于图像背景比较复杂，比如不断变化的背景(彩虹)二值化的方法很多,但都不是鲁棒的(robust)2.二值化vs灰度直方图(1)二值化通常分析了灰度直方图(2)比如二值化值作为灰度直方图的平均密度fixed/global threshold:整个图像的二值化值是一个常量，也可以是另一种形式(如一下公式所示) T代表threshold$$ g(x,y)=\begin{cases} 0 \qquad &amp; f(x,y) \lt T_1 \ 1 \qquad &amp; T_1 \le f(x,y) \le T_2 \ 0 \qquad &amp; f(x,y) \gt T_2 \end{cases} $$两个二值化值定义了密度值的范围(确定了想要的区域)好的二值化取决于二值化值的选取3.经典二值化算法(1)Isodata Algorithm算法为:&emsp;1.选择初始化二值化值 $T_0$&emsp;2.利用$T_0$将图像分成两部分($R_1$和$R_2$)&emsp;3.求$R_1$和$R_2$的均值$\mu_1$和$\mu_2$&emsp;4.选择新的二值化值$T_1=(\mu_1+\mu_2)/2$&emsp;5.重复2–4直到$T_i=T_i-1$(2)最优二值化(optimal threshold)不是所有图像都有双峰性最优二值化:一个评价函数(criterion function)对其最大值，最小值的计算，最终获得最优二值化值i.OTSU Algorithm(最有名的最优二值化算法)一些统计学概念频率:$$ \omega=\sum_{i=0}^{T} P(i) $$其中 $P(i)=n_i/N$，N代表总像素数，$n_i$代表某一个像素值对应的像素数均值:$$ \mu=\frac{ \sum_{i=0}^{T}{i*P(i)}}{\omega} $$ 方差:$$\sigma_t^2=\sum_{i=0}^{T}{(i-\mu)^2*P(i)}$$ 用between-classes variance $\sigma_b^2$来描述所有像素的总强度平均值的每个等级的平均值的变化substituting: $\sigma_b^2=\omega_0(\mu_0-\mu_t)^2+\omega_1(\mu_1-\mu_t)^2 $ 由$\mu_t=\omega_0\mu_0+\mu_1\omega_1$(整体图像的均值)得$\sigma_b^2=\omega_0\omega_1(\mu_1-\mu_0)^2$ $\omega_0,\omega_1,\mu_0,\mu_1$代表着两个类别，即前景和背景的频率和均值评价函数(between-classes方差相对于总方差)被定义为:$$\eta=\sigma_b^2/\sigma_t^2 $$所有可能的二值化值(0-255)都按这种方法评价,使得$\eta$最大的那个就是最优二值化值理解:二值化值T把一张图像分为两部分$R_0$和$R_1$$R_0$对应的频率$\omega_0$代表着所有阈值在T以下的像素点在总像素数中的占比$\mu_0$代表着阈值在T以下的像素点的加权平均,$\mu_1$代表着阈值在T以上下的像素点的加权平均$\eta$越大,方差越大,说明$R_0$，$R_0$两区域差别越大，二值化值得选取越合理ii.Entropy Method(熵算法)熵是衡量一个图像信息量多少的标准 $$ H_b=-\sum_{i=0}^{t} P_i*log(P_i) $$ $$ H_w=-\sum_{i=t+1}^{255} P_i*log(P_i) $$ b-black(背景) w-white(前景) t-threshold leve最优二值化的值即为满足下式对应的t值:$$ max:H=H_b+H_w $$实现:把t从0-255都取一遍找到最大的H值注:图像的双峰性可能较弱，有多个目标区,有多个峰值，利用OTSU和Entropy的得到的灰度直方图最小值(也就是threshold level)可能不同(3)自适应的二值化(adaptive/local/reginal thresholding)方法:切成多个小图像，分别求其二值化，再总体计算 2,2图像卷积及其滤波给定图像f(x,y)和核(kernel) w(a,b)convolution: \begin{gather}f \otimes w=\sum_{\substack{(a,b) \in w\ (x-a,y-b)\in f}}f(x-a,y-b) w(a,b)\end{gather} correclation: \begin{gather}f \otimes w=\sum_{\substack{(a,b) \in w\ (x+a,y+b)\in f}}f(x+a,y+b) w(a,b)\end{gather} 卷积的应用:(1)边缘强化灰度直方图(2)去除噪声,图像模糊(3)边缘增强 核:拥有9个magic number,将它们绑定在一起流程:(1)首先将核的正中心和图像上的每一个像素点进行叠加(把核放在图像的某一部分，与其压住的部分进行卷积运算,再向下一位置移动)(2)核中心压在图像上像素点的卷积值即为该像素点卷积后的值(也就是当前点和8个邻域对应位置灰度值进行乘积累加)注意:卷积值要在新的缓存(buffer)存储,而不要修改原图像灰度值卷积的流程:&emsp;(1)将核中心点与图像第一个像素点重叠，把核旋转$180^\circ$&emsp;(2)把核上每个点的灰度值与压在下面的像素的灰度值相乘，将这些计算结果叠加&emsp;(3)滑动核&emsp;(4)重复(2)，(3)直到图像被处理完问题:&emsp;(1)Q:如何计算图像边缘的卷积值&emsp;A:i.将边缘的一圈直接丢掉 ii.在边缘外再插一圈值,如最近邻插值&emsp;(2)Q:卷积计算结果可能超过0-255&emsp;A:小于0认为是0,大于255认为是255&emsp;(3)为什么要把核旋转$180^\circ$&emsp;A:小于0认为是0,大于255认为是255Q:由式(1)可得,x-a,y-b是做减法，核与其压在下面的像素坐标不是对应的，因此要旋转$180^\circ$，下图也可以说明,核的右下角坐标和图像的左上角坐标在计算时时对应的 卷积的应用:边缘增强什么是边缘线(edge):在两个区域的交界处所形成的的边缘的点所组成的线边缘线上的点:边缘点在边缘上灰度值有较大变化,是不连续的如何产生边缘线(1)颜色,亮度，材质，器官不同(2)两个平面的法向量的方向不同(朝向不同)(3)光照不同(illuminace)edge的属性:unique–从不同的观察点看是相同的(edge在空间位置上和朝向是不变的);也有non-unique edge在空间位置上和朝向是不变的edge的分类(阶跃;斜坡;峰值;1st代表一阶导数,2nd代表二阶导数)梯度gradient(用来表示edge的性质)边缘点(edge point)被定义为该点的二维一阶/二阶导数超过某一特定阈值的点数字图像f(x,y)的梯度被定义为:\begin{gather}\nabla f =\begin{bmatrix} G_x \ G_y\end{bmatrix} =\begin{bmatrix} \frac{\partial f} {\partial x} \ \frac{\partial f} {\partial y}\end{bmatrix}\end{gather} $G_x$:x方向求导 $G_y$:y方向求导梯度的数值(magnitude 平方根)\begin{gather}\nabla f(x,y) =mag(\nabla f(x,y))=[G_x^2+G_y^2]^\frac{1} {2}\end{gather}方向被定义为:\begin{gather}\alpha(x,y) =tan^-1 (\frac{G_x} {G_y})\end{gather} Edge operations(利用卷积方法计算梯度)(1)Roberts OperatorG_x G_y可以被近似计算为:$$G_x=z_9-z_5$$ $$G_x=z_8-z_6$$ (2)Prewitt Operator$$G_x=(z_7+z_8+z_9)-(z_1+z_2+z_3)$$ $$G_y=(z_3+z_6+z_9)-(z_1+z_4+z_7)$$ (3)Sobel Operator$$G_x=(z_7+z_8+z_9)-(z_1+z_2+z_3)$$ $$G_y=(z_3+z_6+z_9)-(z_1+z_4+z_7)$$ 由上式可知sobel算子可以实现边缘提取的效果(计算梯度) 除噪(noise reduce)也叫对图像的平滑(smoothing),清洁(noise cleaning)coherence(和谐)；图像具有一致性incoherence(不和谐):图像中具有噪声除噪:用和谐的点/它的灰度值来替换不和谐的点(对图像的均一化) 基于卷积的去噪方法1.高斯滤波(高斯平滑)高斯核(意涵数–和为1)\begin{gather}G(x,y) =\frac{1} {2 \pi \sigma^2} e^-\frac{x^2+y^2} {2\sigma^2}\end{gather}像山峰一样的分布&emsp;(1)高斯平滑的作用是模糊图像&emsp;(2)平滑的强度被定义为高斯的标准方差$\sigma$($\sigma$越大，对图像的平滑越厉害，图像变得越模糊)&emsp;(3)输出了一个对高斯分布覆盖的点进行平均，但中间的点给更多的权重(加权平均)&emsp;(4)把高斯核的9个数加起来应接近于1(100%),中间的点应该有更高的百分比(相当于山峰)&emsp;(5)把高斯核于图像做卷积实际上就是一种加权平均2.中值滤波每个像素的灰度替换为其邻近点平均(卷积核越大，平滑的越厉害)缺点(1)没有保持图像原有的属性(2)卷积计算量很大median filter:对9个值进行排序找到其中的中位数替换原图像像素的灰度值(效果不如卷积，但计算速度快) 2,3图像的基本操作点操作输出像素点的灰度值仅取决于对应输入图像的灰度值特点:点到点的拷贝,只有灰度值通过转换方程被改变了转换方程:\begin{gather}B(x,y) =f[A(x,y)]\end{gather}(1)线性点操作\begin{gather}D_B=f(D_A)=aD_A+b\end{gather}输入图像:$D_A$a:对比度(contrast)调节参数b:平移项(对应于灰度值)a&gt;1:对比度增加a=0 &amp; b!=0：对灰度值空间进行平移(调节明暗)a&lt;0:反转对比度(2)非线性例:nonolinear monotonic(单调的) 点操作\begin{gather}f(x)=x=C_x(D_m-x)\end{gather}x:输入图像灰度值$D_m$:最大灰度值$C_x$:决定灰度空间的放大和缩小x趋于中间值变化明显(0–255间),两侧灰度值变化不明显应用:&emsp;(1)Photometrice Calibration(光度校准):摄像/照相参数是否合适&emsp;(2)对比度增强&emsp;(3)二值化(也是点操作，大于threshold为1，小于为0)&emsp;(4)边缘线(把边缘标的很亮)&emsp;(5)clippling(切出一个区) 代数操作(Algebraic Operation)产生输出图像通过对两个或者更多图像点对点(pixel-to-pixel)的加减乘除注意(1)图像的大小一定要相同(2)如果两个图像其中一个是参数,则就变成了点操作(一个特例)定义:\begin{gather}C(x,y)=A(x,y)+B(x,y)\end{gather}\begin{gather}C(x,y)=A(x,y)-B(x,y)\end{gather}\begin{gather}C(x,y)=A(x,y)\times B(x,y)\end{gather}\begin{gather}C(x,y)=A(x,y) \div B(x,y)\end{gather}(1)加法&emsp;(1)可用来通过平均的方式进行除噪(例 连续拍0张照片加起来求平均，可得到清晰的的图像，因为噪声是随机存在的，求平均可减弱噪声)&emsp;(2)多次曝光(double-exposure effect)同一个演员出现在图像两侧(也是多次拍摄)(2)减法&emsp;(1)把背景去除(背景固定，前景人在活动)&emsp;(2)检测运动(瞬间拍多张照片，求帧和帧间的减法，可以看到物体运动的趋势)&emsp;(3)梯度计算(单位时间做减法)(3)乘法&emsp;图像二值化后，分出一个区域和原图做乘法,0的区域变成0,1的区域还原原图像灰度值，所以可以去除感兴趣区域的灰度信息 几何操作(Geomtric Operation)改变空间坐标关系；将图像内某一区域在图像内移动两部分工作(1)空间转换(2)灰度值插值(interpolation)进行几何操作后产生空缺位置,需要插值来补齐(1)空间转换假设转换前后坐标为$(x,y)$和 $(x’,y’)$平移 \begin{gather}\begin{bmatrix} x’ \ y’\end{bmatrix} =\begin{bmatrix} x \ y\end{bmatrix} +\begin{bmatrix} \bigtriangleup x \ \bigtriangleup y\end{bmatrix}\end{gather} 旋转 \begin{gather}\begin{bmatrix} x’ \ y’\end{bmatrix} =\begin{bmatrix} cos \alpha &amp; sin \alpha\ -sin \alpha &amp; cos \alpha\end{bmatrix}\begin{bmatrix} \bigtriangleup x \ \bigtriangleup y\end{bmatrix}\end{gather} 缩放 \begin{gather}\begin{bmatrix} x’ \ y’\end{bmatrix} =k\begin{bmatrix} x \ y\end{bmatrix}\end{gather} 注意:(1)平移后放大和放大后平移是不同的(2)旋转后放大和放大后旋转是完全相同的(2)插值算法i.最近邻插值(nearest neighbor)找最近灰度值拷贝过来,容易产生梯田效应ii.双线性插值Bilinear Interpolation(square interpolation)被插值点和其周围点形成正方形，根据距离给不同点权重，计算加权平均即为插值结果iii.多项式插值(B-sqline样条 polynomial多项式) 图像的领域操作(beighbourhood operation)图像内一点与其周围点的相关性对于某一像素点，其连接关系有&emsp;(1)4邻域$$N_4(P)={(x+1,y),(x-1,y),(x,y+1),(x,y-1)}$$&emsp;(2)8邻域$$N_8(P)=N_4(p) \bigcup{(x+1,y),(x-1,y),(x,y+1),(x,y-1)}$$4(8)连接:两点在$N_4(p)$ ($N_8(p)$)范围内经典算法:connected component labeling(联通区域标记)&emsp;(1)根据要素间的连接性来进行标签操作&emsp;(2)把具有共同属性的像素分到一个组里，用相同灰度/颜色进行打标签操作&emsp;(3)分组的依据仅为连接关系(4(8)连接)和灰度条件(相邻的点灰度值要接近)&emsp;(4)具体实施:从上到下，从左到右对图像进行遍历&emsp;(5)Intensity Criterion强度准则(IC):相同Intensity Value的集合(对于二值图像，灰度值必须一致，比如都是1;对于灰度图像，灰度值在一定范围内则分到一组)Two-Pass法 参考1 参考2对于满足IC的像素点Step1(第一次遍历)&emsp;(1)如果所有的近邻都不满足IC，给P一个新标签&emsp;(2)只有一个近邻满足IC，把它的标签给P(灰度值距离P最近的点)&emsp;(3)如果一个或多个近邻都满足IC(灰度值距离P最近的点有多个)，选这些标签中的一个给P，并做一个标志(equivalence)表示和这些标签都有一定的可能性(如两个区域的边界处)Step2 解决equivalence问题&emsp;equivalence resolve algorthm(如Floyd-Warshall algorithm):处理equivalence标签对，并给它一个特定的标签(宏观地看这些点)–找到属于同一区域的最小标签 图像的特征Region property(区域特征):&emsp;在区域被标签或分割后,区域特征是区域分割的重要属性区域属性:(1)周长(primeter)和面积周长的估计方法&emsp;i.把所有边缘上的像素点数一遍，数目就是周长&emsp;ii.更精确的估算(chain-code)把一个点的8邻域按逆时针从0-7标出来，在目标区域中，相邻像素根据不同的标号关系计算距离面积的估计方法:$$Pick’s formula:A(p)=n_I+n_B/2-1$$ $n_I$代表整个像素点都在区域内的像素数 $n_B$代表像素点在区域边缘上的像素数(2)极值点(extreme points)某一区域的x,y最小,大值bonding box:把区域用矩形圈起来，相切的点称为极值点(3)中心点,半径(radius)，直径(diameter)离心(eccentricity):点P的离心值为到边缘线上所有点距离最大的值$$ecc(P)=max \; d(p,q)|q \in F$$q:边缘上的所有点p:当前要计数的点中心点:拥有最小离心值的点P的集合半径:最小离心值$d(p,p’)$直径:最大离心值$d(p’,q’)$(4)中心距(centroid moment)中心:给定图像F，图像上像素集合为$(x_i,y_i)$，则中心为 $$ x_c=\frac{1}{n} \sum_{i=1}^{n}x_i$$ $$ y_c=\frac{1}{n} \sum_{i=1}^{n}y_i$$ 离散(k,l)阶中心距被定义为: $$ \mu_{k,l}= \frac{1}{n}(x_i-x_c)^k(y_i-y_c)^l$$(5)图像的朝向 $$\theta=\frac{1}{2} arctan(\frac{2\mu_{1,1}}{\mu_{2,0}-\mu_{0,2}}) $$以上公式代表着图像的偏转角度,因此可以用来进行图像矫正 3.1数学形态学:二值的形态学数学形态学:针对空间结构的定量分析的一个方法论(a methodology for the quantitative analysis of spatial structure)应用:图像增强，图像分割等结构化要素(structure element(SE)):也叫做核，但保留该概念用于卷积&emsp;中心点(origin):画圆圈的位置&emsp;空格:不做计算的位置平移(Geometric shift)集合A平移距离x，被定义为: $$ A+x={a+x:a\in A}$$ 基本运算1.膨胀(binary dilation)二值化膨胀:图像F被SE k膨胀定义为: $$D(F,K)=F \oplus k= \bigcup_{b\in k} ({a+b|a\in F})$$ 这里的加实际上是或操作,膨胀操作实际上是以SE为半径向周围扩展了一圈例 \begin{gather}\begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 \ 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0\end{bmatrix} \oplus\begin{bmatrix} 1 &amp; 0 \ 1 &amp; ①\end{bmatrix} =\begin{bmatrix} 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 \ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0\end{bmatrix}\end{gather} 将origin和原图中的各点对齐，然后进行相加操作，最后将这些集合并起来归纳:将origin击中图像上所有1的位置，盖章(只考虑前景)运算律(1)交换律: $D(A,B)=A\oplus B=B \oplus A=D(A,B) $(2)结合律: $A \oplus (B \oplus C)=(A \oplus B)\oplus C$(3)转换的不变性: $A \oplus(B+x)=(A \oplus B) +x$(4)递增 $A_1 \subseteq A_2 \Rightarrow (A_1 \oplus B)\subseteq (A_2 \oplus B)$(5)分解率 $A \oplus (B \cup C) = (A \oplus B)\cup (A \oplus C)$(6)多次膨胀 $nB=\underbrace{(B \oplus B \oplus … \oplus B)}_{\text{n}} $2.收缩/腐蚀(erision)F被SE k腐蚀定义为 $$F(F,k)=F\ominus k= \bigcap_{b\in k} ({a-b|a\in F})$$ 注意:F和k都只考虑1的部分,减法实际上为与运算 \begin{gather}\begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 \ 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0\end{bmatrix} \ominus\begin{bmatrix} 1 &amp; 0 \ 1 &amp; ①\end{bmatrix} =\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0\end{bmatrix}\end{gather} 归纳:SE的origin摁在图像上所有1的位置,若图像上该点周围与SE完美匹配(与运算结果为1),则该点保留运算律(1)不可交换: $ E(A,B)\ne E(B,A)$(2)不可逆: $D(E(A,B),B)\ne A \ne E(D(A,B),B)$ 膨胀和腐蚀是不可逆的(3)转换的不变性: $A \ominus(B+x)=(A \ominus B) +x$(4)$A_1 \subseteq A_2 \Rightarrow (A_1 \ominus B)\subseteq (A_2 \ominus B) $(5)$B_1 \subseteq B_2 \Rightarrow (A \ominus B_1)\supseteq (A \ominus B_1) $(6)分解率 $A \ominus (B \cup C) = (A \ominus B)\cap (A \ominus C)$ $(A \ominus B)\ominus C=A \ominus(B \oplus C)$拆分成两个更小的SE会大幅提升效率例:$A \ominus 2B=A \ominus B \ominus B$ 2B为半径为2的圆注意:腐蚀和膨胀并不可逆二者相关性为: $$A \oplus B= [A^c \ominus (-B)]^c $$ $$A \ominus B= [A^c \oplus (-B)]^c$$ 其中$A_c$代表对A取反,$-B$代表对B旋转$180^\circ$3.开运算(Binary Opening) $$O(F,k)=F \circ k= (F \ominus k) \oplus k $$ 实际上是对图像孤立，狭小的区域进行除噪例 \begin{gather}\begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 \ 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0\end{bmatrix} \circ\begin{bmatrix} 1 &amp; 0 \ 1 &amp; ①\end{bmatrix} =\begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0\end{bmatrix}\end{gather}F中不满足匹配k的区域会被抹掉，因为进行了腐蚀操作后边0的区域不再考虑，它附近必须有1才能恢复归纳:所有比SE小的区域会被抹掉运算律:(1)交换律: $O(A+x,B)=O(A,B)+x$(2)$O(A,B) \subseteq A$ 图像开运算后一定变小(3)单调递增 $A_1 \subseteq A_2 \Rightarrow (A_1 \circ B)\subseteq (A_2 \circ B)$(4)不可重复性:$( A \circ B )\circ B =A \circ B$4.闭运算(binary closing) $$ C(F,k)=F \bullet k= (F \oplus k)\ominus k $$ 对图像进行填充，填充比SE小的空洞 \begin{gather}\begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 \ 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0\end{bmatrix} \bullet\begin{bmatrix} 1 &amp; 0 \ 1 &amp; ①\end{bmatrix} =\begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \ 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0\end{bmatrix}\end{gather} 运算律:(1)交换律: $C(A+x,B)=C(A,B)+x$(2)$A \subseteq C(A,B) $图像闭运算后一定变小(3)单调递增 $A_1 \subseteq A_2 \Rightarrow (A_1 \bullet B)\subseteq (A_2 \bullet B)$(4)不可重复性:$( A \bullet B )\bullet B =A \bullet B $ 开闭运算是一对对偶操作(dual operation),不是逆操作 $$ A \circ B= (A^c \bullet B)^c $$ $$ A \bullet B= (A^c \circ B)^c $$ 膨胀:整个区域扩张;闭操作:只有填埋,保留原有特征腐蚀:整个区域收缩;开操作:只有去噪,保留原有特征 算法 Hit-and-Miss $$F \otimes k=(F \ominus k_1) \cap (F^c \ominus k_2)^c $$ 其中 $k_1 \cap k_2=\oslash，k_1 \in k ,k_2 \in k$对前景用$k_1$腐蚀，对背景用$k_2$腐蚀再取反可用来求取特征，前景上提取，背景上抑制(前景fit,背景miss)Particular Patterns(特征点):(1)孤立点(2)顶点(3)边缘点理解:对前景特征进行抓取，对背景特征进行丢失算法步骤:&emsp;(1)以origin为中心对SE和图像进行叠加&emsp;(2)查看SE和它压在下面的图像&emsp;&emsp; i.如果前景(背景)的SE和前景(背景)的图像完全匹配,那么在origin下面的像素被设置为前景的颜色&emsp;&emsp; ii.如果不匹配，被设置为背景的颜色 2.模式谱(Pattern Spectrum)用于测量目标体在不同尺寸物体的分布的描述$F$:处理的图像;$r_ik$:SE的尺寸模式谱被定义为: $$ PS_{r_ik}(F)=\begin{cases} Card((F \circ r_ik)-(F \circ r_{i+1}k)) \qquad &amp; i \ge 0 \ Card((F\bullet r_{-i}k)-(F\bullet r_{-i-1}k)) \qquad &amp; i \lt 0 \end{cases} $$ $Card(F)$代表cardinality计数(对于二值图像将差值图像的目标像素数计数;灰度图像,对灰度值求和)开运算:提取出大小在小于$r_ik$ 到$r_{i+1}k$的部分闭运算:填埋(从另一种角度) 步骤&emsp;(1)用一合适的SE对图像进行开操作&emsp;(2)把它和原图做减法,得到的差值图像为$DST_n$(第n个diatance size transformation 距离尺度转换)&emsp;(3)对于二值图像将差值图像的目标像素数计数;灰度图像,对灰度值求和&emsp;(4)将所得数放在模式谱里(第n个棒，n从0开始)&emsp;(5)重复上述操作直到所有object都消失(将n增大,n代表SE的尺度)举例,用一个圆形SE，不断增加其半径 应用(1)检测图像成分大小(2)检测目标的形状 3.循环膨胀(Recursive Dilation) $$ F \stackrel{i}{\oplus}k =\begin{cases} F \qquad &amp; i=0 \ (F \stackrel{i-1}{\oplus}k)\oplus k \qquad &amp; i \ge 0 \end{cases} $$应用于构成一系列有相同形状，但大小不同的图像不同数字的模式谱 4.循环腐蚀(erosion)$$ F \stackrel{i}{\ominus}k =\begin{cases} F \qquad &amp; i=0 \ (F \stackrel{i-1}{\ominus}k) \ominus k \qquad &amp; i \ge 0 \end{cases} $$可逐渐将图像的object缩小,可应用于计算distance transform 5.距离转换(distance transform)仅用于二值图像转换得到一个灰度图像,灰度值表明像素点到最近边缘的距离(反复腐蚀得到)距离表达:(1)Euclidean distance $$D_{Euclidict}=[(x_2-x_1)^2+(y_2-y_1)^2]^\frac{1}{2}$$ (2)City Block Diatance($N_8$八领域) $$ D_{city}=|x_2-x_1|+|y_2-y_1|$$ (3)Chessboard Distance($N_4$) $$ D_{chess}=max(|x_2-x_1|,|y_2-y_1|)$$ $(x_1,y_1),(x_2,y_2)$代表腐蚀前后点的坐标6.Sekleton(骨骼)去除二值图像中的前景区域，仅保留原始区域的拓扑(extent and connectivity)例1:长方形4个角上放4个圆，其半径越来越大，圆心的轨迹就是Skeleton,圆的边和长方形的两个边相切，表明Skeleton上的点是由距离边缘最远的点组成的 Skeleton subset $S_i(F)$,i-SE尺寸 $$ S_i(F)=(F \ominus r_ik)-[(F \ominus r_ik) \circ k] $$ i=0,1,2,3…n 当i取n，$S_i(F)$变为空$(F \ominus r_ik) \circ k$去除了长方形的角，再用$F \ominus r_ik$减即可得到长方形四个角Skeleton为: $$ S(F)=\bigcup_{i=0}^{n} S_i(F) $$ 7.骨骼恢复(skeleton reconstruction)原图可以通过下式恢复: $$S(F)=\bigcup_{i=0}^{n} (S_i(F) \oplus r_iF) $$ 其中$r_iF为之前使用过的SE$例经过distance transform得到灰度图像,其中的skeleton点都是局部最大值(8领域中最大值)恢复:用skeleton点(该点灰度为几就用对应大小的SE) 3.2灰度的形态学灰度图可用3D立体表示(landscape),灰度越大，高度越高 灰度膨胀(dailation)给定图像F(m,n),被SE&ensp;k膨胀被定义为 $$ D_G(F,k)=F \oplus_g k=max_{[a,b] \in k}{[F(m+a,n+b)+k(a,b)]} $$总体上使源图像变亮比如k是$N_8$,有9个点，找到9个点中使$F(m+a,n+b)+k(a,b)$最大的值即为(m,n)点膨胀的结果可理解为SE在原图上方划过所留下的轨迹就是膨胀的结果(1)白区变大,黑区变小(2)SE越大,效果越明显(3)小黑点会消失，小白点会变大(4)在平坦区域几乎没变化,但在边界区会剧烈变化 灰度腐蚀(erosion)$$ E_G=F \ominus_g k =min_{[a,b]\in k}{[F(m-a,n-b)-k(a,b)]} $$总体上使图像变暗注意有星号要选星号，代表该点不存在了 3.3受限制的膨胀算法(conditional dilation)对要处理的空间进行重建(比如除噪后，破坏了的目标区需要恢复)令M，V为两张二值图像,且$M \subseteq V$，M(marker种子点),V(mask模板)受约束的膨胀定义为: $$ R_i(M,V)=(M\stackrel{i}{\oplus}IV) \quad until \quad R_i(M,V)=R_{i-1}(M,V)$$ $I$代表图像间的交集运算注意:M只允许在V的范围内增长Morphological Reconstruction1.binary reconstruction过程(V是原图,k是SE)&emsp;(1)$M=V \circ k$除噪&emsp;(2)$T=M$&emsp;(3)$M=M\oplus k_i$&emsp;(4)$M=M\cup V$(仅取出属于V也属于M的像素点)&emsp;(5)如果$M \ne T$回到(2)&emsp;(6)结束注意&emsp;(1)SE要足够小,避免跨到其它区&emsp;(2)尽量避免噪声和目标区有连接2.grey reconstructionStep1:在marker上进行灰度膨胀Step2:检查膨胀结果的每个点是否超出mask f的范围Step3:重复1,2直到稳定应用1.opening by reconstruction(OBR)(1)用open操作对图像进行平滑(2)通过重建恢复目标区域2.closing by reconstruction(CBR)先closing再reconstruction 3.4分水岭算法(watershed)1.测地距离(geodesic distance)两点之间不能通过直线到达(Euclidean distance),只能通过折线到达定义:$F_a$为一连接区域，x,y两点间的测地距离$d_{F_a}(x,y)$为x,y两点间最短可执行路径P的长度,路径一定要在$F_a$内 $$d_{F_a}(x,y)=\wedge{l(P)}$$ $\wedge$代表infimum最小值,l(P)代表路径P的长度2.Geometric Influence Zone(IZ)假设区域A包括子集B_1,B_2,…,B_k$则$i_{Z_A}(B_i)$被定义为: $$i_{Z_A}(B_i)={P \in A,\forall j \in [1,k]/{i},d_A(P,B_i)&lt;d_A(P,B_j)} $$ 这里$\forall j \in [1,k]/{i}$表明从[1,k]区间中去除i的部分,也就是$j \ne i$ 如果有3个种子点$B_1,B_2,B_3$，那么根据A中每个点到$B_1,B_2,B_3$的测地距离，离谁最近就属于那个区域注:如果某点到多区域距离最小且相等,这些点组成Skeleton by influence Zone(SKIZ),A中B的SKIZ为 $SKIZ_A(B)$，定义为: $$SKIZ_A(B)=A/IZ_A(B)\quad with IZ_A(B)= \bigcup_{i\in [1,k]} iz_A(B_i) $$ $A/B$意味着A中出去B的部分($B \subset A$)3.分水岭算法高度代表灰度值 Catchment Basin脸盆把二值化值看为水位线，水位线过高就要修坝(dam)形成大坝的线即为分水岭/分区点,以实现对图像的分割算法为(1)根据图像各店灰度值对其进行排序(2)找到最小值(start point)醉卧初始化二值化值threshold level(3)以1位步长提高threshold&emsp;i.如果通过计算测地距离找到其它局部最小值,将其加入最小值列表(minimum list)，用其他现存最小点计算SKIZ&emsp;ii.否则在现存最小值列表计算SKIZ(4)重复直到所有点都被算入脸盆或threshold超过最大值图像中有大量minima解决方法(1)对图像进行平滑操作(如高斯平滑)去掉小的最小值(2)从相对较高的threshold开始(3)用其他办法把小的分区组合(merge) 4.1彩色图像1.彩色图像处理-color vision:模仿人的视觉系统三原色:R,G,B three channel彩色图像一般存储为:R,G,B,$\alpha$–透明度(一般不用)Tricolor image(三原色图像)Tricolor system:由三个灰度图像组成,也可以看成三个灰白数字图像叠加(monochrom digital images)RGB形式(format) Magnta-紫;Cran-青HIS形式:Intensity(I)–整体亮度;Hue(H):色度,极坐标中的极角;Saturation(S)饱和度,极坐标中的极轴长度颜色坐标转换:1.RGB to HISI可用圆柱高度表示建立(x,y,z)直角坐标系,旋转RGB方块使Z轴和其对角线重合,而其R(Red)轴在xz平面上则有: $$x=\frac{1}{\sqrt{6}}[2R-B-G]$$ $$y=\frac{1}{\sqrt{2}}[G-B]$$ $$z=\frac{1}{\sqrt{3}}[R+B+G]$$ $$\rho=\sqrt{x^2+y^2}$$ $$\phi=ang(x,y)$$ 这里圆柱坐标系(cylinderical coordinate)$(\phi.\rho,z)$对应着$(H,S,I)$这样转出来是六边形而不是圆形要对S进行正规化(normalization) 2.HIS TO RGB 彩色图像的增强问题:out of balance(失衡)方法:通常选R,G,B中两个通道进行线性灰度转换来匹配剩余的那个通道过程:(1)找到相对均匀的亮的区域和暗的区域(2)在三通道中分别计算这些区域的灰度均值(3)利用线性对比度调节(linear contrast stretch)对其中两个通道进行调节使其与第三个匹配对比度和颜色增强:(1)饱和度增强(saturation)&emsp;i.为使图像颜色更加饱和(bold),将饱和度乘以一个大于一的数&emsp;ii.减低饱和度,将饱和度乘以一个小于一的数(2)色度调整(hue alteration)微调:加一个很小值到色度,使其色调变暖或冷若加一个很大数会改变图像的表达方式彩色图像恢复(restoration):(1)利用线性点操作确保在RGB形式下灰度和颜色平衡(2)转换到HIS形式(更适用于视觉调整)(3)使用中值滤波(median filter)对色度和饱和度处理,以除掉噪声(4)使用线性滤波(如卷积)是边缘锐化,增强细节,重建密度(5)利用线性点操作对参数进行灰度上的调整(6)转换成RGB形式2.维彩(Pseudocolor)将黑白图像(monochrome)通过每个灰度值在彩色空间的映射转化为彩色图像实现方式:lookup table彩色补偿(color compensation)color spread(颜色分布):彩图传感器对光谱的敏感性宽且有叠加,所以很难在三个通道中的一个通道吧物体完整独一出来方法:线性转换矩阵C代表图像在三个通道中的颜色分布($c_{ij})$点j在i通道的亮度百分比x:1x3的矩阵代表某个像素点的真实亮度(三个channel) $$ Y=Cx+b$$ $$ x=C^{-1}[y-b] $$b代表灰度偏移值，y代表所期待的状态如果已知y，可求出x和y的相关性令E为曝光时间, $$ Y=ECx+b$$ $$ x=E^{-1}C^{-1}[y-b] $$ $E^{-1}C^{-1}$；调整颜色补偿矩阵,调整曝光时间可调节对图像的补偿彩色图像分割:(1)在RGB/HIS空间内，通常不同物体在3D灰度直方图的不同簇内(2)阈值被观察角度和照明严重影响(3)白噪声在RGB三个通道内表达方式一样，很难将其从三个通道中分开(4)在某个通道内某个区域可能非常明显,很容易被分割出来彩色图像测量/表达:尺寸,形式,平均色度,平均饱和度,平均密度 4.2三维图像(3D image)由来:三维:空间上的三维二维图像是三维图像投影得到的Optical Sectioning(光学断层成像):serial sectioning：把人体切片来产生一系列切片以理解人的三维结构缺点(1)切片间的相关性难以把握(2)难免损坏切片X光(X-ray):人体的不同结构对x光的吸收不同Tomography(立体成像术)多次曝光,每次曝光旋转传感器和光线发射源，就可以采集到人体不同角度的投影信息CT:computerized axial tomography(CAT)–计算机立体成像人体从上到下地断层扫描的三维结构三维图像的处理1.Stereometry(立体成像术)Steroscopic image pair(立体成像的一对图像):描述左右眼两个不同视角所获得的图像(1)将两摄像机按人眼位置摆放,对自然场景进行采集 $$R=\frac{d\sqrt{f^2+x_l^2+y_l^2}}{x_r-x_l}$$ (2)Stereo Matching(将两图像匹配)将两图像的坐标关系一一对应方法:在图像上放置虚拟窗口(subpixel accuracy/sub window)两个Sub-windows间找到两图像的对应关系处理过程(1)匹配两个sub-window,设置两个窗口的位置(2)计算两个窗口间的一致性(cross-correlation，平方差求和)(3)在一个图像固定窗口,另一个图像移动窗口,过程中求取一致性,当达到最大且满足期待时,则这两个窗口匹配，认为这两幅图匹配展示(Steroscopic Image Display)比如3D电影shaded Surface Display:阴影表面展示对存在数字描述的3D物体进行图像生成要求(1)表面的空间描述(2)表面的光照反射现象(3)光源的几何形状和成像过程 b,n代表反射参数和物体材质相关A:进行反射的比例系数r:光到表面的距离0&lt;B&lt;1 第五章 图像分割和形状轮廓模型5.1 图像的能量表达1.手工分割(manual)2.全自动(fully automatic)3.先自动分割,再人工修正4.先人工大体勾画,再用算法分割&emsp;(1)比1和3更快&emsp;(2)比1和3可重复性强(reproducible)&emsp;(3)比2更容易应用到各种各样的图像中基因能量模型(deformable model)可形变边缘线/面(deformable contours/surfaces):通过图像内部的立场的分析以实现分割的效果基于上述方法4,先人工分割,勾画出大体轮廓,轮廓自动形变达到想要的边界一种可形变的边缘线:离散动态边缘线(DDC discrete dynamic contour)一系列由直线连接撑的有序号的点(1–N)(1)任意一点可由下式表示 $$\vec P_i(t)=(x_i(t),y_i(t)) $$ (2)每个顶点的合力表示为: $$\vec {f_i^{tot}}(t)=w^{im} \vec {f_i^{im}} + w^{in} \vec {f_i^{in}} +\vec {f_i^{d}} $$ $\vec {f_i^{im}}$:图像的力，驱使图像向着决定边缘位置的feature靠近$\vec {f_i^{in}}$:内部约束力(internal force)避免个别点跳太快使所有点均匀向外膨胀(smooth)$\vec {f_i^{d}}$:阻尼力(damping force)使边缘形变很稳定,避免顶点位置震荡$w^{im}$，$w^{in}$:权重,一般在[0,1]范围内(3)合力作用在顶点i上在时刻t产生加速度 $$ \vec {a_i}(t)=\frac{1}{m} \vec {f_i^{tot}}(t)$$ m为每个点的质量,通常m=1(4)下一时刻的速度 $$ \vec {V_i}(t+\Delta t)=\vec {V_i}(t)+\vec a_i(t) \Delta t$$ 下一时刻位置: $$ \vec {P_i}(t+\Delta t)=\vec {P_i(t)}+\vec {V_i(t)} \Delta t$$ 整体算法:&emsp;(1)显示图像&emsp;(2)令用户初试轮廓(contour)每个点的速度和加速度为0&emsp;(3)计算每个点的合力&emsp;(4)计算加速度&emsp;(5)更新每个点的位置和速度&emsp;(6)对DDC进行重采样(re-sample)&emsp;(7)重复3-6直到$$\begin{Vmatrix}\vec V_i(t)\end{Vmatrix} &lt;\epsilon_1$$ $$\begin{Vmatrix}\vec a_i(t)\end{Vmatrix} &lt;\epsilon_2$$ Total force:(1)iamge force $\vec {f_i^{im}}$把图像灰度值看成山峰,灰度高,势能高,动能低;灰度低,势能低，动能高由能量(energy)可导出: $$ \vec {f_i^{im}}=- \vec {\nabla} E(x,y)$$Image force促使每个点向能量场中最近局部最小值(local minima梯度最小处)的运动E的定义决定了每个顶点能否向期望的图像特征运动如，为了使顶点到达最大梯度值,可定义能量为: $$ E(x_i,y_i)=\frac{1}{\begin{Vmatrix}\vec {\nabla}G_{\sigma} * I\end{Vmatrix}+\epsilon}$$ $\begin{Vmatrix}\vec {\nabla}G_(\sigma) * I\end{Vmatrix}$高斯平滑再求导再取模，为避免其为0,再加一个小常数$\epsilon$对图像进行高斯平滑和减少图像有过多局域最小值选取能量的形式取决于想获得那种特征(step edges,line elements)如对于线元素(line elements) $$ E(x_i,y_i)=\frac {1}{G_{\theta}*I+\epsilon} $$ (2)Intenal forces $\vec {f_i^{in}}$使轮廓边缘平滑(smooth)(图像的噪声可使DDC产生冒尖的区域(jagged)) $$\vec {f_i^{in}} (t)=\vec c_i(t)$$ 其中$\vec {c_i}(t)=\hat{d}i(t)-\hat{d}{i-1}(t)$ $\hat{d}_i(t)$是连接顶点i和顶点i+1的单位边向量 (3) 阻尼力(Damping force) $\vec {f_i^{d}}$使轮廓的动态行为稳定(防止震荡)DDC可能在两个局部最小点间震荡(viscous damping粘性阻尼) $\vec {f_i^{d}}(t)=w^d \vec {V_i}(t)$ 要求$-1&lt;w^d&lt;0$(4)resampling在顶点受力运动之后,DDC一些区域可能顶点密集,而一些区域顶点稀疏,因此进行重采样,密集的地方删除一些点，稀疏的地方增加一些点，加快运算，节省存储方法:线性插值,使DDC在空间上平均 5.3能量方程的变量选取总结(1)利用可变形模型如DDC可自动形成目标的边界(2)最初人工画边界要尽量接近目标边界(3)参数选择&emsp;i.$w^{im}&gt;w^{in}$如果噪声不是特别强&emsp;ii.$\Delta$决定了DDC如何跟随曲线&emsp;iii.$\sigma$应该尽量小为使局部边界准确 5.4图像分割:水平集算法(Level Set Algorithm)分割:从背景中分离目标,用一个模型，其边界形状与ROI边界匹配raw data:原始数据分割技术(1)基于边界的(boundary-driven)边缘检测(无模型model-free)active contours/snake(model-free knowledge-based)active shape models(基于先验知识)(2)基于区域的(region-driven)可形变模型deformable template(knowledged-based)统计学的/聚类技术(model-free statistical clustering) (knowledge-based)(3)基于边缘+区域属性active contours水平集算法(model-free knowledge-based)水平集:在同一水平面(高度)上的点水平集方法是一种front propagation theory(前向传播理论)SNAKE如何工作(1)在图像上初始化边缘点(2)数字化边缘点(3)在内外力作用下,移动边缘点问题(1)对初始轮廓要求点(2)无法分割复杂区域(3)对多目标分割没有办法前向传播:对snake的另一种解释过程:一个封闭的接口在平面内移动；更广泛的，一个front从初始边缘沿着法向量(normal vector)以速度F到达目标边界在front中的两种表达方式(1)基于参数的(2)水平集(level set representation)前向表达(front representation)Level Set:增加一维来表达曲面(原来的参数化二维方程,难以表达复杂平面)Front:zero level set从active contour到level set的转换(1)contour–front(2)contour energy–force(3)image energy–speed function零水平集 $$ \frac{\partial \phi}{\partial t}=F[\nabla \phi] $$ (为避免复杂的3D contour,要求当前求取平面为0高度)动态坐标系统 $O_{xy}$t=0:当前所关注区的现实状态,通过函数曲面可计算出下一时刻的状态Level Set Method:解决偏微分方程(Partial Differential Equation(PDE)):其中接口为0水平集(被初始contour所约束)通常，$\phi$为front $\gamma(0)$的有符号距离 $$ \phi(x,y,0)=\begin{cases} -d(x,y,\gamma) \qquad &amp; front内 \ 0 \qquad &amp; front上\ d(x,y,\gamma)\qquad &amp; front外 \end{cases} $$上图截面为零水平集的状态分割方法(1)初始化front $\gamma(0)$(2)计算$ \phi(x,y,0)$(3)迭代$ \phi(x,y,t+1)=\phi(x,y,t)+\Delta \phi(x,y,t)$直到收敛(convergence)(4)标记front $\gamma(tend)$法向量速度$F=F(L,G,I)$L:Local properties如曲率,法线方向G:Global properties由front的PDE求出来的I:Independent Properties如流速$R(x,y)=2I(x,y)-1$实现方式(1)计算在front上的速度$k_1$,延伸到所有其他水平集(2)计算$ \phi(x,y,t+1)=\phi(x,y,t)+\Delta \phi(x,y,t)$(3)找到下一次迭代front的位置,通过线性插值修改$ \phi(x,y,t+1)$停止front迭代的条件为使front在边缘上停止,要定义一个速度作为停止标准(g小于某一值时停止迭代)$g_i(x_{i,j})$ $x_{i,j}$为(i,j)点的梯度扩展速度方程extension的要求:level set移动时点和点不能碰撞Fast Marching(提高效率)(1)假设F不变号,那么contour只能扩展(F&gt;0)或收缩(F&lt;0)保证问题稳定,contour只能通过每个像素点至多一次(2)为避免错过边缘要减少时间步长，迭代次数增加(3)大幅提高运算过程的速度(从种子结构到目标边界)(4)方法:开始时使用Fst marching,快到目标时使用level set(更为精确)扩展速度方程(active pixels-曲面已到达的点;alive pixels:曲面接下来要到达的点;far away pixels:曲面接触不到的点)Fast Marching method(1)计算$T(x,y)$:由contour到达(x,y)的时间(2)在某一高度t的表面给出t时刻到达点的集合 OPENCV使用安装与配置VS2017配置opencv教程（超详细！！！） 参考需要注意的一点是在配置完成之后要用visual studio重新建立一个项目(空项目或者控制台项目均可),才能正常使用opencv]]></content>
      <categories>
        <category>digital image processing</category>
      </categories>
      <tags>
        <tag>-digital image processing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux学习]]></title>
    <url>%2Fvampire1996.github.io%2F2019%2F03%2F29%2FlinuxLearning%2F</url>
    <content type="text"><![CDATA[修改下载源文件sources.list注意要以root用户打开文件 参考镜像源文件(注意要根据ubuntu系统选择源,我现在的版本是18.04) 清华大学开源软件镜像站 vim命令i-insert 进入插入模式(可编辑)，按esc退出，进入普通模式复制粘贴(在普通模式下)123yy 复制一行 dd 删除一行 p 在当前行后粘贴之前复系统 win10创建linux子系统参考注意源要和ubuntu系统适配 安装linux双系统UEFI模式下安装，要根据U盘制作的类型选择是legacy还是UEFI参考解决开机黑屏参考解决重复登录问题参考ubuntu进入emergency mode解决参考双系统Ubuntu无法访问Windows磁盘分区解决方法参考 linux常用命令查看磁盘信息1fdisk -l 查找占用GPU资源的PID1sudo fuser -v /dev/nvidia* 杀死进程1kill -9 pid #pid为对应进程号 在终端下：复制命令：1Ctrl + Shift + C 组合键 粘贴命令1Ctrl + Shift + V 组合键. 解决linux系统无法打开windows硬盘问题1sudo ntfsfix /dev/sdb5(指定硬盘，错误中可以看到） 更改文件名(将file1改名为file2)1mv file1 file2 查看当前目录信息1pwd 文件复制命令cp1cp [-adfilprsu] 源文件(source) 目标文件(destination) 如将/test1目录下的file1复制到/test3目录，并将文件名改为file2,可输入以下命令：1cp /test1/file1 /test3/file2 创建文件夹1mkdir filename 解压zip文件到当前目录1unzip wwwroot.zip 删除文件夹(将会删除/var/log/httpd/access目录以及其下所有文件、文件夹)1rm -rf /var/log/httpd/access 查看某文件夹下文件的个数1ls -l |grep &quot;^-&quot;|wc -l linux使用在关机时一定要把文件先保存好关闭后在关机]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>-linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机视觉与深度学习]]></title>
    <url>%2Fvampire1996.github.io%2F2019%2F03%2F29%2FCVAndDeeplearning%2F</url>
    <content type="text"><![CDATA[软件安装Ubuntu16.04下安装PyTorch 参考解决pytorch安装问题参考 参考2 注意在网上搜索清华镜像,把上面网站都试一试Ubuntu16.04下安装PyTorch 参考安装完Anaconda python3.7，想使用python3.6方法 参考 用source activate py36 进入python3.6环境之后，可以通过conda list来查看包的位置，这样就可以在pycharm中找到包的位置 pycharm使用解决Pycharm无法导入包问题 Unresolved reference 参考pycharm同一目录下无法import明明已经存在的.py文件 参考 cuda在pycharm中的使用问题设置环境变量时不论是修改.bashrc文件还是在终端输入export LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH都无法在pycharm中找到该环境变量,只能在pycharm中添加 参考 fast-rcnn学习逐字理解目标检测simple-faster-rcnn-pytorch-master代码 一 二在PyTorch中使用Visdom可视化工具 参考pytorch 从头开始faster-rcnn 零 一 二 三 四ruotianluo开源的代码:pytorch-faster-rcnn Pytorch版faster rcnn的安装、配置与测试chenyuntc开源的代码:simple-faster-rcnn-pytorch 从编程实现角度学习Faster R-CNN（附极简实现） 基于云的深度学习环境使用Russell cloud如何在 GPU 深度学习云服务里，使用自己的数据集？参考Russell Lab 知乎专栏Russell Cloud github 基于云的深度学习环境简介如何六个月内学会深度学习 知乎深度学习自学指南：6个月，从基础知识到模型构建 知乎 Google Colab使用使用colab训练faster-rcnn使用colab运行深度学习gpu应用（Mask R-CNN）实践 Google Colab下载和挂载google drive的文件都在content目录下google colad在使用linux命令时要在前面加上符号’!’安装必要的包和软件123456789101112!apt-get install -y -qq software-properties-common python-software-properties module-init-tools!add-apt-repository -y ppa:alessandro-strada/ppa 2&gt;&amp;1 &gt; /dev/null!apt-get update -qq 2&gt;&amp;1 &gt; /dev/null!apt-get -y install -qq google-drive-ocamlfuse fusefrom google.colab import authauth.authenticate_user()from oauth2client.client import GoogleCredentialscreds = GoogleCredentials.get_application_default()import getpass!google-drive-ocamlfuse -headless -id=&#123;creds.client_id&#125; -secret=&#123;creds.client_secret&#125; &lt; /dev/null 2&gt;&amp;1 | grep URLvcode = getpass.getpass()!echo &#123;vcode&#125; | google-drive-ocamlfuse -headless -id=&#123;creds.client_id&#125; -secret=&#123;creds.client_secret&#125; 挂载Google Drive代码123# 指定Google Drive云端硬盘的根目录，名为drive!mkdir -p drive!google-drive-ocamlfuse drive 注意不能使用cd直接改变路径,而是用python的方法123import osos.chdir(&apos;drive&apos;)!ls 以上是使用相对目录的方法,也就是只能使用访问当前目录下的文件如果使用绝对目录,则为:123import osos.chdir(&apos;/content/drive&apos;)!ls 使用tips(1)改变当前目录为drive后就可以使用google drive中的文件,也可以进入该文件夹下载文件，由于google drive在12小时候就会收回，所以将文件保存在中即可避免这种情况(2)google对于下载外网数据集速度奇快,但是colab对于/content/drive下的文件读写速度远低于根目录/content下的速度,所以不论是训练数据还是解压数据集都建议在根目录下进行，可将关键文件如checkpoint保存到drive中或者直接保存到本地从本地计算机上传文件到colab123from google.colab import filesuploaded = files.upload() 从colab下载文件到本地123456from google.colab import fileswith open(&apos;example.txt&apos;, &apos;w&apos;) as f: f.write(&apos;some content&apos;)files.download(&apos;example.txt&apos;) (3)从本地上传数据集到google drive如果上传文件夹会很慢，但是压缩后上传速度会较快之后可从/content/drive中复制压缩数据集文件到/conten目录下(这里加上sudo命令提高权限)1!sudo cp /content/drive/mtwi_2018_task1_test.zip /content (4)把数据集放到目标目录后可利用以下命令将其解压到当前目录1unzip wwwroot.zip (5)cloab中修改脚本文件.py的方法这里我使用以下目录将原程序删除1rm -rf /content/cnn_lstm_ctc_ocr_for_ICPR 在github中修改文件后再讲程序拷贝到colab中12os.chdir(&apos;/content&apos;)!git clone https://github.com/vampire1996/cnn_lstm_ctc_ocr_for_ICPR.git (6)在google cloab中用7z解压zip文件，速度快于使用unzip命令下载7z12345os.chdir(&apos;/content&apos;)!wget https://jaist.dl.sourceforge.net/project/p7zip/p7zip/16.02/p7zip_16.02_src_all.tar.bz2!tar -jxvf p7zip_16.02_src_all.tar.bz2!cd p7zip_16.02!make &amp;&amp; make install 解压命令1!7za e ICPR2018_test.zip -r -o./ #/后为解压目录 用Google Colab参加天池比赛基于天池新人赛MTWI 2018 挑战赛一：网络图像的文本识别(1)安装必要的包和软件123456789101112!apt-get install -y -qq software-properties-common python-software-properties module-init-tools!add-apt-repository -y ppa:alessandro-strada/ppa 2&gt;&amp;1 &gt; /dev/null!apt-get update -qq 2&gt;&amp;1 &gt; /dev/null!apt-get -y install -qq google-drive-ocamlfuse fusefrom google.colab import authauth.authenticate_user()from oauth2client.client import GoogleCredentialscreds = GoogleCredentials.get_application_default()import getpass!google-drive-ocamlfuse -headless -id=&#123;creds.client_id&#125; -secret=&#123;creds.client_secret&#125; &lt; /dev/null 2&gt;&amp;1 | grep URLvcode = getpass.getpass()!echo &#123;vcode&#125; | google-drive-ocamlfuse -headless -id=&#123;creds.client_id&#125; -secret=&#123;creds.client_secret&#125; (2)挂载Google Drive代码123# 指定Google Drive云端硬盘的根目录，名为drive!mkdir -p drive!google-drive-ocamlfuse drive (3)将程序下载到colab中123import osos.chdir(&apos;/content&apos;)!git clone https://github.com/zfxxfeng/cnn_lstm_ctc_ocr_for_ICPR.git (4)将下载好的模型拷贝到data/model目录下(密码 2h1z12345678910os.chdir(&apos;/content&apos;)!mkdir model!sudo cp /content/drive/colaboratory/tianchi/ICPR2018CHALLENGE/model.zip /content/modelimport osos.chdir(&apos;/content/model&apos;)!unzip model.zip!sudo cp /content/model/graph.pbtxt /content/cnn_lstm_ctc_ocr_for_ICPR/data/model!sudo cp /content/model/model.ckpt-1405532.data-00000-of-00001 /content/cnn_lstm_ctc_ocr_for_ICPR/data/model!sudo cp /content/model/model.ckpt-1405532.index /content/cnn_lstm_ctc_ocr_for_ICPR/data/model!sudo cp /content/model/model.ckpt-1405532.meta /content/cnn_lstm_ctc_ocr_for_ICPR/data/model (5)验证结果,运行这里需要修改validate.py的代码,因为12sess.run(prediction,&#123; image: image_data, width: image_data.shape[1]&#125; ) 这里运行session时对图像维度的要求是(31,?,1)因此要对图像进行放缩,在src目录下添加一个validateSetTransfer.py文件修改以下代码,可在命令行执行以下代码,以实现对验证集图像的resize(注意对图像的resize要在水平和竖直两个方向上都进行resize,这样才能更为精确地保存图像的原有信息)123456789101112131415161718192021222324252627import numpy as npimport cv2from PIL import Imagefrom skimage import ioImg_dataset_dir = '/content/mtwi_2018_task1_test/icpr_mtwi_task1/test_line_image'crop_dataset_dir_horiz = '/content/Crop_dataset/horizontal/'crop_dataset_dir_vert = '/content/Crop_dataset/vertical/'Image_list = os.listdir(Img_dataset_dir)for i in range(len(Image_list)): #img_new = Image.open('/content/cnn_lstm_ctc_ocr_for_ICPR/data/test_image/1_1.jpg') img = Image.open(os.path.join(Img_dataset_dir,Image_list[i])).convert('RGB') if img.size[0]&gt;=1.2*img.size[1]:#(0为宽，1位高)#横的 p=img.size[1]/31 if p!=0: new_height=31 new_width=int(img.size[0]/p) img=img.resize((new_width,new_height)) img.save(os.path.join(crop_dataset_dir_horiz,Image_list[i])) else:#竖的 p=img.size[0]/31 if p!=0: new_height=int(img.size[1]/p) new_width=31 img=img.resize((new_width,new_height)) img.save(os.path.join(crop_dataset_dir_vert,Image_list[i])) 接下来即可执行代码12os.chdir(&apos;/content/cnn_lstm_ctc_ocr_for_ICPR/src&apos;)!python validate.py 当下方出现1Use standard file APIs to check for files with this prefix. 在下面的小框框里填上希望识别的图像的路径,比如1/content/cnn_lstm_ctc_ocr_for_ICPR/data/test_image/1.jpg 稍等一会儿就可以看到结果同时,由于要对整个测试集进行测试而不是对一张图片进行测试,对main函数进行以下修改12345678910111213temp=''cur_line=0#由于计算结果比较慢，每次开始时设置一变量,比如line_10，这里键盘键入cur_line=10,则从line_10开始读取while True: temp = input() breakcur_line=int(temp)for i in range(cur_line,len(Image_list)): image_data = _get_image(os.path.join(Img_dataset_dir,'line_'+str(i+1)+".jpg"))#读取测试集数据 [output] = sess.run(prediction,&#123; image: image_data, width: image_data.shape[1]&#125; ) listText = open(output_txt+'/'+'list.txt','a')#这里每次循环都对txt文件进行开关操作以方便打开该文件监控进程 listText.write("line_"+str(i+1)+".jpg"+" "+_get_string(output.values)+"\n") listText.close() 这里123Img_dataset_dir = &apos;/content/Crop_dataset/horizontal&apos;#测试集所在目录Image_list = os.listdir(Img_dataset_dir)#测试集图片文件名的列表output_txt = &apos;/content/cnn_lstm_ctc_ocr_for_ICPR/result&apos;#输出txt文件所在目录 在cnn_lstm_ctc_ocr_for_ICPR/result目录下即可看到所得txt文件 深度学习概念1.mAP(Mean Average Precision)简而言之,对多个验证集个体求平均AP值,AP值代表某个验证集的平均精确度(越接近于1精确度越高)True Positive(TP)，模型将正实例判定为正类False Negative(FN)，模型将正实例判定为负类False Positive(FP), 模型将负实例判定位正类True Negative(TN)，模型将负实例判定位负类精度（Precision）：精度是针对判定结果而言，预测为正类的样本（TP+FP）中真正是正实例（TP）的比率 $$ Precision=\frac{TP}{TP+FP}$$ 召回率（Recall）：召回率是针对样本而言，被正确判定的正实例（TP）在总的正实例中（TP+FN）的比率 $$ Recall=\frac{TP}{TP+FN}$$ 举例:在一个数据库中有1000个文档，其中有100个是与NBA相关的，系统检索出75个文档，其中，只有50个是与NBA相关，此时：精确率 = 50 / 75 = 67%召回率 = 50 / 100 = 50% 精度和召回率虽然没有必然的关系，然而在大规模数据集合中，这两个指标却是相互制约的。一般情况下，召回率高时，精度低；精度高时，召回率低。计算mAP的方法:画出Precision-Recall曲线(1)在VOC2010以前，只需要选取当Recall &gt;= 0, 0.1, 0.2, …, 1共11个点时的Precision最大值，然后AP就是这11个Precision的平均值。(2)在VOC2010及以后，需要针对每一个不同的Recall值（包括0和1），选取其大于等于这些Recall值时的Precision最大值，然后计算PR曲线下面积作为AP值。 什么是mAP？机器学习中常见的评估指标：Precision、recall、F-measure、Accuracy、ROC曲线和AUC知乎:目标检测中的mAP是什么含义？ 2.Epoch, Batch, IterationEpoch:使用训练集的全部数据对模型进行一次完整训练,被称为”一代训练”Batch:使用训练集的一小部分样本对模型权重进行一次反向传播的参数更新,这一小部分样本被称为”一批数据”Iteration:使用一个Batch数据对模型进行一次参数更新的过程,被称之为”一次训练”换算关系 $$Number of Batches =\frac{Training Set Size}{Batch Size}$$ 实际上，梯度下降的几种方式的根本区别就在于上面公式中的 Batch Size不同。注：上表中 Mini-Batch 的 Batch 个数为 N / B + 1 是针对未整除的情况。整除则是 N / B。示例CIFAR10 数据集有 50000 张训练图片，10000 张测试图片。现在选择 Batch Size = 256 对模型进行训练。每个 Epoch 要训练的图片数量：50000训练集具有的 Batch 个数：$50000/256=195+1=196$每个 Epoch 需要完成的 Batch 个数： 196每个 Epoch 具有的 Iteration 个数： 196每个 Epoch 中发生模型权重更新的次数： 196训练10代后，模型权重更新的次数：$19610=1960$不同代的训练，其实用的是同一个训练集的数据。第 1 代和第 10代虽然用的都是训练集的五万张图片，但是对模型的权重更新值却是完全不同的。因为不同代的模型处于代价函数空间上的不同位置，模型的训练代越靠后，越接近谷底，其代价越小。 3.梯度下降知乎:深度学习中的优化算法从数学上的角度来看，梯度的方向是函数增长速度最快的方向，那么梯度的反方向就是函数减少最快的方向。那么，如果想计算一个函数的最小值，就可以使用梯度下降法的思想来做。这里改变的是变量x的值，梯度方向只有正负之分,x沿着梯度方向改变,函数值f(x)必然增大知乎:深度学习中的优化算法Momentum SGD加入速度v避免在局部最小值出梯度计算为0导致权重矩阵无法更新AdaGrad进行梯度累加以提高迭代速度AdaGrad 和 RMSProp 算法的逃离速度比 SGD 快了许多。 jupyter note使用下载anaconda后，在anaconda promote输入jupyter notebook即可打开notebook，可根据终端中的内容输入对应网址查看具体内容]]></content>
      <categories>
        <category>CV deeplearning</category>
      </categories>
      <tags>
        <tag>-CV deeplearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web Service学习]]></title>
    <url>%2Fvampire1996.github.io%2F2019%2F03%2F26%2Fwebservice%2F</url>
    <content type="text"><![CDATA[建立工程和使用参考访问上图URI+services(localhost:8080/WebServiceTest_war_exploded/services)即可实现对服务页面的访问。 入门学习参考 将本地项目部署到云服务器上将本地web项目部署到腾讯云服务器上 tomcat安装记得要和jdk版本匹配(在tomcat官网上有匹配信息)在腾讯云服务器上用9.0版本不好使，下了7.0版本好使腾讯云服务器踩坑实录:想在本地访问云服务器首先要开启tomcat服务器(cmd中输入startup),访问1http://localhost:8080 其中8080是在tomcat/conf/server.xml中修改的。当外网访问时，如果设置为80端口可以不加端口号，但是由于我用这个腾讯云服务器本地80端口已经被nginx服务器占用了，所以没办法使用，而外网想访问云服务器可以使用公网IP+端口号(如8080)的形式访问tomcat服务器。然而我用这个腾讯云服务器公网IP下的8080端口也被占用了，所以改成了8090，这样就可以在外网使用tomcat服务器下的webserverce啦。 安卓访问webservice参考这里要注意的是soap版本号SoapSerializationEnvelope.VER12要低于web service的soap版本号1SoapSerializationEnvelope envelope = new SoapSerializationEnvelope(SoapSerializationEnvelope.VER12); 其次这里类型转换会报错，直接把envelope.bodyIn转换为字符形式即可1SoapObject object = (SoapObject) envelope.bodyIn;]]></content>
      <categories>
        <category>web service</category>
      </categories>
      <tags>
        <tag>-web service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓学习]]></title>
    <url>%2Fvampire1996.github.io%2F2019%2F02%2F18%2FandroidLearning%2F</url>
    <content type="text"><![CDATA[使用OkHttp进行Http访问当访问某一地址时失败，需要在AndroidManifest.xml文件中添加1android:usesCleartextTraffic="true" 参考 使用ADB命令行win+r进入cmd界面，cd命令进入Android SDK目录下，接下来再进入platform-tools目录接下来即可使用adb命令。 完全卸载已在设备上安装的App1adb uninstall com.example.coolweather 无法修改应用图标用adb命令完全卸载app后，重命名包名再重新安装app参考 下载七牛云空间中的公开资源找到外链默认域名或自定义绑定的域名，域名+文件名即为访问该文件的url，直接进行http访问即可。也可以在七牛云中进入存储空间，内容管理+操作+点击显示更多操作+复制外链查看该文件对应的url。 linux访问windows中文件‘’’cd /mnt/d #访问D盘cd /mnt/c #访问C盘‘’’ 打开图形界面1.打开xfce4桌面1xfce4-session 2.打开compiz1compiz]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>-Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Letter0]]></title>
    <url>%2Fvampire1996.github.io%2F2019%2F02%2F08%2Fletter0%2F</url>
    <content type="text"><![CDATA[亲爱的鱼鱼: 一年一度的情人节又到了，不知道你有没有想找个人一起度过呢？哈哈，没有鲜花也没有礼物，和你说说心里话吧。 距离我们相识也有一段时间了，虽然只是网上聊天，但是隔着屏幕我也能感受到你的善良和温油(不知道有没有猜错)。我们每天分享彼此的生活，诉说各自的心事，可能在彼此心里都描绘出了一个对方的形象，但是就像我之前说的，只是管中窥豹，但必须承认和你交流给我的生活带来了更多的色彩，让我觉得也许爱情并不遥远。我记得有人说幸福就是每天醒来都满怀希望的开始新的一天，而你就是那个甜甜的希望。 与你的相遇是我之前人生没有过的体验，几乎没有女生主动找我聊过天，也没有人像你这样时时刻刻都考虑到我的感受。我知道这是你的天性，但是还是有点小私心希望你能只对我这样hhh。我总在想你这样善良的女生如果遇到生活黑暗丑陋的一面怎么办？但是通过对你个人经历的了解我觉得可能你总能找到方法解决问题或者说你已经习惯出淤泥而不染永远保持对真善美的追求，做一个文能插花，武能上山采摘的奇女子. 在我们的谈话中你总是说自己是学渣，菜鸡等等看低自己的话。我觉得你完全没有必要担心或者对自己感到不自信，因为就我个人经验来说，只要一直保持努力向上的心态，让自己进入一个优秀而出色的集体，肯定会不断进步，成为自己想变成的那个人。因为人生是一场长跑，一时的落后并不重要，重要的是要做笑到最后的那个人，当然也希望我们能彼此监督，共同进步，不论是学习还是生活。 最后，希望如果我们足够幸运，明年的今天我能陪在你身边，过一个真正意义上的情人节(小鲜花，小礼物搞起来)，也希望当未来某一天你看到这些话的时候，会感到甜蜜。]]></content>
      <categories>
        <category>Letter</category>
      </categories>
      <tags>
        <tag>-Letter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 117. Populating Next Right Pointers in Each Node II]]></title>
    <url>%2Fvampire1996.github.io%2F2019%2F01%2F14%2Fleetcode117%2F</url>
    <content type="text"><![CDATA[117. Populating Next Right Pointers in Each Node II python solution123456789101112131415161718192021222324252627282930313233# Definition for binary tree with next pointer.# class TreeLinkNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# self.next = None"""思路整理 BFS+Queue1)利用队列 存储每一代的节点 2)对于每一代节点 迭代执行： i.node为当前节点 pre为其左侧的节点 ii.令pre指向node即可 最后一个节点指向空Explanation1)use queue to store the node's in one certain generation2)for each,generation,iteratively conduct: i.node is current node and pre is the node in its left side ii.let pre points to node and let the last node points to null"""class Solution: # @param root, a tree link node # @return nothing def connect(self, root): if not root:return queue=[root] while queue: length=len(queue) for i in range(length): node=queue.pop(0) if i!=0:pre.next=node if node.left:queue.append(node.left) if node.right:queue.append(node.right) pre=node java solution123456789101112131415161718192021222324252627282930313233343536/** * Definition for binary tree with next pointer. * public class TreeLinkNode &#123; * int val; * TreeLinkNode left, right, next; * TreeLinkNode(int x) &#123; val = x; &#125; * &#125; *///level traversalpublic class Solution &#123; public void connect(TreeLinkNode root) &#123; TreeLinkNode dummy=new TreeLinkNode(0); while(root!=null) &#123; TreeLinkNode cur=dummy; System.out.println(root.val); while(root!=null) &#123; if(root.left!=null) &#123; cur.next=root.left; cur=cur.next; &#125; if(root.right!=null) &#123; cur.next=root.right; cur=cur.next; &#125; root=root.next; &#125; root=dummy.next; //dummy.next必需置为null因为到最后一个level必须将dummy.next置为null才能推出循环 root=null dummy.next = null; &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA进行android开发]]></title>
    <url>%2Fvampire1996.github.io%2F2019%2F01%2F11%2FideaAndroid%2F</url>
    <content type="text"><![CDATA[配置Gradle新建项目无法运行出现Failed to find Build Tools revision 27.0.3的解决方法参考本地下载的builtool版本就是buildToolsVersion “28.0.3” 出现多个gradle报错“Error:Gradle distribution ‘https\://services.gradle.org/distributions/gradle-4.4-all.zip’ contains too many directories. Expected to find exactly 1 directory.”解决方法：将gradle-4.4-all.zip中的__MACOSX 文件夹删除。]]></content>
      <categories>
        <category>android开发</category>
      </categories>
      <tags>
        <tag>-android开发 -IntelliJ IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 300. Longest Increasing Subsequence]]></title>
    <url>%2Fvampire1996.github.io%2F2019%2F01%2F08%2Fleetcode300%2F</url>
    <content type="text"><![CDATA[300. Longest Increasing Subsequence python solution12345678910111213141516171819202122232425262728class Solution(object): def lengthOfLIS(self, nums): """ :type nums: List[int] :rtype: int """ """ 思路整理:DP O(n^2) Input: [10,9,2,5,3,7,101,18] cur=[1,1,1,2,2,3,4,4] 1)用cur存储每个位置到该位置时的最大子序列长度 2)对于每个nums[i] 找到其之前nums中每个小于其的位置j,对应cur[j]+1即为 从从j到i的长度 而cur[i]需要找到所有这些长度中最大的值 Explanation 1)we use cur to store lis in each position in nums 2)for each nums[i],we need to find all nums[j]&lt;nums[i] and cur[j]+1 is the length form nums[j] to nums[i],and we need to find the longest length among all cur[j]+1 """ if not nums:return 0 cur=[1 for i in range(len(nums))] length=1 for i in range(1,len(nums)): for j in range(i): if nums[j]&lt;nums[i]: if cur[j]+1&gt;cur[i]: cur[i]=cur[j]+1 if cur[i]&gt;length:length=cur[i] return length java solution1234567891011121314151617181920212223242526272829303132/*DP O(nlogn)tails用于存放所有递增子序列的最小值tails[i] 存放长度为i+1的递增子序列最小值(在nums中)Input:nums = [4,5,6,3]len = 1 : [4], [5], [6], [3] =&gt; tails[0] = 3len = 2 : [4, 5], [5, 6] =&gt; tails[1] = 5len = 3 : [4, 5, 6] =&gt; tails[2] = 6利用二分查找(1)当num&gt;所有tails 则tails.append(num) Size++(2)当 tails[i-1]&lt;num&lt;=tails[i] tails[i]=num*/class Solution &#123; public int lengthOfLIS(int[] nums) &#123; int[] tails=new int[nums.length]; int Size=0; for(int num:nums) &#123; int i=0,j=Size; while(i&lt;j) &#123; int m=i+(j-i)/2; //最终跳出循环时i=j 因此若tails[m]==num则j=m最终i=j=m if(tails[m]&lt;num) i=m+1; else j=m; &#125; tails[i]=num; if(i==Size)Size++; &#125; return Size; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 90. Subsets II]]></title>
    <url>%2Fvampire1996.github.io%2F2019%2F01%2F06%2Fleetcode90%2F</url>
    <content type="text"><![CDATA[90. Subsets II python solution123456789101112131415161718192021222324252627class Solution(object): def subsetsWithDup(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ """ 思路整理:DFS recursion 1)对nums进行排序以避免nums中重复元素不聚集在一起如[1,2,4,4,3,4] 2)从nums中依次取出元素加到path中进行DFS 3)对于重复元素如[1,2,2]中的2，res中每个以2为开头的数组的只取nums的第一个2 Explanation 1)sort nums to gather all same number together 2)take numbers from nums iteratively and use them to conduct DFS 3)for same numbers like 2 in [1,2,2],each array only take the first 2 as its first 2 """ def helper(start,end,path,res): res.append(path) for i in range(start,end): if i!=start and nums[i]==nums[i-1]:continue helper(i+1,end,path+[nums[i]],res) return res=[] nums.sort() helper(0,len(nums),[],res) return res java solution123456789101112131415161718192021222324252627282930/*对于无重复元素的n维数组 有2^n个子数组 因为每个元素在每个子数组里都只有出现或者不出现两种可能而对于有重复元素的数组如[1,2,2](1)[](2)[] [1] 复制一份[] 并向其中加入1(3)[] [1] [2] [1,2] 复制一份[] [1] 并向其中加入2(3)[] [1] [2] [1,2] [2,2] [1,2,2]对于重复元素 只向前一次添加过与其相同元素的数组中添加该元素复制一份[2] [1,2] 并向其中加入2*/class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;List&lt;Integer&gt;&gt;(); int start=0; res.add(new ArrayList&lt;Integer&gt;()); Arrays.sort(nums); for(int i=0;i&lt;nums.length;i++) &#123; if(i==0||nums[i]!=nums[i-1]) start=0; int size=res.size(); for(int j=start;j&lt;size;j++) &#123; List&lt;Integer&gt; temp=new ArrayList&lt;Integer&gt;(res.get(j)); temp.add(nums[i]); res.add(temp); &#125; start=size; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日记]]></title>
    <url>%2Fvampire1996.github.io%2F2018%2F12%2F31%2Fpoem3%2F</url>
    <content type="text"><![CDATA[海子 姐姐, 今夜我在德令哈, 夜色笼罩姐姐, 我今夜只有戈壁草原尽头我两手空空悲痛时握不住一颗泪滴姐姐, 今夜我在德令哈这是雨水中一座荒凉的城除了那些路过的和居住的德令哈……今夜这是唯一的, 最后的, 抒情这是唯一的, 最后的, 草原我把石头还给石头让胜利的胜利今夜青稞只属于他自己一切都在生长今夜我只有美丽的戈壁 空空姐姐, 今夜我不关心人类, 我只想你]]></content>
      <categories>
        <category>poem</category>
      </categories>
      <tags>
        <tag>-poem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我有一个不到一百斤的理想]]></title>
    <url>%2Fvampire1996.github.io%2F2018%2F12%2F31%2Fpoem2%2F</url>
    <content type="text"><![CDATA[逆水谣 借一碗馄饨面，扑灭我的忧伤撒一把小虾米，助我去远洋回忆起昨夜的甜点，本该充满甜蜜的力量却为何在望向今天的糖果时，忍不住迷茫 我有一个，不到一百斤的理想恶魔却挥舞着香甜，摧毁这志向我只能向橱窗里的美丽，轻轻的挥一挥手等着我战胜了邪恶，再接你回家箱 或许我的余生，将在战斗中激荡或许我的梦想，只会增加重量或许我的期待，已穿在了别人的身上或许下一刻的我，已经沦为恶魔的臂膀 悲哀啊，天命如此难挡绽放吧，味蕾上的欲望悔恨吗？那些擦肩而过的漂亮请安慰我！这人生的，路还长……]]></content>
      <categories>
        <category>poem</category>
      </categories>
      <tags>
        <tag>-poem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[老电影]]></title>
    <url>%2Fvampire1996.github.io%2F2018%2F12%2F31%2Fpoem1%2F</url>
    <content type="text"><![CDATA[逆水谣 无所事事的咖啡杯蜷缩在沙发上的腿 白天不开窗子的电脑前看着那部电影，回味 舌尖有着葡萄干的甜蜜用来遮掩着苦涩的嘴 手指在把发尾缠绕着纠结着还没播到的伤悲 有时酸涩会化作眼泪有些记忆会酝酿得甜美 那些曾经两个人共同看过的老电影一个人看的时候，只会是微笑着流泪]]></content>
      <categories>
        <category>poem</category>
      </categories>
      <tags>
        <tag>-poem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 279. Perfect Squares]]></title>
    <url>%2Fvampire1996.github.io%2F2018%2F12%2F29%2Fleetcode279%2F</url>
    <content type="text"><![CDATA[279. Perfect Squares python solution123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution(object): def numSquares(self, n): """ :type n: int :rtype: int """ """ O(n^3) 思路整理: 1)用nums存储小于根号n取整的所有整数的平方和 2)迭代执行O(n) 以nums[i]为组成n的平方数中的最大值 j=i 迭代执行O(j) 找到以nums[0:j+1]中平方数组成n-nums[i]的最小平方数个数--O(j) Explanation 1)use nums to store all square numbers of integers which are less than int(sqrt(n)) 2)iteratively conduct take nums[i] as the largest number as a part of n iteratively conduct find the smallest number of n-nums[i]'s square numbers using nums[0:j+1] """ def helper(nums,lo,hi,temp): if temp==0:return 0 i=hi cnt=0 while i&gt;=lo: if temp-nums[i]&gt;0: temp-=nums[i] cnt+=1 continue elif temp-nums[i]==0:break else:i-=1 return cnt+1 num=int(math.sqrt(n)) nums=[i*i for i in range(1,num+1)] cnt=2e31 i=num-1 while i&gt;=0: j=i while j&gt;=0: cur=helper(nums,0,j,n-nums[i]) if cur+1&lt;cnt:cnt=cur+1 j-=1 i-=1 return cnt python3 solution1234567891011121314151617181920class Solution: _dp=[0] def numSquares(self, n): """ :type n: int :rtype: int """ """ static dynamic programming 用dp数组存储每一个数到该位置所需的最小平方数个数 那么dp[j]=min(dp[j-i*i])+1 1&lt;=i*i&lt;=j j=j-i*i+i*i 也就是说每个数都可以由cnt[j-i*i]+1得到一个平方数和的方案 找到其中最小的个数即可 这里利用静态变量_dp，只需初始化一次 当之前有testcase调用之后，之前的_dp继续可以用与下一次 testcase使用,因此可以减少时间 """ mincnt=self._dp while len(mincnt)&lt;=n: mincnt+=[min(mincnt[-i*i] for i in range(1,int(len(mincnt)**0.5)+1))+1] return mincnt[n] java solution1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class Solution &#123; public int numSquares(int n) &#123; return LagrangeFourSquareTheorem(n); &#125; /* 广度优先搜索 search search Input: n = 13 1 2(1+1) 4 5(1+4) 9 10(1+9) cnt=1 13(9+3) 结果为2 cnt=2 */ private int bfs(int n) &#123; if(n&lt;=0)return 0; List&lt;Integer&gt; squares=new ArrayList&lt;Integer&gt;(); boolean visited[]=new boolean[n]; for(int i=1;i*i&lt;=n;i++) &#123; if(i*i==n)return 1; squares.add(i*i); &#125; Queue&lt;Integer&gt; search = new LinkedList&lt;Integer&gt;(); for(int i=1;i*i&lt;=n;i++)search.add(i*i); int curCnt=1; while(!search.isEmpty()) &#123; curCnt++; int searchSize=search.size(); for(int i=0;i&lt;searchSize;i++) &#123; int tmp=search.peek(); //当前search中某一数加上一个平方数如果等于n则搜索结束 for(int square:squares) &#123; if(tmp+square==n) &#123; return curCnt; &#125; //visited 用于存储是否访问过某一节点，如果访问过则不再访问 else if(tmp+square&lt;n&amp;&amp;visited[tmp+square-1]==false) &#123; search.add(tmp+square); visited[tmp+square-1]=true; &#125; else if(tmp+square&gt;n) break; &#125; search.remove(); &#125; &#125; return 0; &#125; //Lagrange 四平方定理： 任何一个正整数都可以表示成不超过四个整数的平方之和。 //O(n) private int LagrangeFourSquareTheorem(int n) &#123; int ub=(int)Math.sqrt(n);//upper bound for(int a=0;a&lt;=ub;a++) &#123; for(int b=a;b&lt;=ub;b++) &#123; //因为a,b都是从0开始的,所以返回时的数一定是最小的 int c=(int)Math.sqrt(n-a*a-b*b); if(a*a+b*b+c*c==n) &#123; return (a==0?0:1)+(b==0?0:1)+(c==0?0:1); &#125; &#125; &#125; //超过3个只能是4 return 4; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 213. House Robber II]]></title>
    <url>%2Fvampire1996.github.io%2F2018%2F12%2F27%2Fleetcode213%2F</url>
    <content type="text"><![CDATA[213. House Robber II python solution12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution(object): def rob(self, nums): """ :type nums: List[int] :rtype: int """ """ O(n) time complexity O(n) space complexity 思路整理 1)计算某一位置最大金钱的方法是 max(pre[i-2],pre[i-3])+nums[i] pre[i]为本位置可获得的最大金钱,由于不能找与其相邻的位置，因此只能找pre[i-2],pre[i-3] 2)由于题目中说明第一个和最后一个元素也是相邻的 所以利用maxMoney1存储从第一个元素开始到倒数第二个元素每个位置可获得最大金钱 maxMoney2存储从第二个元素开始到最后一个元素每个位置可获得最大金钱 则max(max(maxMoney1[-1],maxMoney1[-2]),max(maxMoney2[-1],maxMoney2[-2])) 倒数第三个元素及之前的元素都会被最后两个元素覆盖 即为总体可获得的最大金钱 理由:从第一个元素开始的某一条抢劫路径不可能到达最后，所以包含最后元素就不包含第一个元素 包含第一个元素就不包含最后一个元素 Explanation Input abcdefgh maxMoney1 bcdefgh to get the maximum in each position maxMoney2 abcdefg when you start at the beginning of the array,you can just raech the (n-1)th position and if you start at the second position,you can reach the last position """ if not nums:return 0 if len(nums)&lt;=3:return max(nums) maxMoney1,maxMoney2=[],[0] for i in range(len(nums)): if i==0:maxMoney1.append(nums[i]) elif i==1: maxMoney1.append(nums[i]) maxMoney2.append(nums[i]) elif i==2: maxMoney1.append(nums[i]+nums[i-2]) maxMoney2.append(nums[i]) elif i==3 and i!=len(nums)-1: if maxMoney1[i-2]&gt;maxMoney1[i-3]: maxMoney1.append(nums[i]+maxMoney1[i-2]) else: maxMoney1.append(nums[i]+maxMoney1[i-3]) maxMoney2.append(nums[i]+nums[i-2]) elif i&lt;len(nums)-1: if maxMoney1[i-2]&gt;maxMoney1[i-3]: maxMoney1.append(nums[i]+maxMoney1[i-2]) else: maxMoney1.append(nums[i]+maxMoney1[i-3]) if maxMoney2[i-2]&gt;maxMoney2[i-3]: maxMoney2.append(nums[i]+maxMoney2[i-2]) else: maxMoney2.append(nums[i]+maxMoney2[i-3]) else: if maxMoney2[i-2]&gt;maxMoney2[i-3]: maxMoney2.append(nums[i]+maxMoney2[i-2]) else: maxMoney2.append(nums[i]+maxMoney2[i-3]) return max(max(maxMoney1[-1],maxMoney1[-2]),max(maxMoney2[-1],maxMoney2[-2])) java solution1234567891011121314151617181920//用rob(k)代表截止到第k个位置最大的抢劫金额//rob(k) = max( rob(k-2) + nums[k], rob(k-1) )class Solution &#123; public int rob(int[] nums) &#123; if(nums.length==1)return nums[0]; return Math.max(helper(nums,1,nums.length-1),helper(nums,0,nums.length-2)); &#125; private int helper(int[] nums,int lo,int hi) &#123; int pre_i1=0,pre_i2=0; for(int i=lo;i&lt;=hi;i++) &#123; int cur=Math.max(nums[i]+pre_i2,pre_i1); int temp=pre_i1; pre_i1=cur; pre_i2=temp; &#125; return pre_i1; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 151. Reverse Words in a String]]></title>
    <url>%2Fvampire1996.github.io%2F2018%2F12%2F26%2Fleetcode151%2F</url>
    <content type="text"><![CDATA[151. Reverse Words in a String python solution1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution(object): def reverseWords(self, s): """ :type s: str :rtype: str """ """ 思路整理: 1)由于字符串是不可修改的 因此需要将其转换为数组 2)将整个数组翻转l[:]=l[::-1] 3)将每个单词翻转 4)排除掉前缀和后缀中的空格 5)排除掉两个单词间多余一个的空格 Explanation 1)because string can not be modified,we need to reverse it to a list 2)reverse the whole list 3)reverse each word in the list 4)redeuce the leading or trailing spaces 5)reduce multiple spaces between two words """ def reverse_string(arr, l, r): '''reverse a given string''' while l &lt; r: arr[l], arr[r] = arr[r], arr[l] l += 1 ; r -= 1 if not s:return s l=list(s) l[:]=l[::-1] length=len(s) i=0 #将每个单词翻转 while i&lt;length: if l[i]==' ': i+=1 continue j=i+1 while j&lt;length and l[j]!=' ':j+=1 reverse_string(l, i, j-1) i=j #排除掉前缀和后缀中的空格 start,end=0,length-1 while start&lt;length and l[start]==' ':start+=1 while end&gt;=0 and l[end]==' ':end-=1 if start==length or end&lt;0:return "" #排除掉两个单词间多余一个的空格 res=[l[start]] for i in range(start+1,end+1): if res[-1]==' ' and l[i]==' ':continue res.append(l[i]) return "".join(res) java solution123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Solution &#123; /* 1)输入为"" 跳过for循环 直接输出out[0]="" 2)输入为"a" 跳过for循环 直接输出out[0]="a" 3)输入为"a b c" for循环结束后res="c b " res+out[0]="c b a" */ public String reverseWords(String s) &#123; return solution2(s); &#125; //利用库函数 private String solution1(String s) &#123; String[] out=s.trim().split("\\s+"); String res=""; for(int i=out.length-1;i&gt;0;i--) &#123; res+=out[i]+" "; &#125; return res+out[0]; &#125; private String solution2(String s) &#123; if(s==null||s.length()==0)return ""; char[] res=s.toCharArray(); reverse(res,0,res.length-1); int start=0,end=0; for(int i=0;i&lt;res.length;i++) &#123; if(res[i]!=' ') &#123; res[end++]=res[i]; &#125; else if(i&gt;0&amp;&amp;res[i-1]!=' ') &#123; reverse(res,start,end-1); res[end++]=' '; start=end; &#125; &#125; reverse(res,start,end-1);//s="the sky is blue" 最后一个单词之前未翻转 //s="" 或s全为空格或s="a b c" res(0,end) //s="a b c " res(0,end-1) return new String(res,0,end&gt;0&amp;&amp;res[end-1]==' '?end-1:end); &#125; private char[] reverse(char[] s,int i,int j) &#123; while(i&lt;j) &#123; char temp=s[i]; s[i]=s[j]; s[j]=temp; i++; j--; &#125; return s; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 200. Number of Islands]]></title>
    <url>%2Fvampire1996.github.io%2F2018%2F12%2F25%2Fleetcode200%2F</url>
    <content type="text"><![CDATA[200. Number of Islands python solution123456789101112131415161718192021222324252627282930313233343536373839class Solution(object): def numIslands(self, grid): """ :type grid: List[List[str]] :rtype: int """ """ 思路整理DFS 1)用visited标记所有访问过的'1' 2)利用helper找到所有与当前位置相通的'1'，并在visited中将其标记为已访问 3)在主循环中每次遇到一个未访问过的'1' 执行一次DFS 也就是说找老了一个新的 island 所以num++ Explanation 1)we use 'visited' to store all the positions of visited '1's 2)function helper can help us to find all the '1's which is connected to current '1',and mark them to Ture in 'visited' 3)in main iteration,when we meet a '1' which has not been visited, we call function helper and also ,this means that we find a new island so num++ """ if not grid:return 0 def helper(visited,i,j,row,col): if i&lt;0 or i==row or j&lt;0 or j==col: return if visited[i][j]==True or grid[i][j]=='0':return visited[i][j]=True helper(visited,i+1,j,row,col) helper(visited,i-1,j,row,col) helper(visited,i,j+1,row,col) helper(visited,i,j-1,row,col) visited=[[False for i in range(len(grid[0]))]for j in range(len(grid))] row,col=len(grid),len(grid[0]) num=0 for i in range(row): for j in range(col): if visited[i][j]==True or grid[i][j]=='0':continue helper(visited,i,j,row,col) num+=1 return num python3 solution12345678910111213141516171819202122232425class Solution: def numIslands(self, grid): &quot;&quot;&quot; Python 2.7 doc on map --返回一个列表 &quot;Apply function to every item of iterable and return a list of the results.&quot; Python 3.6 doc on map --返回一个迭代器 &quot;Return an iterator that applies function to every item of iterable, yielding the results.&quot; 在python3中,map返回一个迭代器,将结果不断迭代,计算的结果会作与下次结果叠加 如 Input: 11110 11010 11000 00000 map(sink,(i+1,i-1,i,i),(j,j,j+1,j-1))输出 9(将所有1求和) list(map(sink,(i+1,i-1,i,i),(j,j,j+1,j-1))) 输出 1 &quot;&quot;&quot; def sink(i,j): if 0&lt;=i&lt;len(grid) and 0&lt;=j&lt;len(grid[0]) and grid[i][j]==&apos;1&apos;: grid[i][j]=&apos;0&apos; list(map(sink,(i+1,i-1,i,i),(j,j,j+1,j-1))) return 1 return 0 if not grid:return 0 return sum(sink(i,j) for i in range(len(grid)) for j in range(len(grid[0]))) java solution1234567891011121314151617181920212223242526class Solution &#123; private int row,col; public int numIslands(char[][] grid) &#123; if(grid==null||grid.length==0)return 0; row=grid.length; col=grid[0].length; int islands=0; for(int i=0;i&lt;row;i++) &#123; for(int j=0;j&lt;col;j++) islands+=sink(grid,i,j); &#125; return islands; &#125; private int sink(char[][] grid,int i,int j) &#123; if(i&lt;0||i==row||j&lt;0||j==col||grid[i][j]=='0')return 0; grid[i][j]='0'; for(int k=0;k&lt;4;k++) &#123; sink(grid,i+d[k],j+d[k+1]); &#125; return 1; &#125; int[] d=&#123;1,0,-1,0,1&#125;;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 80. Remove Duplicates from Sorted Array II]]></title>
    <url>%2Fvampire1996.github.io%2F2018%2F12%2F25%2Fleetcode80%2F</url>
    <content type="text"><![CDATA[80. Remove Duplicates from Sorted Array II python solution123456789101112131415161718192021222324252627282930313233343536373839404142class Solution(object): def removeDuplicates(self, nums): """ :type nums: List[int] :rtype: int """ """ 思路整理 1)length为要返回的长度 cnt为连续元素相等的子数组长度 pre为当前元素前一个元素的值 2)当前元素和pre相等且之前只有一个一个与之相同的元素(pre) 令nums[length]=nums[i] length代表当前已经符合要求的长度 因此这句话代表将当前元素赋值给符合要求长度部分的下一个元素 此时length长度+1 3)当前元素和pre不等 令nums[length]=nums[i] 且相应修改pre length cnt的值 Explanation 1)lenght represents the length we will return cnt represents the length of subarray whose elements are constantly equal pre represents the previous number before nums[i] 2)if nums[i]==pre and cnt==1:#only one number before nums[i] equals to nums[i] set nums[length]=nums[i],length represents the length of the subarray which has arranged according the given requiremnet,after this lenght=length 3)if nums[i]!=pre set nums[length]=nums[i],and change pre,length,cnt """ if not nums:return length,pre,cnt=1,nums[0],1 for i in range(1,len(nums)): if nums[i]==pre and cnt==1: nums[length]=nums[i] cnt+=1 length+=1 elif nums[i]!=pre: nums[length]=nums[i] pre=nums[i] length+=1 cnt=1 return length java solution12345678910111213141516171819202122232425class Solution &#123; public int removeDuplicates(int[] nums) &#123; /* nums[i-2] nums[i-1] nums[i] a a a a b b a b c 只要nums[i]&gt;nums[i-2] nums[i]即为符合题目要求的元素 需要加到符合当前要求序列的末端 然鹅这里nums[i-2]可能已经别修改过了 Given nums = [1,1,1,2,2,3] 到nums[4]的时候 nums = [1,1,2,2,2,3] 所以应该改为nums[length-2] nums[length-1] nums[i],原理同上 */ int length=0; for(int num:nums) &#123; if(length&lt;2||num&gt;nums[length-2]) &#123; nums[length++]=num; &#125; &#125; return length; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 152. Maximum Product Subarray]]></title>
    <url>%2Fvampire1996.github.io%2F2018%2F12%2F24%2Fleetcode152%2F</url>
    <content type="text"><![CDATA[152. Maximum Product Subarray python solution12345678910111213141516171819202122232425262728293031323334class Solution(object): def maxProduct(self, nums): """ :type nums: List[int] :rtype: int """ """ 思路整理 只有两种可能 大写为整数 小写 1)负数的个数为奇数nums=[a,B,c,D,e,F,g,H,i] 对于nums必然可以转换为[A,b]或者[a,B]的形式 (任意一对负数可以组合成一个正数) 而forward记录正向乘积 back记录反向乘积 即可记录A,B这些值中的最大值 2)负数的个数为偶数 将所有数乘起来即可 Explanation there are only two possible situations: 1)the number of negetive numbers are even nums=[a,B,c,D,e,F,g,H,i] num can be transfered to [A,b]or[a,B] we use back and forward to claculate the back product and forward product.so we can use them to find the maximum in A,B's 2)he number of negetive numbers are odd nums=[a,B,c,D,e,F,g,H,i] just return the product of all nums """ res=-2e31 forward,back=1,1 l=len(nums) for i in range(l): forward*=nums[i] back*=nums[l-i-1] res=max([res,forward,back]) if back==0:back=1 if forward==0:forward=1 return res java solution12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int maxProduct(int[] nums) &#123; int res=nums[0]; /* 用min max存储当前最大和最小的乘积 如果nums[i]&lt;0 则nums[i]*max&lt;nums[i]*min因此需要将max和min交换 如果nums[i]=0 max=Math.max(nums[i],nums[i]*max)=0; min=Math.min(nums[i],nums[i]*min)=0; 若nums[i+1]&gt;0 max=Math.max(nums[i+1],nums[i+1]*max)=nums[i+1]; min=Math.min(nums[i+1],nums[i+1]*min)=0; 若nums[i+1]&lt;0 max=Math.max(nums[i+1],nums[i+1]*max)=0; min=Math.min(nums[i+1],nums[i+1]*min)=nums[i+1]; min和max中一定有一个保存nums[i+1] 在接下来的运算中不会会略掉nums[i+1],巧妙地避开了nums[i]=0的情况 */ int max=res,min=res; for(int i=1;i&lt;nums.length;i++) &#123; if(nums[i]&lt;0) &#123; int temp=max; max=min; min=temp; &#125; max=Math.max(nums[i],nums[i]*max); min=Math.min(nums[i],nums[i]*min); res=Math.max(res,max); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 116. Populating Next Right Pointers in Each Node]]></title>
    <url>%2Fvampire1996.github.io%2F2018%2F12%2F24%2Fleetcode116%2F</url>
    <content type="text"><![CDATA[116. Populating Next Right Pointers in Each Node python solution12345678910111213141516171819202122232425262728293031323334353637# Definition for binary tree with next pointer.# class TreeLinkNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# self.next = None"""思路整理 BFS+Queue1)利用队列 存储每一代的节点 2)对于每一代节点 迭代执行： i.node为当前节点 pre为其左侧的节点 ii.令pre指向node即可 最后一个节点指向空Explanation1)use queue to store the node's in one certain generation2)for each,generation,iteratively conduct: i.node is current node and pre is the node in its left side ii.let pre points to node and let the last node points to null"""class Solution: # @param root, a tree link node # @return nothing def connect(self, root): if not root:return queue=[root] while queue: #range(len(queue)) 生成[0,...len(queue)-1]可迭代的列表 #不会因为len(queue)改变而改变 for i in range(len(queue)): node=queue.pop(0) if node.left: queue.append(node.left) queue.append(node.right) if i&gt;0:pre.next=node pre=node #下面这句话可加可不加 因为初始化的时候 next就是null #pre.next=None java solution1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * Definition for binary tree with next pointer. * public class TreeLinkNode &#123; * int val; * TreeLinkNode left, right, next; * TreeLinkNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public void connect(TreeLinkNode root) &#123; bfs(root); &#125; //dfs 0ms O(n) time complexity O(1) space complexity /* 1 -&gt; NULL 1 -&gt; NULL 1 -&gt; NULL / \ ---&gt; / \ ---&gt; / \ 2 3 -&gt; NULL 2 -&gt; 3 -&gt; NULL 2 -&gt; 3 -&gt; NULL / \ / \ / \ / \ / \ / \ 4 5 6 7 -&gt; NULL 4 5 6 7 -&gt; NULL 4-&gt;5-&gt;6 7 -&gt; NULL 1 -&gt; NULL / \ 2 -&gt; 3 -&gt; NULL / \ / \ 4-&gt;5-&gt;6-&gt;7 -&gt; NULL */ private void dfs(TreeLinkNode root) &#123; if(root==null)return; //把当前节点的左节点指向右节点 if(root.left!=null)root.left.next=root.right; //把当前节点的右节点指向当前节点右节点的左节点 if(root.right!=null&amp;&amp;root.next!=null)root.right.next=root.next.left; dfs(root.left); dfs(root.right); &#125; //bfs 1ms O(n) time complexity O(1) space complexity /* 1 -&gt; NULL 1 -&gt; NULL 1 -&gt; NULL / \ ---&gt; / \ ---&gt; / \ 2 3 -&gt; NULL 2 -&gt; 3 -&gt; NULL 2 -&gt; 3 -&gt; NULL / \ / \ / \ / \ / \ / \ 4 5 6 7 -&gt; NULL 4 5 6 7 -&gt; NULL 4-&gt;5-&gt;6-&gt;7 -&gt; NULL */ private void bfs(TreeLinkNode root) &#123; if(root==null)return; TreeLinkNode cur=root; while(root!=null) &#123; while(cur!=null) &#123; if(cur.left!=null)cur.left.next=cur.right; if(cur.right!=null&amp;&amp;cur.next!=null)cur.right.next=cur.next.left; cur=cur.next; &#125; cur=root.left; root=root.left; &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 130. Surrounded Regions]]></title>
    <url>%2Fvampire1996.github.io%2F2018%2F12%2F23%2Fleetcode130%2F</url>
    <content type="text"><![CDATA[130. Surrounded Regions python solution1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution(object): def solve(self, board): """ :type board: List[List[str]] :rtype: void Do not return anything, modify board in-place instead. """ """ DFS 思路整理: 1)找到所有未被包围的'O' 而这种'O'只能是从board的第一行，第一列，最后一行，最后一列 出发的一系列'O' 2)从上述位置出发进行DFS 也就是向上 向下 向左 向右移动 看接下来移动到的位置是否是'O' 若不是，则返回 3)利用isSurrounded 存储未被包围和被包围的'O'的位置 将对应位置board中元素置为'X'即可 Explanation 1)try to find all 'O's,which can only be a part of a series of 'O's started from the 1st row.1st column,last row,last column 2)start from one position,try to do BFS,which means that we are trying to move to the left,right,up and down position then check the current element,if it's 'O',set isSurrounded[i][j]=False and continue BFS else return 3)we use isSurrounded to store all positions of surrended 'O's and not surrended 'O's so just set the element to 'X' in corresponding posiotion in board """ def helper(isSurrounded,i,j): if i==0 or j==0 or i==len(board)-1 or j==len(board[0])-1:return if isSurrounded[i][j]==False or board[i][j]=='X':return isSurrounded[i][j]=False helper(isSurrounded,i+1,j) helper(isSurrounded,i,j+1) helper(isSurrounded,i-1,j) helper(isSurrounded,i,j-1) if len(board)&lt;=2 or len(board[0])&lt;=2:return isSurrounded=[[True for i in range(len(board[0]))]for j in range(len(board))] for j in range(1,len(board)-1): if board[j][0]=='O':helper(isSurrounded,j,1) if board[j][len(board[0])-1]=='O':helper(isSurrounded,j,len(board[0])-2) for i in range(1,len(board[0])-1): if board[0][i]=='O':helper(isSurrounded,1,i) if board[len(board)-1][i]=='O':helper(isSurrounded,len(board)-2,i) for j in range(1,len(board)-1): for i in range(1,len(board[0])-1): if board[j][i]=='O': if isSurrounded[j][i]==True:board[j][i]='X' java solution123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution &#123; int[][] dirs=&#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;; public void solve(char[][] board) &#123; if(board==null||board.length==0||board[0]==null||board[0].length==0) return; int row=board.length,col=board[0].length; for(int i=0;i&lt;row;i++) &#123; if(board[i][0]=='O') &#123; dfs(board,i,0); &#125; if(board[i][col-1]=='O') &#123; dfs(board,i,col-1); &#125; &#125; for(int j=0;j&lt;col;j++) &#123; if(board[0][j]=='O') &#123; dfs(board,0,j); &#125; if(board[row-1][j]=='O') &#123; dfs(board,row-1,j); &#125; &#125; for(int i=0;i&lt;row;i++) &#123; for(int j=0;j&lt;col;j++) &#123; if(board[i][j]=='O') &#123; board[i][j]='X'; &#125; else if(board[i][j]=='*') &#123; board[i][j]='O'; &#125; &#125; &#125; &#125; private void dfs(char[][] board,int i,int j) &#123; int m = board.length, n = board[0].length; board[i][j] = '*'; for(int[] dir:dirs) &#123; int x=i+dir[0]; int y=j+dir[1]; if(x&lt;0||x==m||y&lt;0||y==n|| board[x][y] != 'O')continue; dfs(board,x,y); &#125; &#125; &#125; python3 solution1234567891011121314151617181920212223class Solution: def solve(self, board): """ 找到所有未被包围的'O' 将其置为'S' """ #board=[[]] return if not any(board):return row,col=len(board),len(board[0]) save=[ij for k in range(max(row,col)) for ij in ((k,0),(0,k),(row-1,k),(k,col-1))] while save: i,j=save.pop() if 0&lt;=i&lt;row and 0&lt;=j&lt;col and board[i][j]=='O': board[i][j]='S' save.extend([(i-1,j),(i+1,j),(i,j-1),(i,j+1)]) #p=='S'=1 'XO'[1]='O' 之前将未被包围的'O'置为'S'，再将其变回来 #p=='S'=0 'XO'[0]='X' 被包围的'O'置为'X' """ board1[:]=[['XO'[p=='S'] for p in r] for r in board1] board2=[['XO'[p=='S'] for p in r] for r in board2] board1的操作是更改board1内部的值，board2的操作是重新生成一个对象赋值给board2 board2指向的地址还是原来的 """ board[:]=[['XO'[p=='S'] for p in r] for r in board]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 209. Minimum Size Subarray Sum]]></title>
    <url>%2Fvampire1996.github.io%2F2018%2F12%2F22%2Fleetcode209%2F</url>
    <content type="text"><![CDATA[209. Minimum Size Subarray Sum python solution1234567891011121314151617181920212223242526272829303132333435class Solution(object): def minSubArrayLen(self, s, nums): """ :type s: int :type nums: List[int] :rtype: int """ """ O(nlogn) 1)用numSum存储nums从第一个元素到第i个元素的和 2)利用二分查找找到与当前nums[i]相差大于等于s的最小索引end 也就是end-i为满足nums[i+1]+...nums[end]&gt;=s 的最小值 3)如果二分查找结果end==length+1 也就是说sum(nums)&lt;s 无法找到符合条件的子数组 4)二分查找一定会找到大于等于numSum[i]+s的最小索引，证明如下 numSum[i]=4 numSum[i+1]=6 target=5 lo=mi=i hi=6 numSum[mi]=4&lt;5 lo=mi+1=i+1退出 返回i+1 由于在如下二分查找算法中 取值范围是[lo,hi) 所以mi不会取到hi """ if not nums:return 0 def binarySearch(numSum,lo,hi,target): while lo&lt;hi: mi=lo+int(hi-lo)/2 if numSum[mi]&gt;=target:hi=mi else:lo=mi+1 return lo length,l=len(nums),2147483647 hi,lo=length,0 numSum=[0 for i in range(length+1)] for j in range(1,length+1):#O(n) numSum[j]=nums[j-1]+numSum[j-1] for i in range(length): end=binarySearch(numSum,i+1,length+1,numSum[i]+s) if end==length+1:break if end-i&lt;l:l=end-i return l if l!=2147483647 else 0 python3 solution123456789101112131415161718192021222324252627282930313233343536373839class Solution: def minSubArrayLen(self, s, nums): """ :type s: int :type nums: List[int] :rtype: int """ """ O(n) solution 思路整理: 1)若nums所有元素之和小于s 则不会有邻接的子序列满足sum&gt;=s 2)用numSum存储nums从第一个元素到第i个元素的和 3)numSum[end]-numSum[start] 即为从start开始到end 结束的子序列的和 如果numSum[end]-numSum[start]&gt;=s 则从start到end的序列为满足要求的序列 因此start++ 从新的位置开始计算是否符合要求 否则 end++ 继续扩展当前序列 Explanation 1)if the sum of nums is less then s, so there is no contiguous subarray of which the sum ≥ s 2)we use numSum to store the sum from the first element to the ith element 3)numSum[end]-numSum[start] represents the sum of subarray nums[start:end] if numSum[end]-numSum[start]&gt;=s,nums[start:end] satisfies the requirement so,start++,we will calculate from a new position else end++,expand the current subarray """ if not nums or sum(nums)&lt;s:return 0 length,l=len(nums),len(nums) start,end=0,1 numSum=[0 for i in range(length+1)] for j in range(1,length+1):#O(n) numSum[j]=nums[j-1]+numSum[j-1] #只有两种情况 end++ 或者start++ #因此当end 和start都为len(nums)也不过是2*len(nums)次循环 while end&lt;=length and start&lt;end: if numSum[end]-numSum[start]&gt;=s: if l&gt;end-start:l=end-start start+=1 else:end+=1 return l java solution123456789101112131415161718class Solution &#123; public int minSubArrayLen(int s, int[] nums) &#123; if(nums==null||nums.length==0)return 0; int start=0,end=0; int sum=0,min=Integer.MAX_VALUE; while (end&lt;nums.length) &#123; sum+=nums[end++]; //注意这里是while 不是if while(sum&gt;=s) &#123; min=Math.min(min,end-start); sum-=nums[start++]; &#125; &#125; return (min==Integer.MAX_VALUE)?0:min; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 357. Count Numbers with Unique Digits]]></title>
    <url>%2Fvampire1996.github.io%2F2018%2F12%2F22%2Fleetcode357%2F</url>
    <content type="text"><![CDATA[357. Count Numbers with Unique Digits python solution123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution: def countNumbersWithUniqueDigits(self, n): """ :type n: int :rtype: int """ """ 思路整理 1.若输入位数大于1 1)res第一部分是 从0-9 10个数字中取出n个数字并进行全排列combine(10,n)*factorial(n) 2)以上全排列只能包括n位中只有1个0的情况 接下来计算n位中多个0的情况 i. 0x.... x不能是0 且x之后的数位必须含一个0 因此0可以有(n-2)个位置 0之后数位必须有一个0 其余从1-9中取n-2个数进行全排列即可 combine(9,n-1)*factorial(n-2)*(n-2) ii. 00.... 因为已经有两个0 所以之后n-2位迭代执行 最高位必须为1-9 任意一个数 剩下的i-1位 从0-9 中除了上面取出的那个数中取i-1个数 并全排列 9*combine(9,i-1)*factorial(i-1) 2.若输入位数等于1 直接返回10 Explanation if n&gt;1 1)the first part is taking n numbers in 0-9 and taking purmutaion of them combine(10,n)*factorial(n) 2)the upper situation only considers the condition of one 0 then we talk about the condition when ther are more than 2 0's i. 0x.... x cannot be 0 and there must be a 0 after x, so 0 can be placed in n-2 positions, then we just taking n-2 numbers in 1-9 and take purmutaion of them ii. 00.... because there are already 2 0's,so when just iteratively conduct: the highest bit must in 1-9 the rest i-1 bits can anyone but the num in highest bit in 0-9 9*combine(9,i-1)*factorial(i-1) """ def factorial(num): res=1 for i in range(1,num+1): res*=i return res def combine(n,m): temp=min(m,n-m) res=1.0 for i in range(1,temp+1): res*=((n-i+1)/i) return int(res) res=0,0 res=combine(10,n)*factorial(n) for i in range(1,n): if i==n-1:res+=combine(9,i-1)*factorial(i-1)*(i-1) else:res+=9*combine(9,i-1)*factorial(i-1) return res+1 if n&gt;1 else res java solution12345678910111213141516171819202122232425262728/*Following the hint. Let f(n) = count of number with unique digits of length n.f(1) = 10. (0, 1, 2, 3, ...., 9)f(2) = 9 * 9. Because for each number i from 1, ..., 9, we can pick j to form a 2-digit number ij and there are 9 numbers that are different from i for j to choose from.f(3) = f(2) * 8 = 9 * 9 * 8. Because for each number with unique digits of length 2, say ij, we can pick k to form a 3 digit number ijk and there are 8 numbers that are different from i and j for k to choose from.Similarly f(4) = f(3) * 7 = 9 * 9 * 8 * 7....return f(1) + f(2) + .. + f(n)*/class Solution &#123; public int countNumbersWithUniqueDigits(int n) &#123; if(n==0)return 1; int res=10,availableBits=9,pre=9; for(int i=n;i&gt;1;i--,availableBits--) &#123; res+=availableBits*pre; pre*=availableBits; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 113. Path Sum II]]></title>
    <url>%2Fvampire1996.github.io%2F2018%2F12%2F21%2Fleetcode113%2F</url>
    <content type="text"><![CDATA[113. Path Sum II python solution1234567891011121314151617181920212223242526272829303132# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = None""" 5 / \ 4 8 / / \ 11 13 4 / \ / \7 2 5 1BFS+queuequeue是先进先出 因此遍历顺序是5-4-8-11-13-4-7-2-5-1 BFS"""class Solution(object): def pathSum(self, root, sum): if not root:return [] queue=[(root,[root.val],sum-root.val)] res=[] while queue: cur,path,num=queue.pop(0)#弹出第一个元素 if not cur.right and not cur.left and num==0: res.append(path) if cur.left: queue.append((cur.left,path+[cur.left.val],num-cur.left.val)) if cur.right: queue.append((cur.right,path+[cur.right.val],num-cur.right.val)) return res python3 solution1234567891011121314151617181920212223242526272829303132# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def pathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: List[List[int]] """ """ 思路整理:DFS recursion 1)用path缓存路径，用num保存路径和 如果当前节点为叶子结点 且路径和为sum 则在res中加入path Explanation we use to cache pat,num to store the sum of path if current node is a leaf and num==sum,just add path to res """ def helper(res,path,node,num): if not node:return if node.left==None and node.right==None: if num+node.val==sum:res.append(path+[node.val]) return helper(res,path+[node.val],node.left,num+node.val) helper(res,path+[node.val],node.right,num+node.val) res=[] helper(res,[],root,0) return res java solution1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; *//* 5 / \ 4 8 / / \ 11 13 4 / \ / \7 2 5 1DFS 由于stack是后进先出 访问次序是5-4-11-7-2-8-13-4-5-1*/class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123; List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;(); if(root==null)return res; Stack&lt;TreeNode&gt; node=new Stack&lt;TreeNode&gt;(); Stack&lt;List&lt;Integer&gt;&gt; path=new Stack&lt;List&lt;Integer&gt;&gt;(); Stack&lt;Integer&gt; num=new Stack&lt;Integer&gt;(); List&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;(); list.add(root.val); node.add(root); path.add(list); num.add(sum-root.val); //push 加到stack头部(top) add加到stack尾部(end) while(!node.isEmpty()) &#123; TreeNode cur=node.pop(); list=path.pop(); int curNum=num.pop(); if(cur.left==null&amp;&amp;cur.right==null&amp;&amp;curNum==0) &#123; res.add(new ArrayList&lt;&gt;(list)); &#125; if(cur.right!=null) &#123; list.add(cur.right.val); node.add(cur.right); path.add(new ArrayList&lt;&gt;(list)); num.add(curNum-cur.right.val); list.remove(list.size()-1); &#125; if(cur.left!=null) &#123; list.add(cur.left.val); node.add(cur.left); path.add(new ArrayList&lt;&gt;(list)); num.add(curNum-cur.left.val); list.remove(list.size()-1); &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 139. Word Break]]></title>
    <url>%2Fvampire1996.github.io%2F2018%2F12%2F21%2Fleetcode139%2F</url>
    <content type="text"><![CDATA[139. Word Break python solution12345678910111213141516171819"""DP O(n^2)---1+2+3+...+n思路整理:1)res 存储s中每个位置 到该位置能否分裂成wordDict中单词举个例子：字符串为applepen 和 wordDict为apple，pen。当我们遍历到字母n的时候我们从n开始向前找看看有没有apple：即字符串被分为app和lepen（因为apple的长度为5，我们期待lepen可能为apple，若lepen确实为apple，app也能够被break（即dp[2] = true)，那么我们将dp[7] = true,但lepen不为apple而且dp[2]为false，因此我们循环到下一个wordDict即pen，将字符串划分为前面的apple和后面的pen，而后面的pen确实存在，dp[4] = true，所以确实可以划分，因此dp[7]= true。Input: s = "leetcode", wordDict = ["leet", "code"] dp FFFFTFFFT dp[-1]=True """class Solution(object): def wordBreak(self, s, wordDict): res=[False for i in range(len(s)+1)] res[0]=True for i in range(1,len(s)+1): for j in range(i): if res[j] and s[j:i] in wordDict:res[i]=True return res[len(s)] python3 solution1234567891011121314151617class Solution(object): def wordBreak(self, s, wordDict): """ :type s: str :type wordDict: List[str] :rtype: bool """ dp=[True] max_len=max(map(len,wordDict+['']))#找到wordDict中长度最长的单词的长度 #加['']的目的是避免出现map为空的情况 words=set(wordDict)#将列表变成集合 这样访问速度变成O(1) for i in range(1,len(s)+1): #加逗号的原因是使其变成一个元祖(可迭代) #这样速度快于dp.append(x)--第二 和dp+=[x]--第三 dp+=any([dp[j] and s[j:i] in words for j in range(max(0,i-max_len),i)]), #不需要遍历i之前的每一个子串 只有[i-max_len,i]范围内的元素才能有可能和words中单词相同 return dp[-1] java solution1234567891011121314151617181920212223242526272829303132333435363738394041//BFS solution class Solution &#123; public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; int max_len=-1; for(String word :wordDict) &#123; max_len=Math.max(max_len,word.length()); &#125; Set&lt;String&gt; words=new HashSet&lt;&gt;(wordDict); Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); queue.add(0); boolean[] visited=new boolean[s.length()+1]; /* Input: s = "leetcode", wordDict = ["leet", "code"] visited FFFTFFFT max_len=4 leet eetc etco tcod code */ while(!queue.isEmpty()) &#123; int start=queue.remove();//弹出列表的第一个元素 FIFO for(int end=start+1;end-start&lt;=max_len&amp;&amp;end&lt;=s.length();end++) &#123; //visited[end]==ture 说明能到达s[end]位置 不需要判断words中是否包含子串 //当能到达end=s.length()说明成功 if(end&lt;s.length()&amp;&amp;visited[end]) continue; if(words.contains(s.substring(start,end))) &#123; if(end==s.length()) return true; queue.add(end); visited[end]=true; &#125; &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 264. Ugly Number II]]></title>
    <url>%2Fvampire1996.github.io%2F2018%2F12%2F21%2Fleetcode264%2F</url>
    <content type="text"><![CDATA[264. Ugly Number II python solution1234567891011121314151617181920212223242526272829303132333435class Solution(object): def nthUglyNumber(self, n): """ :type n: int :rtype: int """ """ 思路整理 1)用seq[0:n]存储第1个到第n个ugly number 2)计算第i个ugly number的方法是min(seq[x]*2,seq[y]*3,seq[z]*5) x,y,z是在序列中未出现的分别乘以2，3，5 的最小指针 也就是说如果seq[i]=seq[x]*2 x指针对应的元素已经乘过2 并在队列中存储了 下一个大于它且同样乘以2的元素就是seq[x+1] We have an array seq of first n ugly number. We only know, at the beginning, the first one, which is 1. Then seq[1] = min( seq[0]x2, seq[0]x3, seq[0]x5). The answer is seq[0]x2. So we move 2's pointer to 1. Then we test: seq[2] = min( seq[1]x2, seq[0]x3, seq[0]x5). And so on. Be careful about the cases such as 6, in which we need to forward both pointers of 2 and 3. """ seq=[1 for i in range(n)] p2,p3,p5=0,0,0 for i in range(1,n): num=min(seq[p2]*2,min(seq[p3]*3,seq[p5]*5)) seq[i]=num #注意以下情况不是 if elseif 的关系 而是并列的关系 #seq[p2]=3 seq[p3]=2 #2*3=6 3*2=6 seq[i]=6 所以这两种情况都已经使用过了 #因此均需要向前移动指针p2++ p3++ if num==seq[p2]*2:p2+=1 if num==seq[p3]*3:p3+=1 if num==seq[p5]*5:p5+=1 return seq[n-1] java solution12345678910111213141516class Solution &#123; public int nthUglyNumber(int n) &#123; int[] seq=new int[n]; int p2=0,p3=0,p5=0; seq[0]=1; for(int i=1;i&lt;n;i++) &#123; int num=Math.min(seq[p2]*2,Math.min(seq[p3]*3,seq[p5]*5)); seq[i]=num; if(num==seq[p2]*2)p2++; if(num==seq[p3]*3)p3++; if(num==seq[p5]*5)p5++; &#125; return seq[n-1]; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 79. Word Search]]></title>
    <url>%2Fvampire1996.github.io%2F2018%2F12%2F20%2Fleetcode79%2F</url>
    <content type="text"><![CDATA[79. Word Search python solution123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Solution(object): def exist(self, board, word): """ :type board: List[List[str]] :type word: str :rtype: bool """ """ 思路整理: 1)遍历整个board 如果满足board[i][j]==word[0]则调用helper 从i,j出发 探索所有可能的路径 2)利用字典存储满足board[i][j]==word[k]的 i,j位置 每次检测是否在字典中已经出现该位置 由于一条路径中不能有同一个位置，因此利用dict.has_key(key_value)检测是否存在相同位置 3)在每个位置 需满足3个条件才能继续递归 i.有向某一方向前进的余地 ii.向该方向前进的元素与word中下一元素相同 iii.在字典中不存在即将要前进的位置 4)当获得路径与word相同k==len(word)-1 则成功 返回True Explanation 1)traverse the whole board,if board[i][j]==word[0],call the helper 2)because he same letter cell may not be used more than once, so we use a dictionary to avoid it 3)in each position,constrains below must be satisfied to continue the recursion i.we can move to one direction without oversteping the boundary ii.the element we are moving to is the same with next element in word iii.there is no same position in dictionary 4)when we get the same path with word,we can return True """ """ dict.update(dict2)把字典dict2的键/值对更新到dict里 dict.has_key(key)如果键在字典dict里返回true，否则返回false Dict.pop(key)#pop()，()里为需要删除的key值 """ if len(word)&gt;len(board)*len(board[0]):return False def helper(i,j,k,Dict): if k==len(word)-1:return True m=(i-1)*len(board[0])+j if i&gt;0 and not Dict.has_key(m)and board[i-1][j]==word[k+1]:#up n=&#123;m:True&#125; Dict.update(n) if helper(i-1,j,k+1,Dict):return True Dict.pop(m) m=(i+1)*len(board[0])+j if i&lt;len(board)-1 and not Dict.has_key(m)and board[i+1][j]==word[k+1]:#down n=&#123;m:True&#125; Dict.update(n) if helper(i+1,j,k+1,Dict):return True Dict.pop(m) m=i*len(board[0])+j-1 if j&gt;0 and not Dict.has_key(m)and board[i][j-1]==word[k+1]:#left n=&#123;m:True&#125; Dict.update(n) if helper(i,j-1,k+1,Dict):return True Dict.pop(m) m=i*len(board[0])+j+1 if j&lt;len(board[0])-1 and not Dict.has_key(m)and board[i][j+1]==word[k+1]:#right n=&#123;m:True&#125; Dict.update(n) if helper(i,j+1,k+1,Dict):return True Dict.pop(m) return False Dict=&#123;&#125; for i in range(len(board)): for j in range(len(board[0])): if board[i][j]==word[0]: n=&#123;i*len(board[0])+j:True&#125; Dict.update(n) if helper(i,j,0,Dict):return True Dict.pop(i*len(board[0])+j) return False java solution1234567891011121314151617181920212223242526272829class Solution &#123; public boolean exist(char[][] board, String word) &#123; //String为不可变类型 需要将其转换为char数组 //length--数组长度 length()--字符串长度 char[ ] w = word.toCharArray(); for(int i=0;i&lt;board.length;i++) &#123; for(int j=0;j&lt;board[0].length;j++) if(isExist(i,j,0,board,w)) return true; &#125; return false; &#125; private boolean isExist(int i,int j,int k,char[][] board,char[] word) &#123; if (k==word.length)return true; if(i&lt;0||j&lt;0||i==board.length||j==board[0].length)return false; if(board[i][j]!=word[k])return false; //利用异或操作 将当前字符反转 避免出现使用同一个位置字符的情况 //char 8bit board[i][j]^=256; boolean result=isExist(i-1,j,k+1,board,word)|| isExist(i+1,j,k+1,board,word)|| isExist(i,j-1,k+1,board,word)|| isExist(i,j+1,k+1,board,word); //再次异或 恢复原来的值 board[i][j]^=256; return result; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 120. Triangle]]></title>
    <url>%2Fvampire1996.github.io%2F2018%2F12%2F19%2Fleetcode120%2F</url>
    <content type="text"><![CDATA[120. Triangle python solution1234567891011121314151617181920212223242526272829class Solution(object): def minimumTotal(self, triangle): """ :type triangle: List[List[int]] :rtype: int """ """ 思路整理 用cur和pre记录当前行和之前一行到达每个位置的最小路径和 pre a b c triangle[i] d e f g cur a+d min(a,b)+e min(b,c)+e c+g 按以上计算方法即可 Explanation we use cur and pre to store the minimun sum to one position in the current row and the previous row """ #O(row^2) time complexity O(row) space complexity minSum=2147483647#MAX_INT cur=[triangle[0][0]] for i in range(1,len(triangle)): pre=[m for m in cur] for j in range(len(triangle[i])): if j!=len(triangle[i])-1 and j!=0: cur[j]=min(pre[j],pre[j-1])+triangle[i][j] elif j==0:cur[j]=pre[0]+triangle[i][0] else:cur.append(pre[j-1]+triangle[i][j]) for num in cur: if minSum&gt;num:minSum=num return minSum java solution12345678910111213141516171819202122/*采用自底而上(bottom up)的动态规划算法如果已知triangle中 某一位置及其左右两个"孩子" a 则经过a到底的路径一定是a+min(b,c) b c根据这种思路 我们从triangle的最后一行开始 每个位置记录从该位置出发到底的最小路径和 则有 triangle[i][j]=min(triangle[i+1][j],triangle[i+1][j+1])+triangle[i][j] 则triangle[0][0] 最终存储的就是最小路径和*/class Solution &#123; public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; for(int i=triangle.size()-2;i&gt;=0;i--) &#123; for(int j=0;j&lt;triangle.get(i).size();j++) &#123; int self=triangle.get(i).get(j); int min=Math.min(triangle.get(i+1).get(j),triangle.get(i+1).get(j+1)); triangle.get(i).set(j,self+min); &#125; &#125; return triangle.get(0).get(0); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 78. Subsets]]></title>
    <url>%2Fvampire1996.github.io%2F2018%2F12%2F19%2Fleetcode78%2F</url>
    <content type="text"><![CDATA[78. Subsets python solution123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution(object): def subsets(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ """ Input: nums = [1,2,3,4] 思路整理 1)每次迭代在res中添加长度比当前最长list长度大1的枚举序列 2)cur 存储经过一次迭代后res中增加的list数目 prev 记录上一次迭代res的长度 3)每次迭代在res中的范围是res[len(res)_previous,len(res)_current] 4)添加的方法是遍历nums中元素 如果第k个元素索引k大于res[j]最后一个元素在nums中的索引 则添加该元素 e.g. []----&gt;[1]--------&gt;[1,2] res[0][-1]=1 2,3,4均可添加 [1,3] [1,4] [2]--------&gt;[2,3] res[1][-1]=2 3,4均可添加 [2,4] [3]--------&gt;[3,4] res[2][-1]=3 4可添加 [4] res[2][-1]=4 无元素可添加 cur=4 Explanation each time of iteration,we add one element to all element which has the longest length in res and also they should satisfy following rules: res[j][-1]&lt;k k is the index in nums j belongs to [len(res)_previous,len(res)_current] """ res=[[]] l=len(nums) prev=0 for i in range(l): temp=prev prev=len(res) for j in range(temp,len(res)): for k in range(0,l): if temp==0 or k&gt;nums.index(res[j][-1]): """ res复制已经存在的元素如res 不能用res.append(res[j]) 地址传递--修改res[j]的值 会同时改变res[-1] 而是应该用下面这种方法 创建一个新的list """ res.append([m for m in res[j]]) res[-1].append(nums[k]) return res python3 solution123456789101112131415161718192021222324252627import functools"""reduce把一个函数作用在一个序列[x1, x2, x3...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)"""class Solution: def subsets(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ """ n取自nums 迭代结果存放于subsets subsets初始化为[[]] """ """ 思路 对于一定长度为n的序列[a,b,c...]有m种子集 则长度为n+1的序列 相当于原序列添加了一个元素 因此 在原来的子集基础上有两种情况:1)加上这个元素 2)不加这个元素 因此有2m种子集 综上 长度为n的序列共有2^n种子集 以下算法的时间复杂度为O(2^n) 与递归的回溯算法相同 e.g.Input: nums = [1,2,3] Initially: [[]] Adding the first number to all the existed subsets: [[], [1]]; Adding the second number to all the existed subsets: [[], [1], [2], [1, 2]]; Adding the third number to all the existed subsets: [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]. """ return functools.reduce(lambda subsets,n:subsets+[s+[n] for s in subsets],nums,[[]]) java solution12345678910111213141516171819202122232425//backtracking --DFS的一种 用于组合排列的问题/*回溯算法Input: nums = [1,2,3]Output:[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]前一个元素的最后一个元素弹出 再加入新的元素*///O(2^n)class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;(); List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;(); backTrack(nums,0,list,res); return res; &#125; private void backTrack(int[] nums,int start,List&lt;Integer&gt; list,List&lt;List&lt;Integer&gt;&gt; res) &#123; res.add(new ArrayList&lt;Integer&gt;(list)); for(int i=start;i&lt;nums.length;i++) &#123; list.add(nums[i]); backTrack(nums,i+1,list,res); list.remove(list.size()-1); &#125; &#125;&#125; c++ solution1234567891011121314151617181920212223242526272829303132333435class Solution &#123; /* Using [1, 2, 3] as an example, 1 appears once in every two consecutive subsets, 2 appears twice in every four consecutive subsets, and 3 appears four times in every eight subsets (initially all subsets are empty)： 1两个subset一循环 2四个subset一循环 3八个subset一循环 [], [], [], [], [], [], [], [] [], [1], [], [1], [], [1], [], [1] [], [1], [2], [1, 2], [], [1], [2], [1, 2] [], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3] */ //O(n*2^n)public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; //c++中的size()和length()没有区别 int n=pow(2,nums.size()); vector&lt;vector&lt;int&gt;&gt; sets(n,vector&lt;int&gt;()); for(int i=0;i&lt;nums.size();i++) &#123; for(int j=0;j&lt;n;j++) &#123; //以2^(i+1)为周期 前2^i不添加元素(最低位为0) if(1&amp;(j&gt;&gt;i)) &#123; sets[j].push_back(nums[i]);//向量的最后添加元素 //后2^i添加元素(最低位为1) &#125; &#125; &#125; return sets; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 155. Min Stack]]></title>
    <url>%2Fvampire1996.github.io%2F2018%2F12%2F18%2Fleetcode155%2F</url>
    <content type="text"><![CDATA[155. Min Stack python solution123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051"""思路整理:1)用二维数组记录数据 每一组数据分别记录进栈时的数据 和进栈后所有数据的最小值2)getmin 只需取出最后一次进栈后所有数据的最小值self.res[-1][1]即可explanation1)we use a 2D matrix to store datas for each "push" operationwhich include the current data and the minimum data of all data in the stack2)so we can easily get the smallest data by taking self.res[-1][1] as our return data"""class MinStack(object): def __init__(self): """ initialize your data structure here. """ self.res=[] def push(self, x): """ :type x: int :rtype: void """ self.curMin=self.getMin() if x&lt;self.curMin or self.curMin==None:self.curMin=x self.res.append([x,self.curMin]) def pop(self): """ :rtype: void """ self.res.pop() def top(self): """ :rtype: int """ return self.res[-1][0] def getMin(self): """ :rtype: int """ if not self.res:return None return self.res[-1][1]# Your MinStack object will be instantiated and called as such:# obj = MinStack()# obj.push(x)# obj.pop()# param_3 = obj.top()# param_4 = obj.getMin() java solution12345678910111213141516171819202122232425262728293031323334353637383940public class MinStack &#123; int min=Integer.MAX_VALUE; //必须是Integer 不能是 int Stack&lt;Integer&gt; stack; public MinStack()&#123; stack=new Stack&lt;&gt;(); &#125; //当x&lt;=min时 min应变为x 此时将之前的min入栈 //当pop时若弹出的元素为最小值 则将当前的min置为之前入栈的x未入栈时的最小值 public void push(int x) &#123; //这里必须是&lt;= 而不能是&lt; //因为弹出时满足stack.pop()==min 的条件为x&lt;=min if(x&lt;=min)&#123; stack.push(min); min=x; &#125; stack.push(x); &#125; public void pop() &#123; if(stack.pop()==min)min=stack.pop(); &#125; public int top() &#123; return stack.peek(); &#125; public int getMin() &#123; return min; &#125;&#125;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 110. Balanced Binary Tree]]></title>
    <url>%2Fvampire1996.github.io%2F2018%2F12%2F18%2Fleetcode110%2F</url>
    <content type="text"><![CDATA[110. Balanced Binary Tree python solution12345678910111213141516171819202122232425262728293031# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isBalanced(self, root): """ :type root: TreeNode :rtype: bool """ """ 思路整理: DFS 计算每个节点的深度 如果左右子树深度之差大于1 则该树不是BBT 返回-1 只要出现一次-1 则最终返回-1 否则返回树的深度 Explanation calculate each node's depth if the absolate difference is bigger than 1,we just return -1,when there are one -1 returned, we can draw the conclusion that this tree is not a BBT """ def helper(node,depth): if not node:return depth leftdepth=helper(node.left,depth+1) rightdepth=helper(node.right,depth+1) if leftdepth==-1 or rightdepth==-1:return -1 if abs(leftdepth-rightdepth)&gt;1:return -1 return max(leftdepth,rightdepth) return True if helper(root,0)!=-1 else False java solution1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; *///用ans作为出现不平衡情况的标志位 只要ans=false则不是BBTclass Solution &#123; public boolean isBalanced(TreeNode root) &#123; helper(root); return ans; &#125; //private--访问权限仅限于类的内部 private boolean ans=true; private int helper(TreeNode root) &#123; if(root==null)return 0; int left=helper(root.left); int right=helper(root.right); if(Math.abs(left-right)&gt;1) ans=false; return Math.max(left,right)+1; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 74. Search a 2D Matrix]]></title>
    <url>%2Fvampire1996.github.io%2F2018%2F12%2F18%2Fleetcode74%2F</url>
    <content type="text"><![CDATA[74. Search a 2D Matrix python solution12345678910111213141516171819202122232425262728293031class Solution(object): def searchMatrix(self, matrix, target): """ :type matrix: List[List[int]] :type target: int :rtype: bool """ """ 思路整理 1) 当target对于matrix中某一行来说 大于等于其最小值 小于等于最大值 则在这一行进行二分搜索 2)若能找到对应元素返回真 否则返回假 explanation 1)when row[0]&lt;=target and row[-1]&gt;=target conduct binary search 2) if we can find the target in this row,return true else return false """ if not matrix or not matrix[0]:return False def binarySearch(res): lo,hi=0,len(res) while lo&lt;hi: mi=int((lo+hi)/2) if res[mi]==target:return True elif res[mi]&gt;target:hi=mi else:lo=mi+1 return False for row in matrix: if row[0]&lt;=target and row[-1]&gt;=target: return binarySearch(row) return False python3 solution123456789101112131415161718192021class Solution: def searchMatrix(self, matrix, target): &quot;&quot;&quot; :type matrix: List[List[int]] :type target: int :rtype: bool &quot;&quot;&quot; &quot;&quot;&quot; 将二维数组看成一个 m*n的一维数组进行二分搜索 O(log(m*n))=O(log(m))+O(log(n)) &quot;&quot;&quot; #// 取整除 - 返回商的整数部分（向下取整） if not matrix or not matrix[0]:return False row,col=len(matrix),len(matrix[0]) lo,hi=0,row*col while lo&lt;hi: mi=(lo+hi)//2 if matrix[mi//col][mi%col]==target:return True elif matrix[mi//col][mi%col]&gt;target:hi=mi else:lo=mi+1 return False java solution123456789101112131415161718192021222324252627282930class Solution &#123; /* 分别对行和列进行二叉搜索O(log(m))+O(log(n)) */ public boolean searchMatrix(int[][] matrix, int target) &#123; if(matrix==null||matrix.length==0)return false; if(matrix[0]==null||matrix[0].length==0)return false; int lo=0,hi=matrix.length,mi=(lo+hi)/2; while(lo&lt;hi) &#123; mi=(lo+hi)/2; if(matrix[mi][0]==target)return true; else if(matrix[mi][0]&lt;target)lo=mi+1; else hi=mi; &#125; lo=0; hi=matrix[0].length; //当matrix[mi][0]&lt;target 则在mi这一行进行搜索 //当matrix[mi][0]&gt;target 则在mi-1这一行进行搜索 int temp=matrix[mi][0]&gt;target&amp;&amp;mi&gt;0?mi-1:mi; while(lo&lt;hi) &#123; mi=(lo+hi)/2; if(matrix[temp][mi]==target)return true; else if(matrix[temp][mi]&lt;target)lo=mi+1; else hi=mi; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 539. Minimum Time Difference]]></title>
    <url>%2Fvampire1996.github.io%2F2018%2F12%2F17%2Fleetcode539%2F</url>
    <content type="text"><![CDATA[539. Minimum Time Difference python solution123456789101112131415161718192021222324252627282930313233class Solution(object): def findMinDifference(self, timePoints): """ :type timePoints: List[str] :rtype: int """ """ 思路整理: 1)对所有时间点排序 找到排序后所有相邻时间点间最小的时间差 注意还有第一个和最后一个也是相邻的 2)计算两个时间点的最小时间差 i.s1-s2&gt;12h diff=(23-hour2+hour1)*60+60-min2+min1 ii.s1-s2&lt;=12h diff=(hour2-hour1)*60+min2-min1 explanation 1)sort all time points,find the minimun difference between all adjacent time points to be noticed,the first and the last are also adjacent 2)calculate the diffenence between two adjacent time points """ def calDiff(s1,s2): hour1=(ord(s1[0])-ord('0'))*10+ord(s1[1])-ord('0') hour2=(ord(s2[0])-ord('0'))*10+ord(s2[1])-ord('0') min1=(ord(s1[3])-ord('0'))*10+ord(s1[4])-ord('0') min2=(ord(s2[3])-ord('0'))*10+ord(s2[4])-ord('0') if hour2-hour1&gt;12 or (hour2-hour1==12 and min1&lt;min2) : return (23-hour2+hour1)*60+60-min2+min1 else: return (hour2-hour1)*60+min2-min1 timePoints.sort()#升序排列 diff=calDiff(timePoints[0],timePoints[-1]) for i in range(len(timePoints)-1): diff=min(diff,calDiff(timePoints[i],timePoints[i+1])) return diff python3 solution123456789101112131415161718192021222324252627282930313233class Solution: def findMinDifference(self, timePoints): &quot;&quot;&quot; :type timePoints: List[str] :rtype: int &quot;&quot;&quot; def convert(s): return int(s[0:2])*60+int(s[3:]) &quot;&quot;&quot; map()是 Python 内置的高阶函数，它接收一个函数 f 和一个 list， 并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。 &quot;&quot;&quot; minutes=list(map(convert,timePoints)) minutes.sort() &quot;&quot;&quot; zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表 下面zip(minutes,minutes[1:]+minute[0])的含义是 返回[(mintues[0],mintues[1]),(mintues[1],mintues[2]),...(mintues[n-1],mintues[0])] 对应元素依次相减 &quot;&quot;&quot; &quot;&quot;&quot; 对于相邻时间点 都有两个时间差 min1-min2 和24*60-min1+min2 对于升序排列的两个相邻时间点其24*60-min1+min2 一定大于首元素和末元素 24*60-first+last 因此只需计算min1-min2%(24*60)=min1-min2&gt;0 对于首元素和末元素 24*60-first+last first-last&lt;0 如0-1439=-1439 而-1439%(24*60)=1 即为我们想要的结果 &quot;&quot;&quot; &quot;&quot;&quot; -9%7=-9 - 7*[-2]=5 9%-7=-9 - -7*[-2]=-5 &quot;&quot;&quot; return min((y-x)%(24*60) for x,y in zip(minutes,minutes[1:]+minutes[:1])) java solution123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public int findMinDifference(List&lt;String&gt; timePoints) &#123; //因为时间点一共有24*60个 将其转换为24*60个布尔型变量 //若在timePoints中出现 则在对应位置置为true //接下来计算timePoints中相邻时间点的差值的最小值 //同时 将最后的min与时间点的最小值与最大值的差60*24-(last-first)比较 找到二者间的最小值 //不能是last-fast 因为任意相邻的两个时间点都比它小 boolean[] mask=new boolean[24*60]; for(String time:timePoints) &#123; //praseInt() 返回值为int对象 //valueOf()返回值为Integer，可以使用Integer对象里面的所有方法， //包括转为Object对象，而int类型不能转为Object对象 String[] t=time.split(":"); int hour = Integer.parseInt(t[0]); int Min=Integer.parseInt(t[1]); if(mask[hour*60+Min]) return 0; mask[hour*60+Min]=true; &#125; int min=Integer.MAX_VALUE,first=Integer.MAX_VALUE,last=Integer.MIN_VALUE,pre=Integer.MAX_VALUE; for(int i=0;i&lt;60*24;i++) &#123; if(mask[i]) &#123; if(first!=Integer.MAX_VALUE) &#123; min=Math.min(min,i-pre); &#125; first=Math.min(i,first); last=Math.max(i,last); pre=i; &#125; &#125; min=Math.min(min,60*24-(last-first)); return min; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 134. Gas Station]]></title>
    <url>%2Fvampire1996.github.io%2F2018%2F12%2F17%2Fleetcode134%2F</url>
    <content type="text"><![CDATA[134. Gas Station python solution123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution(object): def canCompleteCircuit(self, gas, cost): """ :type gas: List[int] :type cost: List[int] :rtype: int """ """ 思路整理: 1)如果sum(gas+cost)&gt;=0 一定有方案可以从某一位置出发回到该位置 证明: i.假设下面部分和为最小 gas[0]-cost[0]+gas[1]-cost[1]+...+gas[i]-cost[i] ii.则开始位置为start=i+1 且满足gas[i+1]-cost[i+1]&gt;=0 (若gas[i+1]-cost[i+1]&lt;0,则0-i不是最小) 以下各不等式均应该满足 --也就是能从i+1到最后 gas[i+1]-cost[i+1]&gt;=0 gas[i+1]-cost[i+1]+gas[i+2]-cost[i+2]&gt;=0 ....... gas[i+1]-cost[i+1]+gas[i+2]-cost[i+2]+...+gas[n-1]-cost[n-1]&gt;=0 (从i+1到之后的任意一个位置均应该大于等于0,若小于0 则则0-i不是最小) 同时有(因为从0-i之和为最小 任何j&lt;i均满足下列不等式) gas[0]-cost[0]+gas[1]-cost[1]+...+gas[j]-cost[j] + gas[i+1]-cost[i+1]+...+gas[n-1]-cost[n-1] &gt;= gas[0]-cost[0]+gas[1]-cost[1]+...+gas[i]-cost[i] + gas[i+1]-cost[i+1]+...+gas[n-1]-cost[n-1]=sum(gas+cost) &gt;=0 由上可知 gas[i+1]-cost[i+1]&gt;=0, gas[i+1]-cost[i+1]+gas[i+2]-cost[i+2]&gt;=0, gas[i+1]-cost[i+1]+gas[i+2]-cost[i+2]+...+gas[n-1]-cost[n-1]&gt;=0, ... gas[i+1]-cost[i+1]+...+gas[n-1]-cost[n-1] + gas[0]-cost[0]+gas[1]-cost[1]+...+gas[j]-cost[j]&gt;=0, ... 从i+1出发可以到达0-i的任意一个位置 得证 """ tank,total,start=0,0,0 for i in range(len(gas)): tank=tank+gas[i]-cost[i] if tank&lt;0: total+=tank tank=0 start=i+1 return -1 if tank+total&lt;0 else start java solution12345678910111213141516171819202122232425class Solution &#123; /* 思路整理:贪心算法 从start开始走尽可能远的位置(sum&gt;=0) 当无法再前进(sum&lt;0)start向后退一位 也就是从新的位置开始出发 当start与end相遇 则可从start出发回到该位置(前提sum&gt;=0) */ public int canCompleteCircuit(int[] gas, int[] cost) &#123; int start=gas.length-1,end=0; int sum=gas[start]-cost[start]; while(start&gt;end) &#123; if(sum&gt;=0) &#123; sum+=gas[end]-cost[end]; end++; &#125; else &#123; start--; sum+=gas[start]-cost[start]; &#125; &#125; return sum&gt;=0?start:-1; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 199. Binary Tree Right Side View]]></title>
    <url>%2Fvampire1996.github.io%2F2018%2F12%2F17%2Fleetcode199%2F</url>
    <content type="text"><![CDATA[199. Binary Tree Right Side View python solution12345678910111213141516171819202122232425262728293031323334353637383940# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def rightSideView(self, root): """ :type root: TreeNode :rtype: List[int] """ """ 思路整理 1)对二叉树进行先序遍历(root--left--right) 2)将每一层的最后一个元素加到res队尾 explanation 1)take the preorder trversal for the binary tree 2)add the last element to res in stack Input: 1 stack=[1] res=[1] / \ 2 3 stack=[2,3] res=[1,3] \ \ 5 4 stack=[5,4] res=[1,3,4] """ if not root:return [] stack=[root] res=[root.val] while stack: k=len(stack) for i in range(k): #pop() 函数用于移除列表中的一个元素（默认最后一个元素） node=stack.pop(0)#移除列表中的第一个元素 if node.left:stack.append(node.left) if node.right:stack.append(node.right) if stack: res.append(stack[-1].val) return res java solution12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; *//*1.Each depth of the tree only select one node.2. View depth is current size of result list.*/class Solution &#123; public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; //Vector主要用在事先不知道数组的大小，或者只是需要一个可以改变大小的数组的情况。 //创建一个默认的向量，默认大小为10： ArrayList res = new ArrayList&lt;Integer&gt;(); helper(res,root,0); return res; &#125; //DFS-traverse the tree right-to-left, add values to the res whenever we first reach a new record depth. //当depth第一次增加1 即到达下一层时 添加最右边的元素到res public void helper(ArrayList res,TreeNode node,int depth) &#123; if(node!=null) &#123; // size()是集合的方法,可以返回集合中对象的数量 length()是数组的方法,返回数组的长度 if(res.size()==depth) &#123; res.add(new Integer(node.val)); &#125; helper(res,node.right,depth+1); helper(res,node.left,depth+1); &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 522. Longest Uncommon Subsequence II]]></title>
    <url>%2Fvampire1996.github.io%2F2018%2F12%2F17%2Fleetcode522%2F</url>
    <content type="text"><![CDATA[522. Longest Uncommon Subsequence II python solution123456789101112131415161718192021222324252627282930313233class Solution: def findLUSlength(self, strs): """ :type strs: List[str] :rtype: int """ def isSubsequence(s1,s2): """ iter() 函数用来生成迭代器 s会返回s2的下一个值 if t was '1234' and we check whether '3' is in T = iter(t), after we will have next(T) = '4', not '1' """ s=iter(s2) """ all(iterable) returns true if and only if every element of the iterable is truthy. 也就是说只有s1中每个元素都依次和s2的元素匹配 则s1为s2的子串 但是要注意["aaa","aaa","aa"]这种情况 "aa"是"aaa"的子串 "aaa"不是是"aa"的子串 当s1="aa" s2="aaa" all(c in s2 for c in s1) 为真--因此要用这种写法 all(c in s1 for c in s2) 为假--s2取到最后一个a时s1已经没有可迭代的元素了 """ return all(c in s for c in s1) #以字符的长度排序 reverse=True代表长度从大到小--降序 strs.sort(key=len,reverse=True) for s1 in strs: """ 如果s1(当前最长的串)不是其他所有串的子串(只是他自己的子串--sum==1) 则返回其长度即为最长uncommon subsequence """ if sum(isSubsequence(s1,s2) for s2 in strs)==1: return len(s1) return -1 java solution123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public int findLUSlength(String[] strs) &#123; // reverse sorting array with length Arrays.sort(strs,new Comparator&lt;String&gt;() &#123; public int compare(String s1,String s2) &#123; //s2.length()-s1.length()--倒序 s1.length()-s2.length()--正序 //int compare(T o1, T o2) 是比较o1和o2的大小 //如果返回值为负数意味着o1比o2小，否则返回为零意味着o1等于o2，返回为正数意味着o1大于o2 //假如o1的值大于o2，你返回1，此时调用Collections.sort()函数就是升序；假如o1的值大于o2，你返回-1，此时调用Collections.sort()函数就是降序。 return s2.length()-s1.length(); &#125; &#125;); for(int i=0;i&lt;strs.length;i++) &#123; int cnt=strs.length-1; for(int j=0;j&lt;strs.length;j++) &#123; if(i!=j&amp;&amp;isSubsequence(strs,i,j)==false) cnt--; &#125; // strs[i] is not a sub sequence of any other entry if(cnt==0)return strs[i].length(); &#125; return -1; &#125; public boolean isSubsequence(String[] strs,int i,int j) &#123; if(strs[i].length()&gt;strs[j].length())return false; int k=0; for(char ch:strs[j].toCharArray()) if(k&lt;strs[i].length()&amp;&amp;ch==strs[i].charAt(k)) &#123; k++; &#125; return k==strs[i].length(); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 234. Palindrome Linked List]]></title>
    <url>%2Fvampire1996.github.io%2F2018%2F12%2F15%2Fleetcode234%2F</url>
    <content type="text"><![CDATA[234. Palindrome Linked List python solution123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def isPalindrome(self, head): """ :type head: ListNode :rtype: bool """ """ Input: 1-&gt;2-&gt;2-&gt;1 (1) Input: 1-&gt;2-&gt;3-&gt;2-&gt;1 (2) 思路整理: 1)首先找到链表的中间节点slow 偶数个节点(1) slow=2-&gt;2-&gt;1 奇数个节点(2) slow=3-&gt;2-&gt;1 2)翻转链表的第二部分 e.g. slow=4-&gt;3-&gt;2-&gt;1 fast=slow.next=3-&gt;2-&gt;1 temp=slow.next temp=3-&gt;2-&gt;1 temp=2-&gt;3-&gt;1 slow.next=fast.next slow=4-&gt;2-&gt;1 slow=4-&gt;1 fast.next=fast.next.next fast=3-&gt;1 fast=3 slow.next.next=temp slow=4-&gt;2-&gt;3-&gt;1 slow=4-&gt;1-&gt;2-&gt;3 3)比较第一部分和第二部分，完全相同则为回文，否则不是 Explanation 1)find the middle find the middle of the linked list when the number of nodes are odd slow=2-&gt;2-&gt;1 when the number of nodes are even slow=3-&gt;2-&gt;1 2)reverse the second part 3)compare the 1st and the 2nd part """ if not head:return True slow,fast=head,head #find the middle of the linked list while fast.next and fast.next.next: slow=slow.next fast=fast.next.next fast=slow.next #reverse the second part while fast and fast.next: temp=slow.next slow.next=fast.next fast.next=fast.next.next slow.next.next=temp #compare the 1st and the 2nd part fast=slow.next slow=head while fast: if slow.val!=fast.val:return False slow=slow.next fast=fast.next return True python3 solution12345678910111213141516171819202122232425262728293031# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def isPalindrome(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: bool &quot;&quot;&quot; &quot;&quot;&quot; Input: 1-&gt;2-&gt;2-&gt;1 Input: 1-&gt;2-&gt;3-&gt;2-&gt;1 思路整理: 1)rev存储链表的前半部分翻转后的结果 rev=2-&gt;1 slow存储 链表的后半部分 slow=2-&gt;1 2)这种算法并没有改变原链表的结构 而是构建以rev为链表头的链表 3)当节点数为偶数fast=None slow=2-&gt;1 当节点数为偶数fast=1 slow=3-&gt;2-&gt;1 因此slow=slow.next=2-&gt;1 &quot;&quot;&quot; rev,fast,slow=None,head,head while fast and fast.next: fast=fast.next.next rev,rev.next,slow=slow,rev,slow.next if fast:slow=slow.next while rev and rev.val==slow.val: rev=rev.next slow=slow.next return not rev java solution123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isPalindrome(ListNode head) &#123; if(head==null)return true; ListNode slow=head,fast=head; while(fast.next!=null&amp;&amp;fast.next.next!=null) &#123; slow=slow.next; fast=fast.next.next; &#125; fast=slow.next; while(fast!=null&amp;&amp;fast.next!=null) &#123; ListNode next=slow.next; slow.next=fast.next; fast.next=fast.next.next; slow.next.next=next; &#125; fast=slow.next; slow=head; while(fast!=null) &#123; if(fast.val!=slow.val) return false; slow=slow.next; fast=fast.next; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 64. Minimum Path Sum]]></title>
    <url>%2Fvampire1996.github.io%2F2018%2F12%2F14%2Fleetcode64%2F</url>
    <content type="text"><![CDATA[64. Minimum Path Sum python solution12345678910111213141516171819202122232425262728293031323334353637383940class Solution(object): def minPathSum(self, grid): """ :type grid: List[List[int]] :rtype: int """ """ 思路整理 res用于存储grid中每一行每个位置到达该位置的最小sum值 Input: res [ [1,3,1], [1,4,5] [1,5,1], [2,7,6] [4,2,1] [6,8,7] ] 1)对于第一行或第一列 res的值可由grid[0][i]+res[i-1](右侧值+当前grid值) 或 grid[j][0]+res[0](上方值+当前grid值)求得 2)对于其它情况 res值 为res[i]+grid[j][i](上方值+当前grid值) 和res[i-1]+grid[j][i](右侧值+当前grid值) 二者之间的最小值 Explanation we use res to store the minimum sum of each position in grid 1)for grid[0][i] or grid[j][0],we can simply use grid[0][i]+res[i-1] and grid[j][0]+res[0] to calculate them 2) for other situation,res[i]=min(res[i]+grid[j][i],res[i-1]+grid[j][i]) the sum of one particular position,there are only tow potential previous position (either from its top or its left side),so we just take the small one """ if not grid:return 0 row=len(grid) col=len(grid[0]) res=[0 for i in range(col)] res[0]=grid[0][0] for i in range(1,col):res[i]=grid[0][i]+res[i-1] for j in range(1,row): res[0]=grid[j][0]+res[0] for i in range(1,col): res[i]=res[i]+grid[j][i] if res[i]&lt;res[i-1] else res[i-1]+grid[j][i] return res[col-1] java solution1234567891011121314151617class Solution &#123; public int minPathSum(int[][] grid) &#123; int row=grid.length; int col=grid[0].length; for(int i=0;i&lt;row;i++) &#123; for(int j=0;j&lt;col;j++) &#123; if(i==0&amp;&amp;j==0)continue; else if(i==0&amp;&amp;j&gt;0) grid[0][j]+=grid[0][j-1]; else if(i&gt;0&amp;&amp;j==0) grid[i][0]+=grid[i-1][0]; else grid[i][j]=Math.min(grid[i-1][j]+grid[i][j],grid[i][j]+grid[i][j-1]); &#125; &#125; return grid[row-1][col-1]; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 106. Construct Binary Tree from Inorder and Postorder Traversal]]></title>
    <url>%2Fvampire1996.github.io%2F2018%2F12%2F14%2Fleetcode106%2F</url>
    <content type="text"><![CDATA[106. Construct Binary Tree from Inorder and Postorder Traversal python solution123456789101112131415161718192021222324# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def buildTree(self, inorder, postorder): """ :type inorder: List[int] :type postorder: List[int] :rtype: TreeNode """ """ 利用pop()操作 依次从postorder中取出元素因此不需要计算左右子树的范围 注意要先计算右子树再计算左子树 """ if not inorder or not postorder:return None node=TreeNode(postorder.pop()) i=inorder.index(node.val) node.right=self.buildTree(inorder[i+1:], postorder) node.left=self.buildTree(inorder[:i], postorder) return node python3 solution12345678910111213141516171819202122232425262728293031323334353637383940414243444546# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def buildTree(self, inorder, postorder): &quot;&quot;&quot; :type inorder: List[int] :type postorder: List[int] :rtype: TreeNode &quot;&quot;&quot; &quot;&quot;&quot; 思路整理: 1)[lo,hi]代表postorder当前要处理的元素范围 postorder[hi] 为当前函数的根节点 [start,end]代表inorder当前要处理的元素范围 在inorder中找到postorder[hi]对应的秩index 则end-index 为右子树的长度 [hi-(end-index),hi-1]即为postorder中右子树的范围 同理[lo,hi-(end-index)-1]即为postorder中左子树的范围 而[index+1,end]为inorder中右子树的范围 [start,index-1]为inorder中左子树的范围 e.g. lo=0 hi=4 start=0 end=4 inorder = [9,3,15,20,7] index(postorder[hi])=1 end-index=3 postorder = [9,15,7,20,3] node.val=postorder[hi]=3 则postorder中右子树的范围 [hi-(end-index),hi-1]=[1,3]=[3,15,20] postorder中左子树的范围 [lo,hi-(end-index)-1]=[0,0]=[9] 则inorder中右子树的范围 [index+1,end]=[2,4]=[3,15,20] inorder中左子树的范围 [start,index-1]=[0,0]=[9] Explanation 1)[lo,hi]represents the range of elements in postorder postorder[hi] is current root [start,end]represents the range of elements in inorder thus end-index is the length of right child [hi-(end-index),hi-1] is the range of right child in postorder [lo,hi-(end-index)-1] is the range of left child in postorder &quot;&quot;&quot; if not inorder:return None def helper(lo,hi,start,end): if lo&gt;hi or start&gt;end:return None node=TreeNode(postorder[hi]) index=inorder.index(postorder[hi]) node.right=helper(hi-(end-index),hi-1,index+1,end) node.left=helper(lo,hi-(end-index)-1,start,index-1) return node return helper(0,len(inorder)-1,0,len(inorder)-1) java solution1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode buildTree(int[] inorder, int[] postorder) &#123; if(inorder==null||postorder==null)return null; HashMap&lt;Integer,Integer&gt; map=new HashMap&lt;Integer,Integer&gt;(); for(int i=0;i&lt;inorder.length;i++) &#123; map.put(inorder[i],i); &#125; return helper(0,inorder.length-1,0,inorder.length-1,map,inorder,postorder); &#125; private static TreeNode helper(int lo,int hi,int start,int end,HashMap&lt;Integer,Integer&gt; map,int[] inorder, int[] postorder) &#123; if(lo&gt;hi||start&gt;end) return null; TreeNode node=new TreeNode(postorder[hi]); int index=map.get(postorder[hi]); node.right=helper(hi-(end-index),hi-1,index+1,end,map,inorder,postorder); node.left=helper(lo,hi-(end-index)-1,start,index-1,map,inorder,postorder); return node; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem 91. Decode Ways]]></title>
    <url>%2Fvampire1996.github.io%2F2018%2F12%2F14%2Fleetcode91%2F</url>
    <content type="text"><![CDATA[91. Decode Ways python solution12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution: def numDecodings(self, s): """ :type s: str :rtype: int """ """ 思路整理: 1)用cnt[len(s)]存储截止到s[i](包括s[i])所有可能的编码数 2)对于任意s[i] i.若 '1'&lt;=s[i]&lt;='9' 则s[i]都可以直接单独加到之前的编码队列--cnt[i-1] 同时,若s[i-1]=='1' 或者 s[i-1]=='2' and '1'&lt;=s[i]&lt;='6' 则s[i],s[i-1]二者可以结为1个编码 但前提是s[i-1]未与s[i-2]结合 此时我们用twoDigits记录之前的编码队列的s[i-1]与s[i-2]结合成的两位数 cnt[i-1]-twoDigits即为s[i-1]未与s[i-2]结合的数目--temp 则cnt[i]=cnt[i-1]+temp 同时temp可作为下一次迭代时的twoDigits ii.若 's[i]=='0' s[i]只能和s[i-1]结为1个编码 因此,cnt[i]=temp Explanation 1)we use cnt[len(s)] to store all possible decode ways up to s[i](include s[i]) 2)for every s[i] i.if '1'&lt;=s[i]&lt;='9' s[i] can add the formal decoding list seprately--cnt[i-1] meanwhile,if s[i-1]=='1' or(s[i-1]=='2' and '1'&lt;=s[i]&lt;='6') we can combine s[i] with s[i-1] to one number but we should ensure that s[i-1] and s[i-2] are not combined we use twoDigits to represent the number of combinations between s[i-1] and s[i-2],so cnt[i-1]-twoDigits is the number of which s[i-1] and s[i-2] are not combined so cnt[i]=cnt[i-1]+temp to be noticedw,temp can the next twoDigits ii.if 's[i]=='0' s[i] can one combines with s[i-1] thus cnt[i]=temp """ if not s or s[0]=='0':return 0 l=len(s) last=s[0] twoDigits=0 cnt=[0 for i in range(l)] cnt[0]=1 for i in range(1,l): #连续两个0 或者0之前为一大于2的数 if s[i]=='0' and (last=='0' or ord(last)&gt;ord('2')): return 0 if last=='1':temp=cnt[i-1]-twoDigits elif last=='2' and ord(s[i])&lt;ord('7'):temp=cnt[i-1]-twoDigits else:temp=0 cnt[i]=cnt[i-1]+temp if s[i]!='0' else temp twoDigits=temp last=s[i] return cnt[l-1] java solution123456789101112131415161718192021222324252627282930class Solution &#123; public int numDecodings(String s) &#123; if(s==null)return 0; int l=s.length(); int dp[]=new int[l]; //dp[l]每个元素均初始化为0 dp[0]=s.charAt(0)=='0'?0:1; //对于000123这种情况 由于dp[0:2]均为0 因此dp[3:5]也均为0--dp[i]+=dp[i-1/2]; for(int i=1;i&lt;l;i++) &#123; /* public String substring(int beginIndex, int endIndex) 左闭右开 第一个int为开始的索引，对应String数字中的开始位置，--能取到 第二个是截止的索引位置，对应String中的结束位置--取不到 */ /* Integer.valueOf(s)把字符串s解析成Integer对象类型， 返回的integer 可以调用对象中的方法。 */ int first=Integer.valueOf(s.substring(i,i+1)); //取出当前元素并转换为整型--一位数 int second=Integer.valueOf(s.substring(i-1,i+1)); //取出当前元素及其之前元素并转换为整型--两位数 if(first&gt;=1&amp;&amp;first&lt;=9) dp[i]+=dp[i-1]; //符合要求区间，可直接加到之前编码队列 if(second&gt;=10&amp;&amp;second&lt;=26) dp[i]+=i&gt;1?dp[i-2]:1; &#125; return dp[l-1]; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用hexo搭建个人博客]]></title>
    <url>%2Fvampire1996.github.io%2F2018%2F12%2F14%2F%E5%88%A9%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[参考 博客插图由于所有的博客都是使用 markdown 进行编辑的，而 markdown 的插图一般需要外链，下面提供三种插图方法：在 source 文件夹中建立 images 文件夹，把需要插入的图片放到该文件夹中，然后通过相对路径 /images/image_name 进行访问。这种方法是最简单的，但由于 github page 一般空间限制为 1G，所以当图片比较多时这种方法不太合适。把图片上传到第三方图床，网上很多人推荐七牛网，但似乎目前免费空间只有1G了，如果图片较多就需要花钱了。另外，这些第三方图床说不定什么时候倒闭了或者被墙了就麻烦了。直接使用 github 当图床，其实就是创建一个新的 repository，可以命名为 blog_images，然后直接通过网页把需要插入的图片上传到该 repository 中。下面说一下如何获取访问地址，首先进入新建的 repository，点开需要插入的那张图片，复制浏览器中地址栏中的地址，把地址中的 blob 改成 raw 就好了，这一步很重要。虽然每个 repository 也有 1G 容量的限制，但是 reposiroty 的数量是没有限制的，你懂的。个人比较推荐这种方法。正常情况下，markdown 插入图片的语法是1![title](address) 但这种方法不能改变插入图片的大小和位置。因此我们可以通过下面的 html 语句来设置插入图片的格式： 1&lt;img src="address" width=50% height=50% align=center/&gt; 这条语句可以实现图片大小的设置 使用Pandoc渲染公式仅仅使用Mathjax渲染公式效果不好，公式稍微复杂就会出现问题。因此使用hexo-renderer-pandoc。参考我用的时候使用以下命令会报错1cnpm uninstall hexo-renderer-marked --save 直接在bash中使用1cnpm install hexo-renderer-pandoc --save Hexo中添加本地图片1 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true2 在你的hexo目录下执行这样一句话npm install hexo-asset-image –save，这是下载安装一个可以上传本地图片的插件，来自dalao：dalao的git3 等待一小段时间后，再运行hexo n “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹4 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：1![你想输入的替代文字](xxxx/图片名.jpg) 注意： xxxx是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。5 最后检查一下，hexo g生成页面后，进入public\2017\02\26\index.html文件中查看相关字段，可以发现，html标签内的语句是1&lt;img src="2017/02/26/xxxx/图片名.jpg"&gt; 而不是&lt;img src=”xxxx/图片名.jpg&gt;。这很重要，关乎你的网页是否可以真正加载你想插入的图片。 注意事项1.hexo部署和生成有时仅仅使用下面两句实现hexo部署和生成刷新博客并没有变化12hexo ghexo d 可以采用如下方法，现在本地观察有没有变化，再部署到coding/github123hexo ghexo shexo d 也可以先清楚缓存，再部署123hexo clean hexo ghexo d 博客加密 方法 在博客中插入公式在hexo中使用LaTex的方法(1)在blog目录下以管理员身份打开bash(2)下载自动部署MathJax的hexo插件(我电脑用npm会报错，这里用国内镜像cnpm就好)使用命令1cnpm install hexo-math --save (3)使Marked.js与MathJax共存 针对下划线的问题，我决定取消作为斜体转义，因为marked.js中*也是斜体的意思，所以取消掉的转义并不影响我们使用markdown，只要我们习惯用*作为斜体字标记就行了。 针对marked.js与Mathjax对于个别字符二次转义的问题，我们只要不让marked.js去转义\,{,}在MathJax中有特殊用途的字符就行了。具体修改方式，用编辑器打开marked.js（在./node_modules/marked/lib/中） Step 1:1escape: /^\\([\\`*&#123;&#125;\[\]()# +\-.!_&gt;])/, 替换成1escape: /^\\([`*\[\]()# +\-.!_&gt;])/, Step 2:1em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, 替换成1em:/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, (4)更改配置文件进入到主题目录(如themes/next)，找到_config.yml配置问题，把mathjax默认的false修改为true，并更换cdn的url，具体如下：123456# MathJax Supportmathjax: enable: true per_page: true #cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML cdn: //cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML (5)写博客在每次需要用LaTeX渲染的博文中，在文章的Front-matter里打开mathjax开关，具体如下：123456---title: index.htmldate: 2018-2-8 21:01:30tags:mathjax: true-- (6)测试1$$lim_&#123;1\to+\infty&#125;P(|\frac&#123;1&#125;&#123;n&#125;\sum_i^nX_i-\mu|&lt;\epsilon)=1, i=1,...,n$$ 效果$$lim_{1\to+\infty}P(|\frac{1}{n}\sum_i^nX_i-\mu|&lt;\epsilon)=1, i=1,…,n$$ 使用Latex最全 Markdown + Latex 编写技巧在线latex公式编辑]]></content>
      <categories>
        <category>建立博客</category>
      </categories>
      <tags>
        <tag>-blog</tag>
      </tags>
  </entry>
</search>
